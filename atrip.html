<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-11-04 Thu 15:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ATRIP: An MPI-asynchronous implementation of CCSD(T)</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">ATRIP: An MPI-asynchronous implementation of CCSD(T)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0200180">1. Implementation</a>
<ul>
<li><a href="#orgd6c4d50">1.1. The slice</a>
<ul>
<li><a href="#org37b23cd">1.1.1. Introduction</a></li>
<li><a href="#org8243e38">1.1.2. Location</a></li>
<li><a href="#org8c4991d">1.1.3. Type</a></li>
<li><a href="#orgb3dfdd3">1.1.4. State</a></li>
<li><a href="#org2fe4da6">1.1.5. The Info structure</a></li>
<li><a href="#orged8bc78">1.1.6. Name</a></li>
<li><a href="#orgeeafd9b">1.1.7. Database</a></li>
<li><a href="#org361c29b">1.1.8. MPI Types</a></li>
<li><a href="#orgaaf3fdd">1.1.9. Static utilities</a></li>
<li><a href="#org89b1eb4">1.1.10. Attributes</a></li>
<li><a href="#org8bb7fbe">1.1.11. Member functions</a></li>
</ul>
</li>
<li><a href="#orgf779156">1.2. Utils</a>
<ul>
<li><a href="#orgb42cad4">1.2.1. Pretty printing</a></li>
<li><a href="#orgcb5faf7">1.2.2. Chrono</a></li>
</ul>
</li>
<li><a href="#orgbb82e63">1.3. The rank mapping</a></li>
<li><a href="#orgf384cdc">1.4. The slice union</a></li>
<li><a href="#org9af5999">1.5. Tuples</a>
<ul>
<li><a href="#orgd1c7f44">1.5.1. Tuples types</a></li>
<li><a href="#org4b9e24d">1.5.2. Distributing the tuples</a></li>
<li><a href="#orgce410c7">1.5.3. Node information</a></li>
<li><a href="#orgd1b9d08">1.5.4. Naive list</a></li>
<li><a href="#org8f0e940">1.5.5. Group and sort list</a></li>
</ul>
</li>
<li><a href="#orgff9d736">1.6. Unions</a></li>
<li><a href="#orgda4af1f">1.7. Equations</a></li>
<li><a href="#orgcc16f04">1.8. Blas</a></li>
<li><a href="#org9a888d9">1.9. Atrip</a>
<ul>
<li><a href="#orga754d1d">1.9.1. Main</a></li>
</ul>
</li>
<li><a href="#org0de53b1">1.10. Debug</a></li>
<li><a href="#orgd6baa53">1.11. Include header</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0200180" class="outline-2">
<h2 id="org0200180"><span class="section-number-2">1</span> Implementation</h2>
<div class="outline-text-2" id="text-1">
<p>
The algorithm uses two main data types, the <code>Slice</code> and the
<code>SliceUnion</code> as a container and resource manager of the <code>Slice</code>.
</p>
</div>

<div id="outline-container-orgd6c4d50" class="outline-3">
<h3 id="orgd6c4d50"><span class="section-number-3">1.1</span> The slice</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The following section introduces the idea of a slice.
</p>
</div>

<div id="outline-container-org37b23cd" class="outline-4">
<h4 id="org37b23cd"><span class="section-number-4">1.1.1</span> Introduction</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
A slice is the concept of a subset of values of a given tensor.
As an example, for the doubles amplitudes \( T^{ab}_{ij} \), one need two kinds of objects:
</p>
<ul class="org-ul">
<li>the object \( \mathsf{T}(a)^b_{ij} \) which for every \( a \) gets assigned the
tensor \( T^{ab}_{ij} \) of size \( N_\mathrm{o}^2 \times N_\mathrm{v} \)</li>

<li>the object \( \mathsf{T}(a,b)_{ij} \) which for every pair of \( a, b \)
corresponds the \( N_\mathrm{o}^2 \)-sized tensor \( T^{ab}_{ij} \).</li>
</ul>
</div>
</div>

<div id="outline-container-org8243e38" class="outline-4">
<h4 id="org8243e38"><span class="section-number-4">1.1.2</span> Location</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Every slice set, for instance,
\( S_k = \left\{
    a \mapsto \mathsf{T}(a)^{b}_{ij}
    \mid
    a \in A_k
\right\} \)
where \( A_k \) is some subset of
\( \mathsf{N}_\mathrm{v} \),
gets stored in some rank \( k \).
In general however, the number of elements in \( A_k \) can be bigger
than the number of processes \( n_p \). Therefore in order to uniquely
indentify a given slice in \( S_k \) we need two identifiers,
the rank \( k \), which tells us in which core's memory the slice is
allocated, and an additional tag which we will call <code>source</code>.
</p>

<p>
The datatype that simply models this state of affairs
is therefore a simple structure:
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Location</span> { <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>; <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">source</span>; };
</pre>
</div>
</div>
</div>

<div id="outline-container-org8c4991d" class="outline-4">
<h4 id="org8c4991d"><span class="section-number-4">1.1.3</span> Type</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Due to the permutation operators in the equations
it is noticeable that for every one dimensional
slice and triple \( (a,b,c) \)
</p>
\begin{equation*}
a \mapsto \mathsf{t}(a)
\end{equation*}
<p>
one needs at the same time
\( \mathsf{t}(a) \),
\( \mathsf{t}(b) \) and
\( \mathsf{t}(c) \).
For two dimensional slices, i.e., slices of the form
</p>
\begin{equation*}
(a,b) \mapsto \mathsf{t}(a,b)
\end{equation*}
<p>
one needs in the equations the slices
\( \mathsf{t}(a,b) \),
\( \mathsf{t}(b,c) \) and
\( \mathsf{t}(a,c) \).
In addition, in the case of diagrams where
the integral \( V^{ab}_{ci} \) appears,
we additionaly need the permuted slices
from before, i.e.
\( \mathsf{t}(b,a) \),
\( \mathsf{t}(c,b) \) and
\( \mathsf{t}(c,a) \).
</p>

<p>
This means, every slice has associated with it
a type which denotes which permutation it is.
</p>


<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a626a4;">enum</span> <span style="color: #c18401;">Type</span>
    { <span style="color: #8b4513;">A</span> = 10
    , <span style="color: #8b4513;">B</span>
    , <span style="color: #8b4513;">C</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Two-parameter slices</span>
    , <span style="color: #8b4513;">AB</span> = 20
    , <span style="color: #8b4513;">BC</span>
    , <span style="color: #8b4513;">AC</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for abci and the doubles</span>
    , <span style="color: #8b4513;">CB</span>
    , <span style="color: #8b4513;">BA</span>
    , <span style="color: #8b4513;">CA</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">The non-typed slice</span>
    , <span style="color: #8b4513;">Blank</span> = 404
    };
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3dfdd3" class="outline-4">
<h4 id="orgb3dfdd3"><span class="section-number-4">1.1.4</span> State</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
Every slice can be in different states and every state
denotes which function the slice is going to provide
and which relations they have between themselves.
</p>

<dl class="org-dl">
<dt>Fetch</dt><dd>A slice is in state <code>Fetch</code> when it
has a valid data pointer that <b><b>must</b></b> be written to.
A <code>Fetch</code> slice should not live very long, this means
that after the database send and receive phase,
<code>Fetch</code> slices should be changed into <code>Dispatched</code>
in order to start the process of writing to the
data pointer from some other rank.</dd>
<dt>Dispatched</dt><dd>A <code>Dispatched</code> slice indicates that at some point
send and receive MPI calls have been dispatched
in order to get the data.
However, the calls have just been dispatched and there
is no warranty for the data to be there, for that,
the slice must be unwrapped.</dd>
<dt>Ready</dt><dd><code>Ready</code> means that the data pointer can be read from
directly.</dd>
<dt>SelfSufficient</dt><dd>A slice is <code>SelfSufficient</code> when its contents are located
in the same rank that it lives, so that it does not have to
fetch from no other rank.
This is important in order to handle the data pointers correctly
and in order to save calls to MPI receive and send functions.</dd>
<dt>Recycled</dt><dd><code>Recycled</code> means that this slice gets its data pointer from another
slice, so it should not be written to</dd>
<dt>Acceptor</dt><dd><code>Acceptor</code> means that the slice can accept a new slice, it is
the counterpart of the <code>Blank</code> type, but for states</dd>
</dl>

<p>
Again the implementation is a simple enum type.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a626a4;">enum</span> <span style="color: #c18401;">State</span> {
    <span style="color: #8b4513;">Fetch</span> = 0,
    <span style="color: #8b4513;">Dispatched</span> = 2,
    <span style="color: #8b4513;">Ready</span> = 1,
    <span style="color: #8b4513;">SelfSufficient</span> = 911,
    <span style="color: #8b4513;">Recycled</span> = 123,
    <span style="color: #8b4513;">Acceptor</span> = 405
  };
</pre>
</div>
</div>
</div>

<div id="outline-container-org2fe4da6" class="outline-4">
<h4 id="org2fe4da6"><span class="section-number-4">1.1.5</span> The Info structure</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
Every slice has an information structure associated with it
that keeps track of the <b><b>variable</b></b> type, state and so on.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Info</span> {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">which part of a,b,c the slice holds</span>
  <span style="color: #c18401;">PartialTuple</span> <span style="color: #8b4513;">tuple</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">The type of slice for the user to retrieve the correct one</span>
  <span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">What is the state of the slice</span>
  <span style="color: #c18401;">State</span> <span style="color: #8b4513;">state</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Where the slice is to be retrieved</span>
  <span style="color: #c18401;">Location</span> <span style="color: #8b4513;">from</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">If the data are actually to be found in this other slice</span>
  <span style="color: #c18401;">Type</span> <span style="color: #8b4513;">recycling</span>;

  <span style="color: #0184bc;">Info</span>() : tuple{0,0}
          , type{Blank}
          , state{Acceptor}
          , from{0,0}
          , recycling{Blank}
          {}
};

<span style="color: #a626a4;">using</span> <span style="color: #c18401;">Ty_x_Tu</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">pair</span>&lt; <span style="color: #c18401;">Type</span>, <span style="color: #c18401;">PartialTuple</span> &gt;;
</pre>
</div>
</div>
</div>

<div id="outline-container-orged8bc78" class="outline-4">
<h4 id="orged8bc78"><span class="section-number-4">1.1.6</span> Name</h4>
<div class="outline-text-4" id="text-1-1-6">
<p>
CCSD(T) needs in this algorithm 5 types of tensor slices,
namely
\( V^{ij}_{ka} \), \( V^{ab}_{ci} \),
\( V^{ab}_{ij} \)
and two times \( T^{ab}_{ij} \).
The reason why we need two times the doubles
amplitudes is because in the doubles contribution
to the energy, the \( T \) amplidutes will be sliced
through one parameter for the particle contribution
and through two parameters for the hole contribution.
</p>


<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a626a4;">enum</span> <span style="color: #c18401;">Name</span>
    { <span style="color: #8b4513;">TA</span>    = 100
    , <span style="color: #8b4513;">VIJKA</span> = 101
    , <span style="color: #8b4513;">VABCI</span> = 200
    , <span style="color: #8b4513;">TABIJ</span> = 201
    , <span style="color: #8b4513;">VABIJ</span> = 202
    };
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeeafd9b" class="outline-4">
<h4 id="orgeeafd9b"><span class="section-number-4">1.1.7</span> Database</h4>
<div class="outline-text-4" id="text-1-1-7">
<p>
The database is a simple representation of the slices of a slice union.
Every element of the database is given by the name of the tensor it
represents and the internal information structure.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">LocalDatabaseElement</span> {
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name</span>;
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #8b4513;">info</span>;
  };
</pre>
</div>

<p>
A local database (of a given rank) and the global database is thus simply
a vector of these elements.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">LocalDatabase</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;LocalDatabaseElement&gt;;
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Database</span> = LocalDatabase;
</pre>
</div>
</div>
</div>

<div id="outline-container-org361c29b" class="outline-4">
<h4 id="org361c29b"><span class="section-number-4">1.1.8</span> MPI Types</h4>
<div class="outline-text-4" id="text-1-1-8">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">struct</span> <span style="color: #c18401;">mpi</span> {

  <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">vector</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">DT</span>) {
    <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
    MPI_Type_vector(n, 1, 1, DT, &amp;dt);
    MPI_Type_commit(&amp;dt);
    <span style="color: #a626a4;">return</span> dt;
  }

  <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">sliceLocation</span> () {
    <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span> = 2;
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">create a sliceLocation to measure in the current architecture</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">the packing of the struct</span>
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Location</span> <span style="color: #8b4513;">measure</span>;
    <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
    <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">lengths</span>(n, 1);
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">types</span>[n] = {usizeDt(), usizeDt()};

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">measure the displacements in the struct</span>
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0;
    <span style="color: #c18401;">MPI_Aint</span> <span style="color: #8b4513;">displacements</span>[n];
    MPI_Get_address(&amp;measure.rank,   &amp;displacements[j++]);
    MPI_Get_address(&amp;measure.source, &amp;displacements[j++]);
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; n; i++) displacements[i] -= displacements[0];
    displacements[0] = 0;

    MPI_Type_create_struct(n, lengths.data(), displacements, types, &amp;dt);
    MPI_Type_commit(&amp;dt);
    <span style="color: #a626a4;">return</span> dt;
  }

  <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">enumDt</span>() { <span style="color: #a626a4;">return</span> MPI_INT; }
  <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">usizeDt</span>() { <span style="color: #a626a4;">return</span> MPI_UINT64_T; }

  <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">sliceInfo</span> () {
    <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span> = 5;
    <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #8b4513;">measure</span>;
    <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">lengths</span>(n, 1);
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">types</span>[n]
      = { vector(2, <span style="color: #c18401;">usizeDt</span>())
        , enumDt()
        , enumDt()
        , sliceLocation()
        , enumDt()
        };

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">create the displacements from the info measurement struct</span>
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0;
    <span style="color: #c18401;">MPI_Aint</span> <span style="color: #8b4513;">displacements</span>[n];
    MPI_Get_address(measure.tuple.data(), &amp;displacements[j++]);
    MPI_Get_address(&amp;measure.type,        &amp;displacements[j++]);
    MPI_Get_address(&amp;measure.state,       &amp;displacements[j++]);
    MPI_Get_address(&amp;measure.from,        &amp;displacements[j++]);
    MPI_Get_address(&amp;measure.recycling,   &amp;displacements[j++]);
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; n; i++) displacements[i] -= displacements[0];
    displacements[0] = 0;

    MPI_Type_create_struct(n, lengths.data(), displacements, types, &amp;dt);
    MPI_Type_commit(&amp;dt);
    <span style="color: #a626a4;">return</span> dt;
  }

  <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">localDatabaseElement</span> () {
    <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span> = 2;
    <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
    <span style="color: #c18401;">LocalDatabaseElement</span> <span style="color: #8b4513;">measure</span>;
    <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">lengths</span>(n, 1);
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">types</span>[n]
      = { enumDt()
        , sliceInfo()
        };

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">measure the displacements in the struct</span>
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0;
    <span style="color: #c18401;">MPI_Aint</span> <span style="color: #8b4513;">displacements</span>[n];
    MPI_Get_address(&amp;measure.name, &amp;displacements[j++]);
    MPI_Get_address(&amp;measure.info, &amp;displacements[j++]);
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; n; i++) displacements[i] -= displacements[0];
    displacements[0] = 0;

    MPI_Type_create_struct(n, lengths.data(), displacements, types, &amp;dt);
    MPI_Type_commit(&amp;dt);
    <span style="color: #a626a4;">return</span> dt;
  }

};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaaf3fdd" class="outline-4">
<h4 id="orgaaf3fdd"><span class="section-number-4">1.1.9</span> Static utilities</h4>
<div class="outline-text-4" id="text-1-1-9">
<p>
This section presents some functions which are useful to work with
slices and are inside the namespace created by the slice struct.
</p>


<p>
The function <code>subtupleBySlice</code> gives to every <code>Slice::Type</code>
its meaning in terms of the triples \( (a,b,c) \).
</p>

<p>
Notice that since in general the relation
\( a < b < c \) holds (in our implementation), the case
of one-dimensional parametrizations <code>A</code>, <code>B</code> and <code>C</code> is well
defined.
</p>

<p>
The function should only throw if there is an implementation
error where the <code>Slice::Type</code> enum has been expanded and this
function has not been updated accordingly.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">static</span>
<span style="color: #c18401;">PartialTuple</span> <span style="color: #0184bc;">subtupleBySlice</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">abc</span>, <span style="color: #c18401;">Type</span> <span style="color: #8b4513;">sliceType</span>) {
  <span style="color: #a626a4;">switch</span> (sliceType) {
    <span style="color: #a626a4;">case</span> AB: <span style="color: #a626a4;">return</span> {abc[0], abc[1]};
    <span style="color: #a626a4;">case</span> BC: <span style="color: #a626a4;">return</span> {abc[1], abc[2]};
    <span style="color: #a626a4;">case</span> AC: <span style="color: #a626a4;">return</span> {abc[0], abc[2]};
    <span style="color: #a626a4;">case</span> CB: <span style="color: #a626a4;">return</span> {abc[2], abc[1]};
    <span style="color: #a626a4;">case</span> BA: <span style="color: #a626a4;">return</span> {abc[1], abc[0]};
    <span style="color: #a626a4;">case</span> CA: <span style="color: #a626a4;">return</span> {abc[2], abc[0]};
    <span style="color: #a626a4;">case</span>  A: <span style="color: #a626a4;">return</span> {abc[0], 0};
    <span style="color: #a626a4;">case</span>  B: <span style="color: #a626a4;">return</span> {abc[1], 0};
    <span style="color: #a626a4;">case</span>  C: <span style="color: #a626a4;">return</span> {abc[2], 0};
    <span style="color: #a626a4;">default</span>: <span style="color: #a626a4;">throw</span> <span style="color: #50a14f;">"Switch statement not exhaustive!"</span>;
  }
}
</pre>
</div>

<p>
In the context of cleaning up slices during the main loop,
it is important to check if a given slice has some slices
referencing to it in quality of recycled slices.
</p>

<p>
This function should therefore return a vector of pointers
of slices referencing to the given slice's info, when
the length of the vector is zero, then there are no dangling
links.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">static</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>*&gt; <span style="color: #0184bc;">hasRecycledReferencingToIt</span>
  ( <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>
  , <span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>
  ) {
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>*&gt; <span style="color: #8b4513;">result</span>;

  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">s</span>: slices)
    <span style="color: #a626a4;">if</span> (  s.info.recycling == info.type
        &amp;&amp; s.info.tuple == info.tuple
        &amp;&amp; s.info.state == Recycled
        ) result.push_back(&amp;s);

  <span style="color: #a626a4;">return</span> result;
}
</pre>
</div>

<p>
The rest of the coming functions are utilities in order to find in a vector
of slices a given slice by reference. Mostly they are merely convenience
wrappers to the standard library function <code>std::find_if</code>.
</p>

<p>
They are named as <code>find&lt;...&gt;</code>, where <code>&lt;...&gt;</code> represents some condition
and must always return a reference to the found slice, i.e., <code>Slice&amp;</code>.
<code>Atrip</code> relies on these functions to find the sought for slices,
therefore these functions will throw a <code>std::domain_error</code> if the
given slice could not be found.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp; <span style="color: #0184bc;">findOneByType</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>) {
    <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
      = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                      [&amp;<span style="color: #8b4513;">type</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                        <span style="color: #a626a4;">return</span> type == s.info.type;
                      });
    <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
    <span style="color: #8b4513;">WITH_RANK</span>
      &lt;&lt; <span style="color: #50a14f;">"__slice__:find:looking for "</span> &lt;&lt; type &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
      <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Slice by type not found!"</span>);
    <span style="color: #a626a4;">return</span> *sliceIt;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp;
<span style="color: #0184bc;">findRecycledSource</span> (<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #8b4513;">info</span>) {
  <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
    = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                    [&amp;<span style="color: #8b4513;">info</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                      <span style="color: #a626a4;">return</span> info.recycling == s.info.type
                          &amp;&amp; info.tuple == s.info.tuple
                          &amp;&amp; <span style="font-weight: bold; text-decoration: underline;">State</span>::Recycled != s.info.state
                          ;
                    });

  <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
  <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__slice__:find: recycling source of "</span>
            &lt;&lt; pretty_print(info) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
    <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"Slice not found: "</span>
                            + pretty_print(info)
                            + <span style="color: #50a14f;">" rank: "</span>
                            + pretty_print(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank)
                            );
  WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__slice__:find: "</span> &lt;&lt; pretty_print(sliceIt-&gt;info) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  <span style="color: #a626a4;">return</span> *sliceIt;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp; <span style="color: #0184bc;">findByTypeAbc</span>
  ( <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>
  , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>
  , <span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>
  ) {
    <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, type);
    <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
      = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                      [&amp;<span style="color: #8b4513;">type</span>, &amp;<span style="color: #8b4513;">tuple</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                        <span style="color: #a626a4;">return</span> type == s.info.type
                            &amp;&amp; tuple == s.info.tuple
                            ;
                      });
    <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
    <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__slice__:find:"</span> &lt;&lt; type &lt;&lt; <span style="color: #50a14f;">" and tuple "</span>
              &lt;&lt; pretty_print(tuple)
              &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
      <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"Slice not found: "</span>
                              + pretty_print(tuple)
                              + <span style="color: #50a14f;">", "</span>
                              + pretty_print(type)
                              + <span style="color: #50a14f;">" rank: "</span>
                              + pretty_print(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank)
                              );
    <span style="color: #a626a4;">return</span> *sliceIt;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp; <span style="color: #0184bc;">findByInfo</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>,
                         <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>) {
  <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
    = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                   [&amp;<span style="color: #8b4513;">info</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                     <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: maybe implement comparison in Info struct</span>
                     <span style="color: #a626a4;">return</span> info.type == s.info.type
                       &amp;&amp; info.state == s.info.state
                       &amp;&amp; info.tuple == s.info.tuple
                       &amp;&amp; info.from.rank == s.info.from.rank
                       &amp;&amp; info.from.source == s.info.from.source
                       ;
                   });
  <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
    <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__slice__:find:looking for "</span> &lt;&lt; pretty_print(info) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
    <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"Slice by info not found: "</span>
                             + pretty_print(info));
  <span style="color: #a626a4;">return</span> *sliceIt;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org89b1eb4" class="outline-4">
<h4 id="org89b1eb4"><span class="section-number-4">1.1.10</span> Attributes</h4>
<div class="outline-text-4" id="text-1-1-10">
<p>
A slice object does not own data, it is just a container
or a pointer to data together with additional bookkeeping facilities.
</p>

<p>
It includes an info structure with the information about the slice,
<code>Type</code>, <code>State</code> etc, which will be later communicated to other ranks.
</p>

<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #c18401;">Info</span> <span style="color: #8b4513;">info</span>;
</pre>
</div>

<p>
A pointer to data is also necessary for the <code>Slice</code> but not necessary
to be communicated to other ranks. The <code>Slice</code> should never allocate
or deallocate itself the pointer.
</p>
<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #c18401;">F</span>  *<span style="color: #8b4513;">data</span>;
</pre>
</div>

<p>
An <code>MPI_Request</code> handle is also included so that the slices that are
to receive data through MPI can know which request they belong to.
</p>
<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #c18401;">MPI_Request</span> <span style="color: #8b4513;">request</span>;
</pre>
</div>

<p>
For practical purposes in MPI calls, the number of elements in <code>data</code> is also included.
</p>
<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">size</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org8bb7fbe" class="outline-4">
<h4 id="org8bb7fbe"><span class="section-number-4">1.1.11</span> Member functions</h4>
<div class="outline-text-4" id="text-1-1-11">
<p>
It is important to note that a ready slice should not be recycled from
any other slice, so that it can have access by itself to the data.
</p>
<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">markReady</span>() <span style="color: #a626a4;">noexcept</span> {
      info.state = Ready;
      info.recycling = Blank;
    }
</pre>
</div>


<p>
The following function asks wether or not
the slice has effectively been unwrapped or not,
i.e., wether or not the data are accessible and already
there. This can only happen in two ways, either
is the slice <code>Ready</code> or it is <code>SelfSufficient</code>,
i.e., the data pointed to was pre-distributed to the current node.
</p>
<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isUnwrapped</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> info.state == Ready
          || info.state == SelfSufficient
          ;
    }
</pre>
</div>

<p>
The function <code>isUnwrappable</code> answers which slices can be unwrapped
potentially. Unwrapped slices can be unwrapped again idempotentially.
Also <code>Recycled</code> slices can be unwrapped, i.e. the slices pointed to by them
will be unwrapped.
The only other possibility is that the slice has been dispatched
in the past and can be unwrapped. The case where the state
is <code>Dispatched</code> is the canonical intuitive case where a real process
of unwrapping, i.e. waiting for the data to get through the network,
is done.
</p>
<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isUnwrappable</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> isUnwrapped()
          || info.state == Recycled
          || info.state == Dispatched
          ;
    }

    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isDirectlyFetchable</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> info.state == Ready || info.state == Dispatched;
    }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">free</span>() <span style="color: #a626a4;">noexcept</span> {
      info.tuple      = {0, 0};
      info.type       = Blank;
      info.state      = Acceptor;
      info.from       = {0, 0};
      info.recycling  = Blank;
      data            = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
    }

    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isFree</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> info.tuple       == PartialTuple{0, 0}
          &amp;&amp; info.type        == Blank
          &amp;&amp; info.state       == Acceptor
          &amp;&amp; info.from.rank   == 0
          &amp;&amp; info.from.source == 0
          &amp;&amp; info.recycling   == Blank
          &amp;&amp; data             == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
           ;
    }

</pre>
</div>

<p>
The function <code>isRecylable</code> answers the question, which slices can be recycled.
</p>

<p>
A slice can only be recycled if it is Fetch or Ready and has
a valid datapointer.
</p>

<p>
In particular, SelfSufficient are not recyclable, since it is easier
just to create a SelfSufficient slice than deal with data dependencies.
</p>

<p>
Furthermore, a recycled slice is not recyclable, if this is the case
then it is either bad design or a bug.
</p>

<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isRecyclable</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> (  info.state == Dispatched
             || info.state == Ready
             || info.state == Fetch
             )
          &amp;&amp; hasValidDataPointer()
          ;
    }
</pre>
</div>


<p>
The function <code>hasValidDataPointer</code> describes if a slice has a valid
data pointer.
</p>

<p>
This is important to know if the slice has some data to it, also
some structural checks are done, so that it should not be <code>Acceptor</code>
or <code>Blank</code>, if this is the case then it is a bug.
</p>

<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">hasValidDataPointer</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> data       != <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
          &amp;&amp; info.state != Acceptor
          &amp;&amp; info.type  != Blank
          ;
    }
</pre>
</div>


<p>
The function
<code>unwrapAndMarkReady</code>
calls the low-level MPI functions
in order to wait whenever the state of the slice is correct.
The main behaviour of the function should
</p>
<ul class="org-ul">
<li>return if state is <code>Ready</code>, since then there is nothing to be done.</li>
<li>throw if the state is not <code>Dispatched</code>, only a dispatched slice
can be unwrapped through MPI.</li>
<li>throw if an MPI error happens.</li>
</ul>


<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">unwrapAndMarkReady</span>() {
      <span style="color: #a626a4;">if</span> (info.state == Ready) <span style="color: #a626a4;">return</span>;
      <span style="color: #a626a4;">if</span> (info.state != Dispatched)
        <span style="color: #a626a4;">throw</span>
          <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Can't unwrap a non-ready, non-dispatched slice!"</span>);
      markReady();
      <span style="color: #c18401;">MPI_Status</span> <span style="color: #8b4513;">status</span>;
<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__slice__:mpi: waiting "</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">errorCode</span> = MPI_Wait(&amp;request, &amp;status);
      <span style="color: #a626a4;">if</span> (errorCode != MPI_SUCCESS)
        <span style="color: #a626a4;">throw</span> <span style="color: #50a14f;">"MPI ERROR HAPPENED...."</span>;

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
      <span style="color: #c18401;">char</span> <span style="color: #8b4513;">errorString</span>[MPI_MAX_ERROR_STRING];
      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">errorSize</span>;
      MPI_Error_string(errorCode, errorString, &amp;errorSize);

      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__slice__:mpi: status "</span>
                &lt;&lt; <span style="color: #50a14f;">"{ .source="</span>    &lt;&lt; status.MPI_SOURCE
                &lt;&lt; <span style="color: #50a14f;">", .tag="</span>       &lt;&lt; status.MPI_TAG
                &lt;&lt; <span style="color: #50a14f;">", .error="</span>     &lt;&lt; status.MPI_ERROR
                &lt;&lt; <span style="color: #50a14f;">", .errCode="</span>   &lt;&lt; errorCode
                &lt;&lt; <span style="color: #50a14f;">", .err="</span>       &lt;&lt; errorString
                &lt;&lt; <span style="color: #50a14f;">" }"</span>
                &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
    }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf779156" class="outline-3">
<h3 id="orgf779156"><span class="section-number-3">1.2</span> Utils</h3>
<div class="outline-text-3" id="text-1-2">
<p>
This section presents some utilities
</p>
</div>
<div id="outline-container-orgb42cad4" class="outline-4">
<h4 id="orgb42cad4"><span class="section-number-4">1.2.1</span> Pretty printing</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
The pretty printing uses the <a href="https://github.com/sharkdp/dbg-macro">dbg-macro</a> package.
</p>

<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a626a4;">template</span> &lt;<span style="color: #a626a4;">typename</span> <span style="color: #c18401;">T</span>&gt;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">string</span> <span style="color: #0184bc;">pretty_print</span>(<span style="color: #c18401;">T</span>&amp;&amp; <span style="color: #8b4513;">value</span>) {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">stringstream</span> <span style="color: #8b4513;">stream</span>;
<span style="color: #e44649;">#if</span> ATRIP_DEBUG &gt; 1
    <span style="font-weight: bold; text-decoration: underline;">dbg</span>::pretty_print(stream, <span style="font-weight: bold; text-decoration: underline;">std</span>::forward&lt;<span style="color: #c18401;">T</span>&gt;(value));
<span style="color: #e44649;">#endif</span>
    <span style="color: #a626a4;">return</span> stream.str();
  }

</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb5faf7" class="outline-4">
<h4 id="orgcb5faf7"><span class="section-number-4">1.2.2</span> Chrono</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
The chrono is just a simple wrapper for a high resolution clock
that can be found in the <code>std::chrono</code> namespace of the standard library.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#define</span> <span style="color: #0184bc;">WITH_CHRONO</span>(<span style="color: #8b4513;">__chrono_name</span>, ...)         \
  <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono[__chrono_name].start();         \
  <span style="color: #c18401;">__VA_ARGS__</span>                                   \
  <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #8b4513;">chrono</span>[__chrono_name].stop();

<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Timer</span> {
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Clock</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">chrono</span>::high_resolution_clock;
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Event</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">chrono</span>::<span style="color: #c18401;">time_point</span>&lt;<span style="color: #c18401;">Clock</span>&gt;;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">chrono</span>::<span style="color: #c18401;">duration</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">duration</span>;
  <span style="color: #c18401;">Event</span> <span style="color: #8b4513;">_start</span>;
  <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">start</span>() <span style="color: #a626a4;">noexcept</span> { _start = <span style="font-weight: bold; text-decoration: underline;">Clock</span>::now(); }
  <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">stop</span>() <span style="color: #a626a4;">noexcept</span> { duration += <span style="font-weight: bold; text-decoration: underline;">Clock</span>::now() - _start; }
  <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">clear</span>() <span style="color: #a626a4;">noexcept</span> { duration *= 0; }
  <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">double</span> <span style="color: #0184bc;">count</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> { <span style="color: #a626a4;">return</span> duration.count(); }
};
<span style="color: #a626a4;">using</span> <span style="color: #c18401;">Timings</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">map</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::string, <span style="color: #c18401;">Timer</span>&gt;;

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbb82e63" class="outline-3">
<h3 id="orgbb82e63"><span class="section-number-3">1.3</span> The rank mapping</h3>
<div class="outline-text-3" id="text-1-3">
<p>
This section introduces the concept of rank mapping,
which defines how slices will be allocated to every
rank.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;vector&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;algorithm&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Slice.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {
  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">RankMap</span> {

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">lengths</span>;
    <span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">np</span>, <span style="color: #8b4513;">size</span>;

    <span style="color: #0184bc;">RankMap</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">lens</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np_</span>)
      : lengths(lens)
      , np(np_)
      , size(<span style="font-weight: bold; text-decoration: underline;">std</span>::accumulate(lengths.begin(), lengths.end(),
                            1UL, <span style="font-weight: bold; text-decoration: underline;">std</span>::multiplies&lt;<span style="color: #c18401;">size_t</span>&gt;()))
    { assert(lengths.size() &lt;= 2); }

    <span style="color: #c18401;">size_t</span> <span style="color: #0184bc;">find</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Location</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">p</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> p.source * np + p.rank;
    }

    <span style="color: #c18401;">size_t</span> <span style="color: #0184bc;">nSources</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> size / np + size_t(size % np != 0);
    }


    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isPaddingRank</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> size % np == 0
          ? <span style="font-weight: bold; text-decoration: underline;">false</span>
          : rank &gt; (size % np - 1)
          ;
    }

    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isSourcePadding</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">source</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> source == nSources() &amp;&amp; isPaddingRank(rank);
    }

    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Location</span>
    <span style="color: #0184bc;">find</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">sliceType</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">tuple = {11, 8} when abc = {11, 8, 9} and sliceType = AB</span>
      <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, sliceType);

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">index</span>
        = tuple[0]
        + tuple[1] * (lengths.size() &gt; 1 ? lengths[0] : 0)
        ;

      <span style="color: #a626a4;">return</span>
        { index % np
        , index / np
        };
    }

  };

}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf384cdc" class="outline-3">
<h3 id="orgf384cdc"><span class="section-number-3">1.4</span> The slice union</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Debug.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Slice.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/RankMap.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">F</span> = <span style="color: #c18401;">double</span>;
    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Tensor</span> = <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">F</span>&gt;;

    <span style="color: #a626a4;">virtual</span> <span style="color: #c18401;">void</span>
    <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">iteration</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) = 0;

    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * This function should enforce an important property of a SliceUnion.</span>
<span style="color: #a0a1a7;">     * Namely, there can be no two Slices of the same nature.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * This means that there can be at most one slice with a given Ty_x_Tu.</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">checkForDuplicates</span>() <span style="color: #a626a4;">const</span> {
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ty_x_Tu&gt; <span style="color: #8b4513;">tytus</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>: slices) {
        <span style="color: #a626a4;">if</span> (s.isFree()) <span style="color: #a626a4;">continue</span>;
        tytus.push_back({s.info.type, s.info.tuple});
      }

      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tytu</span>: tytus) {
        <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">std</span>::count(tytus.begin(), tytus.end(), tytu) &gt; 1)
          <span style="color: #a626a4;">throw</span> <span style="color: #50a14f;">"Invariance violated, more than one slice with same Ty_x_Tu"</span>;
      }

    }

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ty_x_Tu&gt; <span style="color: #0184bc;">neededSlices</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ty_x_Tu&gt; <span style="color: #8b4513;">needed</span>(sliceTypes.size());
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">build the needed vector</span>
      <span style="font-weight: bold; text-decoration: underline;">std</span>::transform(sliceTypes.begin(), sliceTypes.end(),
                     needed.begin(),
                     [&amp;<span style="color: #8b4513;">abc</span>](<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">type</span>) {
                       <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, type);
                       <span style="color: #a626a4;">return</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(type, tuple);
                     });
      <span style="color: #a626a4;">return</span> needed;
    }

    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">buildLocalDatabase</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * It should build a database of slices so that we know what is needed</span>
<span style="color: #a0a1a7;">     * to fetch in the next iteration represented by the tuple 'abc'.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * 1. The algorithm works as follows, we build a database of the all</span>
<span style="color: #a0a1a7;">     * the slice types that we need together with their tuple.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * 2. Look in the SliceUnion if we already have this tuple,</span>
<span style="color: #a0a1a7;">     * if we already have it mark it (TODO)</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * 3. If we don't have the tuple, look for a (state=acceptor, type=blank)</span>
<span style="color: #a0a1a7;">     * slice and mark this slice as type=Fetch with the corresponding type</span>
<span style="color: #a0a1a7;">     * and tuple.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * NOTE: The algorithm should certify that we always have enough blank</span>
<span style="color: #a0a1a7;">     * slices.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabase</span> <span style="color: #0184bc;">buildLocalDatabase</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabase</span> <span style="color: #8b4513;">result</span>;

      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">needed</span> = neededSlices(abc);

      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:needed:"</span> &lt;&lt; pretty_print(<span style="color: #c18401;">needed</span>) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">BUILD THE DATABASE</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we need to loop over all sliceTypes that this TensorUnion</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">is representing and find out how we will get the corresponding</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">slice for the abc we are considering right now.</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: needed) {
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">type</span> = pair.first;
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">tuple</span> = pair.second;
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">from</span>  = rankMap.find(abc, <span style="color: #c18401;">type</span>);

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:want:"</span> &lt;&lt; pretty_print(pair) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>: slices)
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:guts:ocd "</span>
                    &lt;&lt; s.info &lt;&lt; <span style="color: #50a14f;">" pt "</span> &lt;&lt; s.data
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: checking if exact match"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
        {
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">FIRST: look up if there is already a *Ready* slice matching what we</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">need</span>
          <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">it</span>
            = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                           [&amp;<span style="color: #8b4513;">tuple</span>, &amp;<span style="color: #8b4513;">type</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">other</span>) {
                             <span style="color: #a626a4;">return</span> other.info.tuple == tuple
                                 &amp;&amp; other.info.type == type
                                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we only want another slice when it</span>
                                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">has already ready-to-use data</span>
                                 &amp;&amp; other.isUnwrappable()
                                 ;
                           });
          <span style="color: #a626a4;">if</span> (it != slices.end()) {
            <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we find this slice, it means that we don't have to do anything</span>
            WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: EXACT: found EXACT in name="</span> &lt;&lt; name
                      &lt;&lt; <span style="color: #50a14f;">" for tuple "</span> &lt;&lt; tuple[0] &lt;&lt; <span style="color: #50a14f;">", "</span> &lt;&lt; tuple[1]
                      &lt;&lt; <span style="color: #50a14f;">" ptr "</span> &lt;&lt; it-&gt;data
                      &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
            result.push_back({name, it-&gt;info});
            <span style="color: #a626a4;">continue</span>;
          }
        }

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: checking if recycle"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Try to find a recyling possibility ie. find a slice with the same</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">tuple and that has a valid data pointer.</span>
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">recycleIt</span>
          = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                         [&amp;<span style="color: #8b4513;">tuple</span>, &amp;<span style="color: #8b4513;">type</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">other</span>) {
                           <span style="color: #a626a4;">return</span> other.info.tuple == tuple
                               &amp;&amp; other.info.type != type
                               &amp;&amp; other.isRecyclable()
                               ;
                         });

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we find this recylce, then we find a Blank slice</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">(which should exist by construction :THINK)</span>
        <span style="color: #a0a1a7; font-weight: bold;">//</span>
        <span style="color: #a626a4;">if</span> (recycleIt != slices.end()) {
          <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">blank</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findOneByType(slices, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Blank);
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: formalize this through a method to copy information</span>
          <span style="color: #a0a1a7; font-weight: bold;">//       </span><span style="color: #a0a1a7;">from another slice</span>
          blank.data = recycleIt-&gt;data;
          blank.info.type = type;
          blank.info.tuple = tuple;
          blank.info.state = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled;
          blank.info.from = from;
          blank.info.recycling = recycleIt-&gt;info.type;
          result.push_back({name, blank.info});
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: RECYCLING: n"</span> &lt;&lt; name
                    &lt;&lt; <span style="color: #50a14f;">" "</span> &lt;&lt; pretty_print(abc)
                    &lt;&lt; <span style="color: #50a14f;">" get "</span> &lt;&lt; pretty_print(blank.info)
                    &lt;&lt; <span style="color: #50a14f;">" from "</span> &lt;&lt; pretty_print(recycleIt-&gt;info)
                    &lt;&lt; <span style="color: #50a14f;">" ptr "</span> &lt;&lt; recycleIt-&gt;data
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>
                    ;
          <span style="color: #a626a4;">continue</span>;
        }

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">in this case we have to create a new slice</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">this means that we should have a blank slice at our disposal</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">and also the freePointers should have some elements inside,</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">so we pop a data pointer from the freePointers container</span>
<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: none work, doing new"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
        {
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: NEW: finding blank in "</span> &lt;&lt; name
                    &lt;&lt; <span style="color: #50a14f;">" for type "</span> &lt;&lt; type
                    &lt;&lt; <span style="color: #50a14f;">" for tuple "</span> &lt;&lt; tuple[0] &lt;&lt; <span style="color: #50a14f;">", "</span> &lt;&lt; tuple[1]
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>
                    ;
          <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">blank</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findOneByType(slices, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Blank);
          blank.info.type = type;
          blank.info.tuple = tuple;
          blank.info.from = from;

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Handle self sufficiency</span>
          blank.info.state = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == from.rank
                           ? <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient
                           : <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch
                           ;
          <span style="color: #a626a4;">if</span> (blank.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient) {
            blank.data = sources[from.source].data();
          } <span style="color: #a626a4;">else</span> {
            <span style="color: #a626a4;">if</span> (freePointers.size() == 0)
              <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"No more free pointers!"</span>);
            <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">dataPointer</span> = freePointers.begin();
            freePointers.erase(dataPointer);
            blank.data = *dataPointer;
          }

          result.push_back({name, blank.info});
          <span style="color: #a626a4;">continue</span>;
        }

      }

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>: slices)
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:guts:ocd:__end__ "</span> &lt;&lt; s.info &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>


      <span style="color: #a626a4;">return</span> result;

    }

    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * Garbage collect slices not needed for the next iteration.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * It will throw if it tries to gc a slice that has not been</span>
<span style="color: #a0a1a7;">     * previously unwrapped, as a safety mechanism.</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">clearUnusedSlicesForNext</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">needed</span> = neededSlices(abc);

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">CLEAN UP SLICES, FREE THE ONES THAT ARE NOT NEEDED ANYMORE</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span>: slices) {
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if the slice is free, then it was not used anyways</span>
        <span style="color: #a626a4;">if</span> (slice.isFree()) <span style="color: #a626a4;">continue</span>;


        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">try to find the slice in the needed slices list</span>
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">found</span>
          = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(needed.begin(), needed.end(),
                         [&amp;<span style="color: #8b4513;">slice</span>] (<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Ty_x_Tu</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tytu</span>) {
                           <span style="color: #a626a4;">return</span> slice.info.tuple == tytu.second
                               &amp;&amp; slice.info.type == tytu.first
                               ;
                         });

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we did not find slice in needed, then erase it</span>
        <span style="color: #a626a4;">if</span> (found == needed.end()) {

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">We have to be careful about the data pointer,</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for SelfSufficient, the data pointer is a source pointer</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">of the slice, so we should just wipe it.</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">For Ready slices, we have to be careful if there are some</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">recycled slices depending on it.</span>
          <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">freeSlicePointer</span> = <span style="font-weight: bold; text-decoration: underline;">true</span>;

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">allow to gc unwrapped and recycled, never Fetch,</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we have a Fetch slice then something has gone very wrong.</span>
          <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>slice.isUnwrapped() &amp;&amp; slice.info.state != <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled)
            <span style="color: #a626a4;">throw</span>
              <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Trying to garbage collect "</span>
                                <span style="color: #50a14f;">" a non-unwrapped slice! "</span>
                                + pretty_print(&amp;slice)
                                + pretty_print(slice.info));

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">it can be that our slice is ready, but it has some hanging</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">references lying around in the form of a recycled slice.</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Of course if we need the recycled slice the next iteration</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">this would be fatal, because we would then free the pointer</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">of the slice and at some point in the future we would</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">overwrite it. Therefore, we must check if slice has some</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">references in slices and if so then</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a0a1a7; font-weight: bold;">//  </span><span style="color: #a0a1a7;">- we should mark those references as the original (since the data</span>
          <span style="color: #a0a1a7; font-weight: bold;">//    </span><span style="color: #a0a1a7;">pointer should be the same)</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a0a1a7; font-weight: bold;">//  </span><span style="color: #a0a1a7;">- we should make sure that the data pointer of slice</span>
          <span style="color: #a0a1a7; font-weight: bold;">//    </span><span style="color: #a0a1a7;">does not get freed.</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a626a4;">if</span> (slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ready) {
            <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span>
              &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; <span style="color: #50a14f;">"checking for data recycled dependencies\n"</span>;
            <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">recycled</span>
              = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::hasRecycledReferencingToIt(slices, slice.info);
            <span style="color: #a626a4;">if</span> (recycled.size()) {
              <span style="color: #c18401;">Slice</span>* <span style="color: #8b4513;">newReady</span> = recycled[0];
              <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span>
                &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; <span style="color: #50a14f;">"swaping recycled "</span>
                &lt;&lt; pretty_print(newReady-&gt;info)
                &lt;&lt; <span style="color: #50a14f;">" and "</span>
                &lt;&lt; pretty_print(slice.info)
                &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
              newReady-&gt;markReady();
              assert(newReady-&gt;data == slice.data);
              freeSlicePointer = <span style="font-weight: bold; text-decoration: underline;">false</span>;

              <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; recycled.size(); i++) {
                <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">newRecyled</span> = recycled[i];
                newRecyled-&gt;info.recycling = newReady-&gt;info.type;
                <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span>
                  &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; <span style="color: #50a14f;">"updating recycled "</span>
                  &lt;&lt; pretty_print(newRecyled-&gt;info)
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
              }

            }
          }

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if the slice is self sufficient, do not dare touching the</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">pointer, since it is a pointer to our sources in our rank.</span>
          <span style="color: #a626a4;">if</span> (  slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient
             || slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled
             ) {
            freeSlicePointer = <span style="font-weight: bold; text-decoration: underline;">false</span>;
          }

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">make sure we get its data pointer to be used later</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">only for non-recycled, since it can be that we need</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for next iteration the data of the slice that the recycled points</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">to</span>
          <span style="color: #a626a4;">if</span> (freeSlicePointer) {
            freePointers.insert(slice.data);
            WITH_RANK &lt;&lt; <span style="color: #50a14f;">"~~~:cl("</span> &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">")"</span>
                      &lt;&lt; <span style="color: #50a14f;">" added to freePointer "</span>
                      &lt;&lt; pretty_print(freePointers)
                      &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          } <span style="color: #a626a4;">else</span> {
            <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__gc__:not touching the free Pointer\n"</span>;
          }

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">at this point, let us blank the slice</span>
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"~~~:cl("</span> &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">")"</span>
                    &lt;&lt; <span style="color: #50a14f;">" freeing up slice "</span>
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; slice.info
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          slice.free();
        }

      }
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">CONSTRUCTOR</span>
    <span style="color: #0184bc;">SliceUnion</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
              , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span>&gt; <span style="color: #8b4513;">sliceTypes_</span>
              , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">sliceLength_</span>
              , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">paramLength</span>
              , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
              , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
              , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
              , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name_</span>
              , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nSliceBuffers</span> = 4
              )
              : rankMap(paramLength, np)
              , world(child_world)
              , universe(global_world)
              , sliceLength(sliceLength_)
              , sources(rankMap.nSources(),
                        <span style="font-weight: bold; text-decoration: underline;">std</span>::vector&lt;<span style="color: #c18401;">F</span>&gt;
                          (<span style="font-weight: bold; text-decoration: underline;">std</span>::accumulate(sliceLength.begin(),
                                           sliceLength.end(),
                                           1UL, <span style="font-weight: bold; text-decoration: underline;">std</span>::multiplies&lt;<span style="color: #c18401;">size_t</span>&gt;())))
              , name(name_)
              , sliceTypes(sliceTypes_)
              , sliceBuffers(nSliceBuffers, sources[0])
              <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">, slices(2 * sliceTypes.size(), Slice{ sources[0].size() })</span>
    { <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">constructor begin</span>

      LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"INIT SliceUnion: "</span> &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

      slices
        = <span style="font-weight: bold; text-decoration: underline;">std</span>::vector&lt;<span style="color: #c18401;">Slice</span>&gt;(2 * sliceTypes.size(), { sources[0].size() });
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: think exactly ^------------------- about this number</span>

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">initialize the freePointers with the pointers to the buffers</span>
      <span style="font-weight: bold; text-decoration: underline;">std</span>::transform(sliceBuffers.begin(), sliceBuffers.end(),
                     <span style="font-weight: bold; text-decoration: underline;">std</span>::inserter(freePointers, freePointers.begin()),
                     [](<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">F</span>&gt; &amp;<span style="color: #8b4513;">vec</span>) { <span style="color: #a626a4;">return</span> vec.data(); });



      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"rankMap.nSources "</span>
                           &lt;&lt; rankMap.nSources() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#slices "</span>
                           &lt;&lt; slices.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#slices[0] "</span>
                           &lt;&lt; slices[0].size &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sources "</span>
                           &lt;&lt; sources.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sources[0] "</span>
                           &lt;&lt; sources[0].size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#freePointers "</span>
                           &lt;&lt; freePointers.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sliceBuffers "</span>
                           &lt;&lt; sliceBuffers.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sliceBuffers[0] "</span>
                           &lt;&lt; sliceBuffers[0].size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sliceLength "</span>
                           &lt;&lt; sliceLength.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#paramLength "</span>
                           &lt;&lt; paramLength.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"GB*"</span> &lt;&lt; np &lt;&lt; <span style="color: #50a14f;">" "</span>
                           &lt;&lt; <span style="color: #c18401;">double</span>(sources.size() + sliceBuffers.size())
                            * sources[0].size()
                            * 8 * np
                            / 1073741824.0
                           &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">constructor ends</span>

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">init</span>(<span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>) {

      <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">World</span> <span style="color: #8b4513;">w</span>(world);
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span> = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank
              , <span style="color: #8b4513;">order</span> = sliceLength.size()
              ;
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">syms</span>(order, NS);
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">__sliceLength</span>(sliceLength.begin(), sliceLength.end());
      <span style="color: #c18401;">Tensor</span> <span style="color: #8b4513;">toSliceInto</span>(order,
                         __sliceLength.data(),
                         syms.data(),
                         w);
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"slicing... \n"</span>;

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">setUp sources</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>(0); it &lt; rankMap.nSources(); ++it) {
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span>
          <span style="color: #8b4513;">source</span> = rankMap.isSourcePadding(rank, source) ? 0 : it;
        <span style="color: #c18401;">WITH_OCD</span>
        <span style="color: #8b4513;">WITH_RANK</span>
          &lt;&lt; <span style="color: #50a14f;">"Init:toSliceInto it-"</span> &lt;&lt; it
          &lt;&lt; <span style="color: #50a14f;">" :: source "</span> &lt;&lt; source &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        sliceIntoBuffer(source, toSliceInto, sourceTensor);
      }

    }

    <span style="color: #50a14f; font-style: italic;">/**</span>
<span style="color: #50a14f; font-style: italic;">     * \brief Send asynchronously only if the state is Fetch</span>
<span style="color: #50a14f; font-style: italic;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">send</span>( <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">otherRank</span>
             , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>
             , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">tag</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #c18401;">MPI_Request</span> <span style="color: #8b4513;">request</span>;
      <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">sendData_p</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;

      <span style="color: #a626a4;">if</span> (info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch) sendData_p = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: remove this because I have SelfSufficient</span>
      <span style="color: #a626a4;">if</span> (otherRank == info.from.rank)      sendData_p = <span style="font-weight: bold; text-decoration: underline;">false</span>;
      <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>sendData_p) <span style="color: #a626a4;">return</span>;

      MPI_Isend( <span style="color: #c18401;">sources</span>[info.from.source].data()
               , <span style="color: #c18401;">sources</span>[info.from.source].size()
               , MPI_DOUBLE <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">TODO: adapt this with traits</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
               , otherRank
               , tag
               , universe
               , &amp;request
               );
      <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
      <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"sent to "</span> &lt;&lt; otherRank &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

    }

    <span style="color: #50a14f; font-style: italic;">/**</span>
<span style="color: #50a14f; font-style: italic;">     * \brief Receive asynchronously only if the state is Fetch</span>
<span style="color: #50a14f; font-style: italic;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">receive</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">tag</span>) <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findByInfo(slices, info);

      <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == info.from.rank) <span style="color: #a626a4;">return</span>;

      <span style="color: #a626a4;">if</span> (slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch) {
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: do it through the slice class</span>
        slice.info.state = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Dispatched;
        <span style="color: #c18401;">MPI_Request</span> <span style="color: #8b4513;">request</span>;
        slice.request = request;
        MPI_Irecv( slice.data
                 , slice.size
                 , MPI_DOUBLE <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: Adapt this with traits</span>
                 , info.from.rank
                 , tag
                 , universe
                 , &amp;slice.request
                <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">, MPI_STATUS_IGNORE</span>
                 );
      }
    }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">unwrapAll</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">type</span>: sliceTypes) unwrapSlice(type, abc);
    }

    <span style="color: #c18401;">F</span>* <span style="color: #0184bc;">unwrapSlice</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>, <span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
      <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__unwrap__:slice "</span> &lt;&lt; type &lt;&lt; <span style="color: #50a14f;">" w n "</span>
                &lt;&lt; name
                &lt;&lt; <span style="color: #50a14f;">" abc"</span> &lt;&lt; pretty_print(abc)
                &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findByTypeAbc(slices, type, abc);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:info "</span> &lt;&lt; slice.info &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">switch</span>  (slice.info.state) {
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Dispatched:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:Fetch: "</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          slice.unwrapAndMarkReady();
          <span style="color: #a626a4;">return</span> slice.data;
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:SelfSufficient: "</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          <span style="color: #a626a4;">return</span> slice.data;
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ready:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:READY: UNWRAPPED ALREADY"</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          <span style="color: #a626a4;">return</span> slice.data;
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:RECYCLED "</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          <span style="color: #a626a4;">return</span> unwrapSlice(slice.info.recycling, abc);
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch:
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Acceptor:
          <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Can't unwrap an acceptor or fetch slice!"</span>);
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">default</span>:
          <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Unknown error unwrapping slice!"</span>);
      }
      <span style="color: #a626a4;">return</span> slice.data;
    }

    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">RankMap</span> <span style="color: #8b4513;">rankMap</span>;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">world</span>;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span>;
    <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">sliceLength</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">F</span>&gt; &gt; <span style="color: #8b4513;">sources</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="color: #c18401;">Slice</span> &gt; <span style="color: #8b4513;">slices</span>;
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name</span>;
    <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span>&gt; <span style="color: #8b4513;">sliceTypes</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">F</span>&gt; &gt; <span style="color: #8b4513;">sliceBuffers</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">set</span>&lt;<span style="color: #c18401;">F</span>*&gt; <span style="color: #8b4513;">freePointers</span>;

  };

  <span style="color: #c18401;">SliceUnion</span>&amp;
  <span style="color: #0184bc;">unionByName</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">SliceUnion</span>*&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">unions</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name</span>) {
      <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceUnionIt</span>
        = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(unions.begin(), unions.end(),
                      [&amp;<span style="color: #8b4513;">name</span>](<span style="color: #c18401;">SliceUnion</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">s</span>) {
                        <span style="color: #a626a4;">return</span> name == s-&gt;name;
                      });
      <span style="color: #a626a4;">if</span> (sliceUnionIt == unions.end())
        <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"SliceUnion not found!"</span>);
      <span style="color: #a626a4;">return</span> **sliceUnionIt;
  }

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9af5999" class="outline-3">
<h3 id="org9af5999"><span class="section-number-3">1.5</span> Tuples</h3>
<div class="outline-text-3" id="text-1-5">
<p>
This section introduces the types for tuples \( (a,b,c) \)
as well as their distribution to nodes and cores.
</p>
</div>


<div id="outline-container-orgd1c7f44" class="outline-4">
<h4 id="orgd1c7f44"><span class="section-number-4">1.5.1</span> Tuples types</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
The main tuple types are simple type aliases for finite-size arrays.
A tuple is thus simply 3 natural numbers \( (a,b,c) \)
whereas a partial tuple is a two dimensional subset of these three.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">using</span> <span style="color: #c18401;">ABCTuple</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">array</span>&lt;<span style="color: #c18401;">size_t</span>, 3&gt;;
<span style="color: #a626a4;">using</span> <span style="color: #c18401;">PartialTuple</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">array</span>&lt;<span style="color: #c18401;">size_t</span>, 2&gt;;
<span style="color: #a626a4;">using</span> <span style="color: #c18401;">ABCTuples</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt;;

<span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">FAKE_TUPLE</span> = {0, 0, 0};
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b9e24d" class="outline-4">
<h4 id="org4b9e24d"><span class="section-number-4">1.5.2</span> Distributing the tuples</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
In general it is our task to distribute all the tuples
\( (a,b,c) \) among the ranks. Every distribution should
make sure to allocate the same amount of tuples to every rank,
padding the list with <code>FAKE_TUPLE</code> elements as necessary.
</p>

<p>
The interface that we propose for this is simplye
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">struct</span> <span style="color: #c18401;">TuplesDistribution</span> {
  <span style="color: #a626a4;">virtual</span> <span style="color: #c18401;">ABCTuples</span> <span style="color: #0184bc;">getTuples</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>, <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span>) = 0;
  <span style="color: #a626a4;">virtual</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">tupleIsFake</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">t</span>) { <span style="color: #a626a4;">return</span> t == FAKE_TUPLE; }
};
</pre>
</div>
</div>
</div>



<div id="outline-container-orgce410c7" class="outline-4">
<h4 id="orgce410c7"><span class="section-number-4">1.5.3</span> Node information</h4>
<div class="outline-text-4" id="text-1-5-3">
<dl class="org-dl">
<dt>nodeList</dt><dd>List of hostnames of size \( N_n \)</dd>
<dt>nodeInfos</dt><dd>List of (hostname, local rank Id)
of size \( N_p \), i.e., size of ranks
where local rank id goes from 0 to 48.</dd>
</dl>



<p>
<code>getNodeNames</code> gets the names of the nodes used,
i.e., the size of the resulting vector gives the
number of nodes.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::string&gt; <span style="color: #0184bc;">getNodeNames</span>(<span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">comm</span>){
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span>, <span style="color: #8b4513;">np</span>;
  MPI_Comm_rank(comm, &amp;rank);
  MPI_Comm_size(comm, &amp;np);

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::string&gt; <span style="color: #8b4513;">nodeList</span>(np);
  <span style="color: #c18401;">char</span> <span style="color: #8b4513;">nodeName</span>[MPI_MAX_PROCESSOR_NAME]
     , <span style="color: #8b4513;">nodeNames</span>[np*MPI_MAX_PROCESSOR_NAME]
     ;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">nameLengths</span>(np)
                 , <span style="color: #8b4513;">off</span>(np)
                 ;
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">nameLength</span>;
  MPI_Get_processor_name(nodeName, &amp;nameLength);
  MPI_Allgather(&amp;nameLength,
                1,
                MPI_INT,
                nameLengths.data(),
                1,
                MPI_INT,
                comm);
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>(1); i &lt; np; i++)
    off[i] = off[i-1] + nameLengths[i-1];
  MPI_Allgatherv(nodeName,
                 nameLengths[rank],
                 MPI_BYTE,
                 nodeNames,
                 nameLengths.data(),
                 off.data(),
                 MPI_BYTE,
                 comm);
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>(0); i &lt; np; i++) {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">string</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">s</span>(&amp;nodeNames[off[i]], <span style="color: #c18401;">nameLengths</span>[i]);
    nodeList[i] = s;
  }
  <span style="color: #a626a4;">return</span> nodeList;
}
</pre>
</div>

<p>
<code>getNodeInfos</code>
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">struct</span> <span style="color: #c18401;">RankInfo</span> {
  <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">string</span> <span style="color: #8b4513;">name</span>;
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nodeId</span>;
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">globalRank</span>;
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">localRank</span>;
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ranksPerNode</span>;
};

<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">RankInfo</span>&gt;
<span style="color: #0184bc;">getNodeInfos</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">string</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">nodeNames</span>) {
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">RankInfo</span>&gt; <span style="color: #8b4513;">result</span>;
  <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">uniqueNames</span> = nodeNames;
  {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(uniqueNames.begin(), uniqueNames.end());
    <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">last</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::unique(uniqueNames.begin(), uniqueNames.end());
    uniqueNames.erase(last, uniqueNames.end());
  }
  <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">index</span> = [&amp;<span style="color: #8b4513;">uniqueNames</span>](<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">string</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
    <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">it</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::find(uniqueNames.begin(), uniqueNames.end(), s);
    <span style="color: #a626a4;">return</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::distance(uniqueNames.begin(), it);
  };
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">localRanks</span>(uniqueNames.size(), 0);
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span> = 0;
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">name</span>: nodeNames) {
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nodeId</span> = index(name);
    result.push_back({name,
                      nodeId,
                      rank++,
                      localRanks[nodeId]++,
                      <span style="font-weight: bold; text-decoration: underline;">std</span>::count(nodeNames.begin(),
                                 nodeNames.end(),
                                 name)
                      });
  }
  <span style="color: #a626a4;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd1b9d08" class="outline-4">
<h4 id="orgd1b9d08"><span class="section-number-4">1.5.4</span> Naive list</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
The naive implementation of the global tuples list is simple
three for loops creating tuples of the sort
\( (a,b,c) \) where the following conditions are met at the same time:
</p>
<ul class="org-ul">
<li>\( a \leq b \leq c \)</li>
<li>\(
  a \neq b \land b \neq c
  \)</li>
</ul>

<p>
This means,
\( (1, 2, 3)
 , (1, 1, 3)
 , (1, 2, 2)
\) are acceptable tuples wherease \( (2, 1, 1) \) and \( (1, 1, 1) \) are not.
</p>


<div class="org-src-container">
<pre class="src src-c++"><span style="color: #c18401;">ABCTuples</span> <span style="color: #0184bc;">getTuplesList</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>) {

  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">total number of tuples for the problem</span>
       <span style="color: #8b4513;">n</span> = Nv * (Nv + 1) * (Nv + 2) / 6 - Nv

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">all ranks should have the same number of tuples_per_rank</span>
    , <span style="color: #8b4513;">tuples_per_rank</span> = n / np + size_t(n % np != 0)

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">start index for the global tuples list</span>
    , <span style="color: #8b4513;">start</span> = tuples_per_rank * rank

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">end index for the global tuples list</span>
    , <span style="color: #8b4513;">end</span> = tuples_per_rank * (rank + 1)
    ;

  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"tuples_per_rank = "</span> &lt;&lt; tuples_per_rank &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  WITH_RANK &lt;&lt; <span style="color: #50a14f;">"start, end = "</span> &lt;&lt; start &lt;&lt; <span style="color: #50a14f;">", "</span> &lt;&lt; end &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  <span style="color: #c18401;">ABCTuples</span> <span style="color: #8b4513;">result</span>(tuples_per_rank, FAKE_TUPLE);

  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">a</span>(0), <span style="color: #8b4513;">r</span>(0), <span style="color: #8b4513;">g</span>(0); a &lt; Nv; a++)
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">b</span>(a);             b &lt; Nv; b++)
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">c</span>(b);             c &lt; Nv; c++){
    <span style="color: #a626a4;">if</span> ( a == b &amp;&amp; b == c ) <span style="color: #a626a4;">continue</span>;
    <span style="color: #a626a4;">if</span> ( start &lt;= g &amp;&amp; g &lt; end) result[r++] = {a, b, c};
    g++;
  }

  <span style="color: #a626a4;">return</span> result;

}
</pre>
</div>

<p>
and all tuples would simply be
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #c18401;">ABCTuples</span> <span style="color: #0184bc;">getAllTuplesList</span>(<span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>) {
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span> = Nv * (Nv + 1) * (Nv + 2) / 6 - Nv;
  <span style="color: #c18401;">ABCTuples</span> <span style="color: #8b4513;">result</span>(n);

  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">a</span>(0), <span style="color: #8b4513;">u</span>(0); a &lt; Nv; a++)
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">b</span>(a); b &lt; Nv; b++)
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">c</span>(b); c &lt; Nv; c++){
    <span style="color: #a626a4;">if</span> ( a == b &amp;&amp; b == c ) <span style="color: #a626a4;">continue</span>;
    result[u++] = {a, b, c};
  }

  <span style="color: #a626a4;">return</span> result;
}
</pre>
</div>


<p>
With <code>getTupleList</code> we can easily define a tuple distribution like
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">struct</span> <span style="color: #c18401;">NaiveDistribution</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">TuplesDistribution</span> {
  <span style="color: #c18401;">ABCTuples</span> <span style="color: #0184bc;">getTuples</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>, <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span>) <span style="color: #a626a4;">override</span> {
    <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span>, <span style="color: #8b4513;">np</span>;
    MPI_Comm_rank(universe, &amp;rank);
    MPI_Comm_size(universe, &amp;np);
    <span style="color: #a626a4;">return</span> getTuplesList(Nv, (<span style="color: #c18401;">size_t</span>)rank, (<span style="color: #c18401;">size_t</span>)np);
  }
};
</pre>
</div>
</div>
</div>


<div id="outline-container-org8f0e940" class="outline-4">
<h4 id="org8f0e940"><span class="section-number-4">1.5.5</span> Group and sort list</h4>
<div class="outline-text-4" id="text-1-5-5">
</div>
<ol class="org-ol">
<li><a id="orgac91d18"></a>Utils<br />
<div class="outline-text-5" id="text-1-5-5-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Provides the node on which the slice-element is found</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Right now we distribute the slices in a round robin fashion</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">over the different nodes (NOTE: not mpi ranks but nodes)</span>
<span style="color: #c18401;">size_t</span> <span style="color: #0184bc;">isOnNode</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">tuple</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nodes</span>) { <span style="color: #a626a4;">return</span> tuple % nodes; }


<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Info</span> {
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nNodes</span>;
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>;
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>;
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nodeId</span>;
};


<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">return the node (or all nodes) where the elements of this</span>
<span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">tuple are located</span>
<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #0184bc;">getTupleNodes</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">t</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nNodes</span>) {
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">result</span>;
  <span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">nTuple</span> = { isOnNode(t[0], nNodes)
                    , isOnNode(t[1], nNodes)
                    , isOnNode(t[2], nNodes)
                    };
  <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(nTuple.begin(), nTuple.end());
  <span style="font-weight: bold; text-decoration: underline;">ABCTuple</span>::<span style="color: #c18401;">iterator</span> <span style="color: #8b4513;">it</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::unique(nTuple.begin(), nTuple.end());
  result.resize(it - nTuple.begin());
  <span style="font-weight: bold; text-decoration: underline;">std</span>::copy(nTuple.begin(), it, result.begin());
  <span style="color: #a626a4;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li><a id="org2cfd5ab"></a>Distribution<br />
<div class="outline-text-5" id="text-1-5-5-2">
<p>
wording: home element = element which is located on the given node
</p>
<ol class="org-ol">
<li>we distribute the tuples such that each tuple has at least one 'home element'</li>
<li>we sort each tuple in a way that the 'home element' are the fastest indices</li>
<li>we sort the list of tuples on every node</li>
<li>we resort the tuples that for every tuple abc the following holds: a&lt;b&lt;c</li>
</ol>
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt;
<span style="color: #0184bc;">specialDistribution</span>(<span style="color: #c18401;">Info</span> <span style="color: #8b4513;">info</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">allTuples</span>) {

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt; <span style="color: #8b4513;">nodeTuples</span>;
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nNodes</span>(info.nNodes);
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>(info.np);
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">N</span>(allTuples.size());

  <span style="color: #a0a1a7; font-weight: bold;">//      </span><span style="color: #a0a1a7;">nodeid          tuple list</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">map</span>&lt;<span style="color: #c18401;">size_t</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt; &gt; <span style="color: #8b4513;">container1d</span>;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">map</span>&lt;<span style="color: #c18401;">size_t</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt; &gt; <span style="color: #8b4513;">container2d</span>;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">map</span>&lt;<span style="color: #c18401;">size_t</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt; &gt; <span style="color: #8b4513;">container3d</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">build container-n-d's</span>
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">t</span>: allTuples) {
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">one which node(s) are the tuple elements located...</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">put them into the right container</span>
    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">nt</span> = getTupleNodes(t, nNodes);
    <span style="color: #a626a4;">if</span> ( nt.size() == 1) container1d[nt[0]].push_back(t);
    <span style="color: #a626a4;">if</span> ( nt.size() == 2) container2d[nt[0] + nNodes*nt[1]].push_back(t);
    <span style="color: #a626a4;">if</span> ( nt.size() == 3)
      container3d[nt[0] + nNodes*nt[1] + nNodes*nNodes*nt[2]].push_back(t);
  }

  <span style="color: #a626a4;">if</span> (info.nodeId == 0)
    <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="color: #50a14f;">"\tBuilding 1-d containers\n"</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">DISTRIBUTE 1-d containers</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">every tuple which is only located at one node belongs to this node</span>
  {
    <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tuplesVec</span> = container1d[info.nodeId];
    nodeTuples.resize(tuplesVec.size());
    <span style="font-weight: bold; text-decoration: underline;">std</span>::copy(tuplesVec.begin(), tuplesVec.end(), nodeTuples.begin());
  }

  <span style="color: #a626a4;">if</span> (info.nodeId == 0)
    <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="color: #50a14f;">"\tBuilding 2-d containers\n"</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">DISTRIBUTE 2-d containers</span>
  <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">the tuples which are located at two nodes are half/half given to these nodes</span>
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> &amp;<span style="color: #8b4513;">m</span>: container2d) {
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">idx</span> = m.first%nNodes;
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">idy</span> = m.first/nNodes;
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">myNode</span> = idx;

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">either idx or idy is my node</span>
    <span style="color: #a626a4;">if</span> (idx != info.nodeId &amp;&amp; idy != info.nodeId) <span style="color: #a626a4;">continue</span>;
    <span style="color: #a626a4;">if</span> (idy == info.nodeId) myNode = idy;

    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuplesVec</span> = m.second;
    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">n</span> = tuplesVec.size() / 2;
    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">size</span> = nodeTuples.size();
    <span style="color: #a626a4;">if</span> (myNode == idx) {
      nodeTuples.resize(size + n);
      <span style="font-weight: bold; text-decoration: underline;">std</span>::copy(tuplesVec.begin(),
                tuplesVec.begin() + n,
                nodeTuples.begin() + size);
    } <span style="color: #a626a4;">else</span> {
      <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">ny</span> = tuplesVec.size() - n;
      nodeTuples.resize(size + ny);
      <span style="font-weight: bold; text-decoration: underline;">std</span>::copy(tuplesVec.begin() + n,
                tuplesVec.end(),
                nodeTuples.begin() + size);
    }

  }

  <span style="color: #a626a4;">if</span> (info.nodeId == 0)
    <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="color: #50a14f;">"\tBuilding 3-d containers\n"</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">DISTRIBUTE 3-d containers</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">similar game for the tuples which belong to three different nodes</span>
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">m</span>: container3d){
    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuplesVec</span> = m.second;
    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">idx</span> = m.first%nNodes;
    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">idy</span> = (m.first/nNodes)%nNodes;
    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">idz</span> = m.first/nNodes/nNodes;
    <span style="color: #a626a4;">if</span> (idx != info.nodeId &amp;&amp; idy != info.nodeId &amp;&amp; idz != info.nodeId) <span style="color: #a626a4;">continue</span>;

    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nx</span> = tuplesVec.size() / 3;
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span>, <span style="color: #8b4513;">nbegin</span>, <span style="color: #8b4513;">nend</span>;
    <span style="color: #a626a4;">if</span> (info.nodeId == idx) {
      n = nx;
      nbegin = 0;
      nend = n;
    } <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> (info.nodeId == idy) {
      n = nx;
      nbegin = n;
      nend = n + n;
    } <span style="color: #a626a4;">else</span> {
      n = tuplesVec.size() - 2 * nx;
      nbegin = 2 * nx;
      nend = 2 * nx + n;
    }

    <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">size</span> = nodeTuples.size();
    nodeTuples.resize(size + n);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::copy(tuplesVec.begin() + nbegin,
              tuplesVec.begin() + nend,
              nodeTuples.begin() + size);

  }


  <span style="color: #a626a4;">if</span> (info.nodeId == 0)
    <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="color: #50a14f;">"\tsorting...\n"</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">sort part of group-and-sort algorithm</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">every tuple on a given node is sorted in a way that</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">the 'home elements' are the fastest index.</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">1:yyy 2:yyn(x) 3:yny(x) 4:ynn(x) 5:nyy 6:nyn(x) 7:nny 8:nnn</span>
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span> = info.nodeId;
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> &amp;<span style="color: #8b4513;">nt</span>: nodeTuples){
    <span style="color: #a626a4;">if</span> ( isOnNode(nt[0], nNodes) == n ){ <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">1234</span>
      <span style="color: #a626a4;">if</span> ( isOnNode(nt[2], nNodes) != n ){ <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">24</span>
        <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">x</span>(nt[0]); nt[0] = nt[2]; nt[2] = x; <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">switch first and last</span>
      }
      <span style="color: #a626a4;">else</span> <span style="color: #a626a4;">if</span> ( isOnNode(nt[1], nNodes) != n){ <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">3</span>
        <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">x</span>(nt[0]); nt[0] = nt[1]; nt[1] = x; <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">switch first two</span>
      }
    } <span style="color: #a626a4;">else</span> {
      <span style="color: #a626a4;">if</span> ( isOnNode(nt[1], nNodes) == n   <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">56</span>
        &amp;&amp; isOnNode(nt[2], nNodes) != n){ <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">6</span>
        <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">x</span>(nt[1]); nt[1] = nt[2]; nt[2] = x; <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">switch last two</span>
      }
    }
  }

  <span style="color: #a626a4;">if</span> (info.nodeId == 0) <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="color: #50a14f;">"\tsorting list of tuples...\n"</span>;
  <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">now we sort the list of tuples</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(nodeTuples.begin(), nodeTuples.end());

  <span style="color: #a626a4;">if</span> (info.nodeId == 0) <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="color: #50a14f;">"\trestoring tuples...\n"</span>;
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we bring the tuples abc back in the order a&lt;b&lt;c</span>
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> &amp;<span style="color: #8b4513;">t</span>: nodeTuples)  <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(t.begin(), t.end());

  <span style="color: #a626a4;">return</span> nodeTuples;

}
</pre>
</div>


<p>
TODO: ERASE THIS CODE BLOCK
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">determine which element has to be fetched from sources for the next iteration</span>
<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #0184bc;">fetchElement</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">cur</span>, <span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">suc</span>){
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">result</span>;
  <span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">inter</span>;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(cur.begin(), cur.end());
  <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(suc.begin(), suc.end());
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">array</span>&lt;<span style="color: #c18401;">size_t</span>,3&gt;::<span style="color: #c18401;">iterator</span> <span style="color: #8b4513;">rit</span>, <span style="color: #8b4513;">cit</span>, <span style="color: #8b4513;">sit</span>;
  cit = <span style="font-weight: bold; text-decoration: underline;">std</span>::unique(cur.begin(), cur.end());
  sit = <span style="font-weight: bold; text-decoration: underline;">std</span>::unique(suc.begin(), suc.end());
  rit = <span style="font-weight: bold; text-decoration: underline;">std</span>::set_difference(suc.begin(), sit, cur.begin(), cit, inter.begin());
  result.resize(rit - inter.begin());
  <span style="font-weight: bold; text-decoration: underline;">std</span>::copy(inter.begin(), rit, result.begin());
  <span style="color: #a626a4;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li><a id="org119d6de"></a>Main<br />
<div class="outline-text-5" id="text-1-5-5-3">
<p>
The main routine should return the list of tuples to be handled by the current rank.
</p>

<p>
Let \( N_p \) be the number of ranks or processes.
Let \( N_n \) be the number of nodes or sockets.
</p>

<p>
Then we have the following
</p>

<pre class="example" id="org1dee3c3">
Global rank | 0 1 2 3 4 5 6 7 8
key         | global rank
nodeId      | 0 1 0 1 1 0 2 2 2
Local rank  | 0 0 1 1 2 2 0 1 2
intra color | 0 1 0 1 1 0 2 2 2
</pre>





<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt; <span style="color: #0184bc;">main</span>(<span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>) {

  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span>, <span style="color: #8b4513;">np</span>;
  MPI_Comm_rank(universe, &amp;rank);
  MPI_Comm_size(universe, &amp;np);

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt; <span style="color: #8b4513;">result</span>;

  <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">nodeNames</span>(getNodeNames(universe));
  <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">nodeNamesUnique</span>(nodeNames);
  {
    <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">last</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::unique(nodeNamesUnique.begin(),
                                   nodeNamesUnique.end());
    nodeNamesUnique.erase(last, nodeNamesUnique.end());
  }
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we pick one rank from every node</span>
  <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">nodeInfos</span> = getNodeInfos(nodeNames);
  <span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">nNodes</span> = nodeNamesUnique.size();

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">We want to construct a communicator which only contains of one</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">element per node</span>
  <span style="color: #c18401;">bool</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">makeDistribution</span>
    = nodeInfos[rank].localRank == 0;

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt;
    <span style="color: #8b4513;">nodeTuples</span> = makeDistribution
               ? specialDistribution(Info{ nNodes
                                         , Nv
                                         , np
                                         , nodeInfos[rank].nodeId
                                         },
                                      getAllTuplesList(Nv))
               : <span style="font-weight: bold; text-decoration: underline;">std</span>::vector&lt;ABCTuple&gt;()
               ;

  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"got nodeTuples\n"</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">now we have to send the data from **one** rank on each node</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">to all others ranks of this node</span>
    <span style="color: #a626a4;">const</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">color</span> = nodeInfos[rank].nodeId
    , <span style="color: #8b4513;">key</span> = nodeInfos[rank].localRank
    ;


  <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">INTRA_COMM</span>;
  MPI_Comm_split(universe, color, key, &amp;INTRA_COMM);
</pre>
</div>

<p>
Every node has to distribute <b><b>at least</b></b>
<code>nodeTuples.size() / nodeInfos[rank].ranksPerNode</code>
tuples among the ranks.
</p>

<p>
We have to communicate this quantity among all nodes.
</p>

<div class="org-src-container">
<pre class="src src-c++">
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span>
    <span style="color: #8b4513;">tuplesPerRankLocal</span>
       = nodeTuples.size() / nodeInfos[rank].ranksPerNode
       + size_t(nodeTuples.size() % nodeInfos[rank].ranksPerNode != 0)
       ;

  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">tuplesPerRankGlobal</span>;

  MPI_Reduce(&amp;tuplesPerRankLocal,
             &amp;tuplesPerRankGlobal,
             1,
             MPI_UINT64_T,
             MPI_MAX,
             0,
             universe);

  MPI_Bcast(&amp;tuplesPerRankGlobal,
            1,
            MPI_UINT64_T,
            0,
            universe);

  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"Tuples per rank: "</span> &lt;&lt; tuplesPerRankGlobal &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"ranks per node "</span> &lt;&lt; nodeInfos[rank].ranksPerNode &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#nodes "</span> &lt;&lt; nNodes &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
</pre>
</div>

<p>
Now we have the tuples that every rank has to have, i.e.,
<code>tuplesPerRankGlobal</code>.
</p>

<p>
However before this,
the tuples in <code>nodeTuples</code> now have to be sent from the local rank
in every node to all the ranks in the given node,
and we have to make sure that every rank inside a given node
gets the same amount of tuples, in this case it should be
<code>tuplesPerRankLocal</code>, and in our node the total number
of tuples should be <code>tuplesPerRankLocal * nodeInfos[rank].ranksPerNode</code>,
however this might not be the case up to now due to divisibility issues.
</p>

<p>
Up to now we have exactly <code>nodeTuples.size()</code> tuples, we have to make sure by
resizing that the condition above is met, i.e., so we can resize
and add some fake tuples at the end as padding.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">totalTuples</span>
  = tuplesPerRankGlobal * nodeInfos[rank].ranksPerNode;

<span style="color: #a626a4;">if</span> (makeDistribution) {
  nodeTuples.insert(nodeTuples.end(),
                    totalTuples - nodeTuples.size(),
                    FAKE_TUPLE);
}
</pre>
</div>

<p>
And now we can simply scatter the tuples in nodeTuples and send
<code>tuplesPerRankGlobal</code> to the different ranks in the node,
</p>

<div class="org-src-container">
<pre class="src src-c++">{
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">construct mpi type for abctuple</span>
  <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">MPI_ABCTUPLE</span>;
  MPI_Type_vector(nodeTuples[0].size(), 1, 1, MPI_UINT64_T, &amp;MPI_ABCTUPLE);
  MPI_Type_commit(&amp;MPI_ABCTUPLE);

  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"scattering tuples \n"</span>;

  result.resize(tuplesPerRankGlobal);
  MPI_Scatter(nodeTuples.data(),
              tuplesPerRankGlobal,
              MPI_ABCTUPLE,
              result.data(),
              tuplesPerRankGlobal,
              MPI_ABCTUPLE,
              0,
              INTRA_COMM);

  MPI_Type_free(&amp;MPI_ABCTUPLE);

}
</pre>
</div>


<p>
The next step is sending the tuples in the local root rank
to the other ranks in the node, this we do with the MPI function
<code>MPI_Scatterv</code>.
Every rank gets <code>tuplesPerRankLocal</code> tuples and
the <code>nodeTuples</code> vector is now homogeneous and divisible by the number
of ranks per node in our node.
Therefore, the <code>displacements</code> are simply the vector
</p>
\begin{equation*}
  \left\{
  k * \mathrm{tuplesPerNodeLocal}
  \mid
  k \in
  \left\{ 0
        , \ldots
        , \#\text{ranks in node} - 1
        \right\}
  \right\}
\end{equation*}

<p>
and the <code>sendCounts</code> vector is simply the constant vector
<code>tuplesPerRankLocal</code> of size <code>ranksPerNode</code>.
</p>

<p>
TODO: Remove
</p>
<div class="org-src-container">
<pre class="src src-c++">{
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #a626a4;">const</span>
    <span style="color: #8b4513;">sendCounts</span>(nodeInfos[rank].ranksPerNode, tuplesPerRankLocal);

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt;
    <span style="color: #8b4513;">displacements</span>(nodeInfos[rank].ranksPerNode);

  <span style="font-weight: bold; text-decoration: underline;">std</span>::iota(displacements.begin(),
            displacements.end(),
            tuplesPerRankLocal);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">important!</span>
  result.resize(tuplesPerRankLocal);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">construct mpi type for abctuple</span>
  <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">MPI_ABCTUPLE</span>;
  MPI_Type_vector(nodeTuples[0].size(), 1, 1, MPI_UINT64_T, &amp;MPI_ABCTUPLE);
  MPI_Type_commit(&amp;MPI_ABCTUPLE);

  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"scattering tuples \n"</span>;
  MPI_Scatterv(nodeTuples.data(),
              sendCounts.data(),
              displacements.data(),
              MPI_ABCTUPLE,
              result.data(),
              tuplesPerRankLocal,
              MPI_ABCTUPLE,
              0,
              INTRA_COMM);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">free type</span>
  MPI_Type_free(&amp;MPI_ABCTUPLE);

}
</pre>
</div>

<p>
and now we have to make sure that the size of the result
is the same with every rank in the universe communicator,
inserting fake tuples where needed
</p>

<div class="org-src-container">
<pre class="src src-c++">
  LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"scattering tuples \n"</span>;

  <span style="color: #a626a4;">return</span> result;

}
</pre>
</div>
</div>
</li>

<li><a id="orgfebfcfc"></a>Interface<br />
<div class="outline-text-5" id="text-1-5-5-4">
<p>
The distribution interface will then simply be
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Distribution</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">TuplesDistribution</span> {
  <span style="color: #c18401;">ABCTuples</span> <span style="color: #0184bc;">getTuples</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>, <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span>) <span style="color: #a626a4;">override</span> {
    <span style="color: #a626a4;">return</span> main(universe, Nv);
  }
};
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgff9d736" class="outline-3">
<h3 id="orgff9d736"><span class="section-number-3">1.6</span> Unions</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Every slice pertaining to every different tensor
is sliced differently.
</p>


<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/SliceUnion.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoVector</span>
    ( <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; &amp;<span style="color: #8b4513;">v</span>
    , <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; &amp;<span style="color: #8b4513;">toSlice</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">low</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">up</span>
    , <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">origin</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">originLow</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">originUp</span>
    ) {
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Thank you CTF for forcing me to do this</span>
    <span style="color: #a626a4;">struct</span> { <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">up</span>, <span style="color: #8b4513;">low</span>; }
        <span style="color: #8b4513;">toSlice_</span> = { {up.begin(), up.end()}
                   , {low.begin(), low.end()} }
      , <span style="color: #8b4513;">origin_</span> = { {originUp.begin(), originUp.end()}
                  , {originLow.begin(), originLow.end()} }
      ;

    <span style="color: #c18401;">WITH_OCD</span>
    <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"slicing into "</span> &lt;&lt; pretty_print(toSlice_.up)
                          &lt;&lt; <span style="color: #50a14f;">","</span> &lt;&lt; pretty_print(toSlice_.low)
              &lt;&lt; <span style="color: #50a14f;">" from "</span> &lt;&lt; pretty_print(origin_.up)
                   &lt;&lt; <span style="color: #50a14f;">","</span> &lt;&lt; pretty_print(origin_.low)
              &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

<span style="color: #e44649;">#if</span><span style="color: #e44649; font-weight: bold;">n</span><span style="color: #e44649;">def</span> ATRIP_DONT_SLICE
    toSlice.slice( toSlice_.low.data()
                 , toSlice_.up.data()
                 , 0.0
                 , origin
                 , origin_.low.data()
                 , origin_.up.data()
                 , 1.0);
    memcpy(v.data(), toSlice.data, <span style="color: #a626a4;">sizeof</span>(<span style="color: #c18401;">double</span>) * v.size());
<span style="color: #e44649;">#endif</span>

  }


  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">TAPHH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">TAPHH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
         ) : SliceUnion( sourceTensor
                       , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::C}
                       , {Nv, No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                       , {Nv}
                       , np
                       , child_world
                       , global_world
                       , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::TA
                       , 4) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span>
    {
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = sliceLength[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">a</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it});
              ;


      sliceIntoVector( sources[it]
                     , to,   {0, 0, 0},    {Nv, No, No}
                     , from, {a, 0, 0, 0}, {a+1, Nv, No, No}
                     );

    }

  };


  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">HHHA</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">HHHA</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
        ) : SliceUnion( sourceTensor
                      , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::C}
                      , {No, No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                      , {Nv}         <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                      , np
                      , child_world
                      , global_world
                      , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::VIJKA
                      , 4) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span>
    {

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">No</span> = sliceLength[0]
              , <span style="color: #8b4513;">a</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              ;

      sliceIntoVector( sources[it]
                     , to,   {0, 0, 0},    {No, No, No}
                     , from, {0, 0, 0, a}, {No, No, No, a+1}
                     );

    }
  };

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">ABPH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">ABPH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
        ) : SliceUnion( sourceTensor
                      , { <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC
                        , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BA, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::CB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::CA
                        }
                      , {Nv, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                      , {Nv, Nv} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                      , np
                      , child_world
                      , global_world
                      , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::VABCI
                      , 2*6) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span> {

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = sliceLength[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">el</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              , <span style="color: #8b4513;">a</span> = el % Nv
              , <span style="color: #8b4513;">b</span> = el / Nv
              ;


      sliceIntoVector( sources[it]
                     , to,   {0, 0},       {Nv, No}
                     , from, {a, b, 0, 0}, {a+1, b+1, Nv, No}
                     );

    }

  };

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">ABHH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">ABHH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
        ) : SliceUnion( sourceTensor
                      , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC}
                      , {No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                      , {Nv, Nv} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                      , np
                      , child_world
                      , global_world
                      , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::VABIJ
                      , 6) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span> {

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = from.lens[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">el</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              , <span style="color: #8b4513;">a</span> = el % Nv
              , <span style="color: #8b4513;">b</span> = el / Nv
              ;

      sliceIntoVector( sources[it]
                     , to,   {0, 0},       {No, No}
                     , from, {a, b, 0, 0}, {a+1, b+1, No, No}
                     );


    }

  };


  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">TABHH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">TABHH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
         ) : SliceUnion( sourceTensor
                       , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC}
                       , {No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                       , {Nv, Nv} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                       , np
                       , child_world
                       , global_world
                       , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::TABIJ
                       , 6) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span> {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: maybe generalize this with ABHH</span>

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = from.lens[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">el</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              , <span style="color: #8b4513;">a</span> = el % Nv
              , <span style="color: #8b4513;">b</span> = el / Nv
              ;

      sliceIntoVector( sources[it]
                     , to,   {0, 0},       {No, No}
                     , from, {a, b, 0, 0}, {a+1, b+1, No, No}
                     );


    }

  };

}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgda4af1f" class="outline-3">
<h3 id="orgda4af1f"><span class="section-number-3">1.7</span> Equations</h3>
<div class="outline-text-3" id="text-1-7">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once

<span style="color: #e44649;">#include</span><span style="color: #50a14f;">&lt;atrip/Slice.hpp&gt;</span>
<span style="color: #e44649;">#include</span><span style="color: #50a14f;">&lt;atrip/Blas.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #c18401;">double</span> <span style="color: #0184bc;">getEnergyDistinct</span>
    ( <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">epsabc</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">epsi</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Tijk_</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Zijk_</span>
    ) {
    <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">blockSize</span>=16;
    <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>(0.);
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span> = epsi.size();
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kk</span>=0; kk&lt;No; kk+=blockSize){
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min(No, kk+blockSize) );
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jj</span>(kk); jj&lt;No; jj+=blockSize){
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( No, jj+blockSize) );
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ii</span>(jj); ii&lt;No; ii+=blockSize){
          <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">iend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( No, ii+blockSize) );
          <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span>(kk); k &lt; kend; k++){
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ek</span>(epsi[k]);
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jstart</span> = jj &gt; k ? jj : k;
            <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>(jstart); j &lt; jend; j++){
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ej</span>(epsi[j]);
              <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facjk</span>( j == k ? 0.5 : 1.0);
              <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">istart</span> = ii &gt; j ? ii : j;
              <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>(istart); i &lt; iend; i++){
                <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ei</span>(epsi[i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facij</span> ( i==j ? 0.5 : 1.0);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">denominator</span>(epsabc - ei - ej - ek);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">U</span>(Zijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">V</span>(Zijk_[i + No*k + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">W</span>(Zijk_[j + No*i + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">X</span>(Zijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">Y</span>(Zijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">Z</span>(Zijk_[k + No*j + No*No*i]);

                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">A</span>(Tijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">B</span>(Tijk_[i + No*k + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">C</span>(Tijk_[j + No*i + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">D</span>(Tijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">E</span>(Tijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">F</span>(Tijk_[k + No*j + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">value</span>(3.0*(<span style="color: #c18401;">A</span>*<span style="color: #8b4513;">U</span>+B*V+C*W+D*X+E*Y+F*Z)
                            +((U+X+Y)-2.0*(V+W+Z))*(A+D+E)
                            +((V+W+Z)-2.0*(U+X+Y))*(B+C+F));
                energy += 2.0*value / denominator * facjk * facij;
              } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i</span>
            } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">j</span>
          } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">k</span>
        } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ii</span>
      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">jj</span>
    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">kk</span>
    <span style="color: #a626a4;">return</span> energy;
  }


  <span style="color: #c18401;">double</span> <span style="color: #0184bc;">getEnergySame</span>
    ( <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">epsabc</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">epsi</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Tijk_</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Zijk_</span>
    ) {
    <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">blockSize</span> = 16;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span> = epsi.size();
    <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>(0.);
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kk</span>=0; kk&lt;No; kk+=blockSize){
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( kk+blockSize, No) );
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jj</span>(kk); jj&lt;No; jj+=blockSize){
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( jj+blockSize, No) );
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ii</span>(jj); ii&lt;No; ii+=blockSize){
          <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">iend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( ii+blockSize, No) );
          <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span>(kk); k &lt; kend; k++){
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ek</span>(epsi[k]);
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jstart</span> = jj &gt; k ? jj : k;
            <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>(jstart); j &lt; jend; j++){
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facjk</span>( j == k ? 0.5 : 1.0);
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ej</span>(epsi[j]);
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">istart</span> = ii &gt; j ? ii : j;
              <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>(istart); i &lt; iend; i++){
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ei</span>(epsi[i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facij</span> ( i==j ? 0.5 : 1.0);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">denominator</span>(epsabc - ei - ej - ek);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">U</span>(Zijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">V</span>(Zijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">W</span>(Zijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">A</span>(Tijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">B</span>(Tijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">C</span>(Tijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">value</span>(3.0*( <span style="color: #c18401;">A</span>*<span style="color: #8b4513;">U</span> + B*V + C*W) - (A+B+C)*(U+V+W));
                energy += 2.0*value / denominator * facjk * facij;
              } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i</span>
            } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">j</span>
          } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">k</span>
        } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ii</span>
      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">jj</span>
    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">kk</span>
    <span style="color: #a626a4;">return</span> energy;
  }

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">singlesContribution</span>
    ( <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
    , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
    , <span style="color: #a626a4;">const</span> <span style="color: #c18401;">ABCTuple</span> &amp;<span style="color: #8b4513;">abc</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">Tph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VABij</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VACij</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VBCij</span>
    , <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">Zijk</span>
    ) {
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">a</span>(abc[0]), <span style="color: #8b4513;">b</span>(abc[1]), <span style="color: #8b4513;">c</span>(abc[2]);
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span>=0; k &lt; No; k++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>=0; i &lt; No; i++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>=0; j &lt; No; j++) {
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ijk</span> = i + j*No + k*No*No
                ,  <span style="color: #8b4513;">jk</span> = j + No * k
                ;
      Zijk[ijk] += Tph[ a + i * Nv ] * VBCij[ j + k * No ];
      Zijk[ijk] += Tph[ b + j * Nv ] * VACij[ i + k * No ];
      Zijk[ijk] += Tph[ c + k * Nv ] * VABij[ i + j * No ];
    }
  }

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">doublesContribution</span>
    ( <span style="color: #a626a4;">const</span> <span style="color: #c18401;">ABCTuple</span> &amp;<span style="color: #8b4513;">abc</span>
    , <span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">No</span>
    , <span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">Nv</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VABCI</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VABph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VACph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VBCph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VBAph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VCAph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VCBph</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VHHHA</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VhhhA</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VhhhB</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VhhhC</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TA</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TAphh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TBphh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TCphh</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TABIJ</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TABhh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TAChh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TBChh</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TIJK</span>
    , <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">Tijk</span>
    ) {

    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">a</span> = abc[0], <span style="color: #8b4513;">b</span> = abc[1], <span style="color: #8b4513;">c</span> = abc[2]
              , <span style="color: #8b4513;">NoNo</span> = No*No, <span style="color: #8b4513;">NoNv</span> = No*Nv
              ;

<span style="color: #e44649;">#if</span> <span style="color: #e44649;">defined</span>(ATRIP_USE_DGEMM)
<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">_IJK_</span>(<span style="color: #8b4513;">i</span>, <span style="color: #8b4513;">j</span>, <span style="color: #8b4513;">k</span>) i + j*No + k*NoNo
<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">REORDER</span>(<span style="color: #8b4513;">__II</span>, <span style="color: #8b4513;">__JJ</span>, <span style="color: #8b4513;">__KK</span>)                           \
  WITH_CHRONO(<span style="color: #50a14f;">"double:reorder"</span>,                             \
              <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span> = 0; k &lt; No; k++)               \
                <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0; j &lt; No; j++)             \
                  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 0; i &lt; No; i++) {         \
                    Tijk[_IJK_(i, j, k)]                    \
                    += _t_buffer[_IJK_(__II, __JJ, __KK)];  \
                  }                                         \
              )
<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">DGEMM_PARTICLES</span>(<span style="color: #8b4513;">__A</span>, <span style="color: #8b4513;">__B</span>)               \
  <span style="font-weight: bold; text-decoration: underline;">atrip</span>::dgemm_(<span style="color: #50a14f;">"T"</span>,                            \
                <span style="color: #50a14f;">"N"</span>,                            \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo,              \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No,                \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;Nv,                \
                &amp;one,                           \
                __A,                            \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;Nv,                \
                __B,                            \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;Nv,                \
                &amp;zero,                          \
                _t_buffer.data(),               \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo);
<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">DGEMM_HOLES</span>(<span style="color: #8b4513;">__A</span>, <span style="color: #8b4513;">__B</span>, <span style="color: #8b4513;">__TRANSB</span>)         \
  <span style="font-weight: bold; text-decoration: underline;">atrip</span>::dgemm_(<span style="color: #50a14f;">"N"</span>,                            \
                __TRANSB,                       \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo,              \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No,                \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No,                \
                &amp;m_one,                         \
                __A,                            \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo,              \
                __B,                            \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No,                \
                &amp;zero,                          \
                _t_buffer.data(),               \
                (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo);

    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">F</span> = <span style="color: #c18401;">double</span>;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">NoNoNo</span> = No*NoNo;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">_t_buffer</span>;
    _t_buffer.reserve(NoNoNo);
    <span style="color: #c18401;">F</span> <span style="color: #8b4513;">one</span>{1.0}, <span style="color: #8b4513;">m_one</span>{-1.0}, <span style="color: #8b4513;">zero</span>{0.0};

    WITH_CHRONO(<span style="color: #50a14f;">"double:reorder"</span>,
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span> = 0; k &lt; NoNoNo; k++) {
         Tijk[k] = 0.0;
       })

    WITH_CHRONO(<span style="color: #50a14f;">"doubles:holes"</span>,
                { <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Holes part ================================================</span>
                  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhC[i + k*No + L*NoNo] * TABhh[L + j*No]; H1</span>
                  WITH_CHRONO(<span style="color: #50a14f;">"doubles:holes:1"</span>,
                              DGEMM_HOLES(VhhhC, TABhh, <span style="color: #50a14f;">"N"</span>)
                              REORDER(i, k, j)
                              )
                  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhC[j + k*No + L*NoNo] * TABhh[i + L*No]; H0</span>
                  WITH_CHRONO(<span style="color: #50a14f;">"doubles:holes:2"</span>,
                              DGEMM_HOLES(VhhhC, TABhh, <span style="color: #50a14f;">"T"</span>)
                              REORDER(j, k, i)
                              )
                  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhB[i + j*No + L*NoNo] * TAChh[L + k*No]; H5</span>
                  WITH_CHRONO(<span style="color: #50a14f;">"doubles:holes:3"</span>,
                              DGEMM_HOLES(VhhhB, TAChh, <span style="color: #50a14f;">"N"</span>)
                              REORDER(i, j, k)
                              )
                  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhB[k + j*No + L*NoNo] * TAChh[i + L*No]; H3</span>
                  WITH_CHRONO(<span style="color: #50a14f;">"doubles:holes:4"</span>,
                              DGEMM_HOLES(VhhhB, TAChh, <span style="color: #50a14f;">"T"</span>)
                              REORDER(k, j, i)
                              )
                  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhA[j + i*No + L*NoNo] * TBChh[L + k*No]; H1</span>
                  WITH_CHRONO(<span style="color: #50a14f;">"doubles:holes:5"</span>,
                              DGEMM_HOLES(VhhhA, TBChh, <span style="color: #50a14f;">"N"</span>)
                              REORDER(j, i, k)
                              )
                  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhA[k + i*No + L*NoNo] * TBChh[j + L*No]; H4</span>
                  WITH_CHRONO(<span style="color: #50a14f;">"doubles:holes:6"</span>,
                              DGEMM_HOLES(VhhhA, TBChh, <span style="color: #50a14f;">"T"</span>)
                              REORDER(k, i, j)
                              )
                }
                )

      WITH_CHRONO(<span style="color: #50a14f;">"doubles:particles"</span>,
                  { <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Particle part ===========================================</span>
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TAphh[E + i*Nv + j*NoNv] * VBCph[E + k*Nv]; P0</span>
                    WITH_CHRONO(<span style="color: #50a14f;">"doubles:particles:1"</span>,
                                DGEMM_PARTICLES(TAphh, VBCph)
                                REORDER(i, j, k)
                                )
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TAphh[E + i*Nv + k*NoNv] * VCBph[E + j*Nv]; P3</span>
                    WITH_CHRONO(<span style="color: #50a14f;">"doubles:particles:2"</span>,
                                DGEMM_PARTICLES(TAphh, VCBph)
                                REORDER(i, k, j)
                                )
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TCphh[E + k*Nv + i*NoNv] * VABph[E + j*Nv]; P5</span>
                    WITH_CHRONO(<span style="color: #50a14f;">"doubles:particles:3"</span>,
                                DGEMM_PARTICLES(TCphh, VABph)
                                REORDER(k, i, j)
                                )
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TCphh[E + k*Nv + j*NoNv] * VBAph[E + i*Nv]; P2</span>
                    WITH_CHRONO(<span style="color: #50a14f;">"doubles:particles:4"</span>,
                                DGEMM_PARTICLES(TCphh, VBAph)
                                REORDER(k, j, i)
                                )
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TBphh[E + j*Nv + i*NoNv] * VACph[E + k*Nv]; P1</span>
                    WITH_CHRONO(<span style="color: #50a14f;">"doubles:particles:5"</span>,
                                DGEMM_PARTICLES(TBphh, VACph)
                                REORDER(j, i, k)
                                )
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TBphh[E + j*Nv + k*NoNv] * VCAph[E + i*Nv]; P4</span>
                    WITH_CHRONO(<span style="color: #50a14f;">"doubles:particles:6"</span>,
                                DGEMM_PARTICLES(TBphh, VCAph)
                                REORDER(j, k, i)
                                )
                  }
                  )

<span style="color: #e44649;">#undef</span> REORDER
<span style="color: #e44649;">#undef</span> DGEMM_HOLES
<span style="color: #e44649;">#undef</span> DGEMM_PARTICLES
<span style="color: #e44649;">#undef</span> _IJK_
<span style="color: #e44649;">#else</span>
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span> = 0; k &lt; No; k++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0; j &lt; No; j++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 0; i &lt; No; i++){
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ijk</span> = i + j*No + k*NoNo
                ,  <span style="color: #8b4513;">jk</span> = j + k*No
                ;
      Tijk[ijk] = 0.0; <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">:important</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">HOLE DIAGRAMS: TABHH and VHHHA</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">L</span> = 0; L &lt; No; L++){
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[abLj] * V[Lcik]        H1</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[baLi] * V[Lcjk]        H0      TODO: conjugate T for complex</span>
        Tijk[ijk] -= TABhh[L + j*No] * VhhhC[i + k*No + L*NoNo];
        Tijk[ijk] -= TABhh[i + L*No] * VhhhC[j + k*No + L*NoNo];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[acLk] * V[Lbij]        H5</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[caLi] * V[Lbkj]        H3</span>
        Tijk[ijk] -= TAChh[L + k*No] * VhhhB[i + j*No + L*NoNo];
        Tijk[ijk] -= TAChh[i + L*No] * VhhhB[k + j*No + L*NoNo];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[bcLk] * V[Laji]        H2</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[cbLj] * V[Laki]        H4</span>
        Tijk[ijk] -= TBChh[L + k*No] * VhhhA[j + i*No + L*NoNo];
        Tijk[ijk] -= TBChh[j + L*No] * VhhhA[k + i*No + L*NoNo];
      }
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PARTILCE DIAGRAMS: TAPHH and VABPH</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">E</span> = 0; E &lt; Nv; E++) {
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[aEij] * V[bcEk]        P0</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[aEik] * V[cbEj]        P3 // TODO: CHECK THIS ONE, I DONT KNOW</span>
        Tijk[ijk] += TAphh[E + i*Nv + j*NoNv] * VBCph[E + k*Nv];
        Tijk[ijk] += TAphh[E + i*Nv + k*NoNv] * VCBph[E + j*Nv];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[cEki] * V[abEj]        P5</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[cEkj] * V[baEi]        P2</span>
        Tijk[ijk] += TCphh[E + k*Nv + i*NoNv] * VABph[E + j*Nv];
        Tijk[ijk] += TCphh[E + k*Nv + j*NoNv] * VBAph[E + i*Nv];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[bEji] * V[acEk]        P1</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[bEjk] * V[caEi]        P4</span>
        Tijk[ijk] += TBphh[E + j*Nv + i*NoNv] * VACph[E + k*Nv];
        Tijk[ijk] += TBphh[E + j*Nv + k*NoNv] * VCAph[E + i*Nv];
      }

    }
<span style="color: #e44649;">#endif</span>
  }

}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcc16f04" class="outline-3">
<h3 id="orgcc16f04"><span class="section-number-3">1.8</span> Blas</h3>
<div class="outline-text-3" id="text-1-8">
<p>
The main matrix-matrix multiplication method used in this algorithm
is mainly using the <code>DGEMM</code> function, which we declare as
<code>extern</code> since it should be known only at link-time.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {
  <span style="color: #a626a4;">extern</span> <span style="color: #50a14f;">"C"</span> {
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">dgemm_</span>(
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">char</span> *<span style="color: #8b4513;">transa</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">char</span> *<span style="color: #8b4513;">transb</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">m</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">n</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">k</span>,
      <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">alpha</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">A</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">lda</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">B</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">ldb</span>,
      <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">beta</span>,
      <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">C</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">ldc</span>
    );
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a888d9" class="outline-3">
<h3 id="org9a888d9"><span class="section-number-3">1.9</span> Atrip</h3>
<div class="outline-text-3" id="text-1-9">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;sstream&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;string&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;map&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;ctf.hpp&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Utils.hpp&gt;</span>

<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">ADD_ATTRIBUTE</span>(<span style="color: #8b4513;">_type</span>, <span style="color: #8b4513;">_name</span>, <span style="color: #8b4513;">_default</span>)   \
  <span style="color: #c18401;">_type</span> <span style="color: #8b4513;">_name</span> = _default;                       \
  <span style="color: #c18401;">Input</span>&amp; <span style="color: #8b4513;">with_</span> ## _name(<span style="color: #c18401;">_type</span> <span style="color: #8b4513;">i</span>) {              \
    _name = i;                                  \
    <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>;                               \
  }

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Atrip</span> {

    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span>;
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">np</span>;
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">Timings</span> <span style="color: #8b4513;">chrono</span>;
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">init</span>();

    <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Input</span> {
      <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; *<span style="color: #8b4513;">ei</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">ea</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Tph</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Tpphh</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Vpphh</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Vhhhp</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Vppph</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        ;
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_epsilon_i</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { ei = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_epsilon_a</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { ea = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Tai</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Tph = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Tabij</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Tpphh = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Vabij</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Vpphh = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Vijka</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Vhhhp = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Vabci</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Vppph = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }

      <span style="color: #a626a4;">enum</span> <span style="color: #c18401;">TuplesDistribution</span> {
        <span style="color: #8b4513;">NAIVE</span>,
        <span style="color: #8b4513;">GROUP_AND_SORT</span>,
      };

      ADD_ATTRIBUTE(<span style="color: #c18401;">bool</span>, chrono, <span style="font-weight: bold; text-decoration: underline;">false</span>)
      ADD_ATTRIBUTE(<span style="color: #c18401;">bool</span>, barrier, <span style="font-weight: bold; text-decoration: underline;">false</span>)
      ADD_ATTRIBUTE(<span style="color: #c18401;">int</span>, maxIterations, 0)
      ADD_ATTRIBUTE(<span style="color: #c18401;">int</span>, iterationMod, -1)
      ADD_ATTRIBUTE(<span style="color: #c18401;">TuplesDistribution</span>, tuplesDistribution, NAIVE)


    };

    <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Output</span> {
      <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>;
    };
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">Output</span> <span style="color: #0184bc;">run</span>(<span style="color: #c18401;">Input</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">in</span>);
  };

}

<span style="color: #e44649;">#undef</span> ADD_ATTRIBUTE
</pre>
</div>
</div>

<div id="outline-container-orga754d1d" class="outline-4">
<h4 id="orga754d1d"><span class="section-number-4">1.9.1</span> Main</h4>
<div class="outline-text-4" id="text-1-9-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;iomanip&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Atrip.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Utils.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Equations.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/SliceUnion.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Unions.hpp&gt;</span>

<span style="color: #a626a4;">using</span> <span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span>;

<span style="color: #c18401;">int</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #8b4513;">rank</span>;
<span style="color: #c18401;">int</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #8b4513;">np</span>;
<span style="color: #c18401;">Timings</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #8b4513;">chrono</span>;

<span style="color: #c18401;">void</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #0184bc;">init</span>()  {
  MPI_Comm_rank(MPI_COMM_WORLD, &amp;<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank);
  MPI_Comm_size(MPI_COMM_WORLD, &amp;<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::np);
}

<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #c18401;">Output</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #0184bc;">run</span>(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #c18401;">Input</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">in</span>) {

  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">np</span> = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::np;
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span> = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank;
  <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span> = in.ei-&gt;wrld-&gt;comm;

  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span> = in.ei-&gt;lens[0];
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span> = in.ea-&gt;lens[0];
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"No: "</span> &lt;&lt; No &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"Nv: "</span> &lt;&lt; Nv &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">allocate the three scratches, see piecuch</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">Tijk</span>(No*No*No) <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">doubles only (see piecuch)</span>
                    , <span style="color: #8b4513;">Zijk</span>(No*No*No) <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">singles + doubles (see piecuch)</span>
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we need local copies of the following tensors on every</span>
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">rank</span>
                    , <span style="color: #8b4513;">epsi</span>(No)
                    , <span style="color: #8b4513;">epsa</span>(Nv)
                    , <span style="color: #8b4513;">Tai</span>(No * Nv)
                    ;

  in.ei-&gt;read_all(epsi.data());
  in.ea-&gt;read_all(epsa.data());
  in.Tph-&gt;read_all(Tai.data());

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMMUNICATOR CONSTRUCTION ========================================={{{1</span>
  <span style="color: #a0a1a7; font-weight: bold;">//</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Construct a new communicator living only on a single rank</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">child_size</span> = 1
    , <span style="color: #8b4513;">child_rank</span>
    ;
  <span style="color: #a626a4;">const</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">color</span> = rank / child_size
    , <span style="color: #8b4513;">crank</span> = rank % child_size
    ;
  <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_comm</span>;
  <span style="color: #a626a4;">if</span> (np == 1) {
    child_comm = universe;
  } <span style="color: #a626a4;">else</span> {
    MPI_Comm_split(universe, color, crank, &amp;child_comm);
    MPI_Comm_rank(child_comm, &amp;child_rank);
    MPI_Comm_size(child_comm, &amp;child_size);
  }


  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">BUILD SLICES PARAMETRIZED BY NV ==================================={{{1</span>
  WITH_CHRONO(<span style="color: #50a14f;">"nv-slices"</span>,
    LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"BUILD NV-SLICES\n"</span>;
    <span style="color: #c18401;">TAPHH</span> <span style="color: #8b4513;">taphh</span>(*in.Tpphh, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
    <span style="color: #c18401;">HHHA</span>  <span style="color: #8b4513;">hhha</span>(*in.Vhhhp, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
  )

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">BUILD SLICES PARAMETRIZED BY NV x NV =============================={{{1</span>
  WITH_CHRONO(<span style="color: #50a14f;">"nv-nv-slices"</span>,
    LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"BUILD NV x NV-SLICES\n"</span>;
    <span style="color: #c18401;">ABPH</span> <span style="color: #8b4513;">abph</span>(*in.Vppph, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
    <span style="color: #c18401;">ABHH</span> <span style="color: #8b4513;">abhh</span>(*in.Vpphh, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
    <span style="color: #c18401;">TABHH</span> <span style="color: #8b4513;">tabhh</span>(*in.Tpphh, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
  )

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">all tensors</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="color: #c18401;">SliceUnion</span>* &gt; <span style="color: #8b4513;">unions</span> = {&amp;taphh, &amp;hhha, &amp;abph, &amp;abhh, &amp;tabhh};

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">get tuples for the current rank</span>
  <span style="color: #c18401;">TuplesDistribution</span> *<span style="color: #8b4513;">distribution</span>;

  <span style="color: #a626a4;">if</span> (in.tuplesDistribution == <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Input</span>::<span style="font-weight: bold; text-decoration: underline;">TuplesDistribution</span>::NAIVE) {
    LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"Using the naive distribution\n"</span>;
    distribution = <span style="color: #a626a4;">new</span> <span style="color: #c18401;">NaiveDistribution</span>();
  } <span style="color: #a626a4;">else</span> {
    LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"Using the group-and-sort distribution\n"</span>;
    distribution = <span style="color: #a626a4;">new</span> <span style="font-weight: bold; text-decoration: underline;">group_and_sort</span>::<span style="color: #c18401;">Distribution</span>();
  }

  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"BUILDING TUPLE LIST\n"</span>;
  WITH_CHRONO(<span style="color: #50a14f;">"tuples:build"</span>,
    <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">tuplesList</span> = distribution-&gt;getTuples(Nv, universe);
    )
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nIterations</span> = tuplesList.size();
  {
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">_all_tuples</span> = Nv * (Nv + 1) * (Nv + 2) / 6 - Nv;
    LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#iterations: "</span>
                  &lt;&lt; nIterations
                  &lt;&lt; <span style="color: #50a14f;">"/"</span>
                  &lt;&lt; nIterations * np
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  }


  <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">isFakeTuple</span>
    = [&amp;<span style="color: #8b4513;">tuplesList</span>, <span style="font-weight: bold; text-decoration: underline;">distribution</span>](<span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">i</span>) {
      <span style="color: #a626a4;">return</span> distribution-&gt;tupleIsFake(tuplesList[i]);
    };


  <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">communicateDatabase</span>
    = [ &amp;<span style="color: #8b4513;">unions</span>
      , <span style="font-weight: bold; text-decoration: underline;">np</span>
      ] (<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>, <span style="color: #c18401;">MPI_Comm</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">c</span>) -&gt; <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Database {

        WITH_CHRONO(<span style="color: #50a14f;">"db:comm:type:do"</span>,
          <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">MPI_LDB_ELEMENT</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="font-weight: bold; text-decoration: underline;">mpi</span>::localDatabaseElement();
        )

        WITH_CHRONO(<span style="color: #50a14f;">"db:comm:ldb"</span>,
          <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabase</span> <span style="color: #8b4513;">ldb</span>;
          <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tensor</span>: unions) {
            <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tensorDb</span> = tensor-&gt;buildLocalDatabase(abc);
            ldb.insert(ldb.end(), tensorDb.begin(), tensorDb.end());
          }
        )

        <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Database</span> <span style="color: #8b4513;">db</span>(np * ldb.size(), ldb[0]);

        WITH_CHRONO(<span style="color: #50a14f;">"oneshot-db:comm:allgather"</span>,
        WITH_CHRONO(<span style="color: #50a14f;">"db:comm:allgather"</span>,
          MPI_Allgather( ldb.data()
                      , ldb.size()
                      , MPI_LDB_ELEMENT
                      , db.data()
                      , ldb.size()
                      , MPI_LDB_ELEMENT
                      , c);
        ))

        WITH_CHRONO(<span style="color: #50a14f;">"db:comm:type:free"</span>,
          MPI_Type_free(&amp;MPI_LDB_ELEMENT);
        )

        <span style="color: #a626a4;">return</span> db;
      };

  <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">doIOPhase</span>
    = [&amp;<span style="color: #8b4513;">unions</span>, &amp;<span style="color: #8b4513;">rank</span>, &amp;<span style="color: #8b4513;">np</span>, &amp;<span style="color: #8b4513;">universe</span>] (<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Database</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">db</span>) {

    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">localDBLength</span> = db.size() / np;

    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">sendTag</span> = 0
         , <span style="color: #8b4513;">recvTag</span> = rank * localDBLength
         ;

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">RECIEVE PHASE ======================================================</span>
    {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">At this point, we have already send to everyone that fits</span>
      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">begin</span> = &amp;db[rank * localDBLength]
                , <span style="color: #8b4513;">end</span>   = begin + localDBLength
                ;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">it</span> = begin; it != end; ++it) {
        recvTag++;
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">el</span> = *it;
        <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span> = unionByName(unions, el.name);

        <span style="color: #c18401;">WITH_DBG</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #8b4513;">cout</span>
          &lt;&lt; rank &lt;&lt; <span style="color: #50a14f;">":r"</span>
          &lt;&lt; <span style="color: #50a14f;">"&#9839;"</span> &lt;&lt; recvTag &lt;&lt; <span style="color: #50a14f;">" =&gt;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#171;n"</span> &lt;&lt; el.name
          &lt;&lt; <span style="color: #50a14f;">", t"</span> &lt;&lt; el.info.type
          &lt;&lt; <span style="color: #50a14f;">", s"</span> &lt;&lt; el.info.state
          &lt;&lt; <span style="color: #50a14f;">"&#187;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8857; {"</span> &lt;&lt; rank &lt;&lt; <span style="color: #50a14f;">"&#8656;"</span> &lt;&lt; el.info.from.rank
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.from.source &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8756; {"</span> &lt;&lt; el.info.tuple[0]
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.tuple[1]
                    &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">"\n"</span>
          ;

        WITH_CHRONO(<span style="color: #50a14f;">"db:io:recv"</span>,
          u.receive(el.info, recvTag);
        )

      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">recv</span>
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">SEND PHASE =========================================================</span>
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">otherRank</span> = 0; otherRank&lt;np; otherRank++) {
      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">begin</span> = &amp;db[otherRank * localDBLength]
                , <span style="color: #8b4513;">end</span> = begin + localDBLength
                ;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">it</span> = begin; it != end; ++it) {
        sendTag++;
        <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabaseElement</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">el</span> = *it;

        <span style="color: #a626a4;">if</span> (el.info.from.rank != rank) <span style="color: #a626a4;">continue</span>;

        <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span> = unionByName(unions, el.name);
        <span style="color: #c18401;">WITH_DBG</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #8b4513;">cout</span>
          &lt;&lt; rank &lt;&lt; <span style="color: #50a14f;">":s"</span>
          &lt;&lt; <span style="color: #50a14f;">"&#9839;"</span> &lt;&lt; sendTag &lt;&lt; <span style="color: #50a14f;">" =&gt;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#171;n"</span> &lt;&lt; el.name
          &lt;&lt; <span style="color: #50a14f;">", t"</span> &lt;&lt; el.info.type
          &lt;&lt; <span style="color: #50a14f;">", s"</span> &lt;&lt; el.info.state
          &lt;&lt; <span style="color: #50a14f;">"&#187;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8857; {"</span> &lt;&lt; el.info.from.rank &lt;&lt; <span style="color: #50a14f;">"&#8658;"</span> &lt;&lt; otherRank
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.from.source &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8756; {"</span> &lt;&lt; el.info.tuple[0]
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.tuple[1]
                    &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">"\n"</span>
          ;

        WITH_CHRONO(<span style="color: #50a14f;">"db:io:send"</span>,
          u.send(otherRank, el.info, sendTag);
        )

      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">send phase</span>

    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">otherRank</span>


  };

<span style="color: #e44649;">#if</span> <span style="color: #e44649;">defined</span>(HAVE_OCD) || <span style="color: #e44649;">defined</span>(ATRIP_PRINT_TUPLES)
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">map</span>&lt;<span style="color: #c18401;">ABCTuple</span>, <span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">tupleEnergies</span>;
<span style="color: #e44649;">#endif</span>

  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">doublesFlops</span>
    = <span style="color: #c18401;">double</span>(No)
    * <span style="color: #c18401;">double</span>(No)
    * <span style="color: #c18401;">double</span>(No)
    * (<span style="color: #c18401;">double</span>(<span style="color: #8b4513;">No</span>) + <span style="color: #c18401;">double</span>(Nv))
    * 2
    * 6
    / 1e9
    ;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">START MAIN LOOP ======================================================{{{1</span>

  <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>(0.);

  <span style="color: #a626a4;">for</span> ( <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 0, <span style="color: #8b4513;">iteration</span> = 1
      ; i &lt; tuplesList.size()
      ; i++, iteration++
      ) {
    <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono[<span style="color: #50a14f;">"iterations"</span>].start();

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check overhead from chrono over all iterations</span>
    WITH_CHRONO(<span style="color: #50a14f;">"start:stop"</span>, {})

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check overhead of doing a barrier at the beginning</span>
    WITH_CHRONO(<span style="color: #50a14f;">"oneshot-mpi:barrier"</span>,
    WITH_CHRONO(<span style="color: #50a14f;">"mpi:barrier"</span>,
      <span style="color: #a626a4;">if</span> (in.barrier) MPI_Barrier(universe);
    ))

    <span style="color: #a626a4;">if</span> (iteration % in.iterationMod == 0) {
      LOG(0,<span style="color: #50a14f;">"Atrip"</span>)
        &lt;&lt; <span style="color: #50a14f;">"iteration "</span> &lt;&lt; iteration
        &lt;&lt; <span style="color: #50a14f;">" ["</span> &lt;&lt; 100 * iteration / nIterations &lt;&lt; <span style="color: #50a14f;">"%]"</span>
        &lt;&lt; <span style="color: #50a14f;">" ("</span> &lt;&lt; doublesFlops * iteration / <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono[<span style="color: #50a14f;">"doubles"</span>].count()
        &lt;&lt; <span style="color: #50a14f;">"GF)"</span>
        &lt;&lt; <span style="color: #50a14f;">" ("</span> &lt;&lt; doublesFlops * iteration / <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono[<span style="color: #50a14f;">"iterations"</span>].count()
        &lt;&lt; <span style="color: #50a14f;">"GF)"</span>
        &lt;&lt; <span style="color: #50a14f;">" ===========================\n"</span>;

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PRINT TIMINGS</span>
      <span style="color: #a626a4;">if</span> (in.chrono)
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono)
        LOG(1, <span style="color: #50a14f;">" "</span>) &lt;&lt; pair.first &lt;&lt; <span style="color: #50a14f;">" :: "</span>
                    &lt;&lt; pair.second.count()
                    &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::endl;

    }

    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">abc</span> = isFakeTuple(i)
                       ? tuplesList[tuplesList.size() - 1]
                       : tuplesList[i]
                 , *<span style="color: #8b4513;">abcNext</span> = i == (tuplesList.size() - 1)
                            ? <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                            : &amp;tuplesList[i + 1]
                 ;

    WITH_CHRONO(<span style="color: #50a14f;">"with_rank"</span>,
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">" :it "</span> &lt;&lt; iteration
                &lt;&lt; <span style="color: #50a14f;">" :abc "</span> &lt;&lt; pretty_print(abc)
                &lt;&lt; <span style="color: #50a14f;">" :abcN "</span>
                &lt;&lt; (abcNext ? pretty_print(*abcNext) : <span style="color: #50a14f;">"None"</span>)
                &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    )


    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMM FIRST DATABASE ================================================{{{1</span>
    <span style="color: #a626a4;">if</span> (i == 0) {
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database ............ \n"</span>;
      <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">db</span> = communicateDatabase(abc, universe);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database communicated \n"</span>;
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database io phase \n"</span>;
      doIOPhase(db);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database io phase DONE\n"</span>;
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__::::Unwrapping all slices for first database\n"</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: unions) u-&gt;unwrapAll(abc);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__::::Unwrapping slices for first database DONE\n"</span>;
      MPI_Barrier(universe);
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMM NEXT DATABASE ================================================={{{1</span>
    <span style="color: #a626a4;">if</span> (abcNext) {
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__comm__:"</span> &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"th communicating database\n"</span>;
      WITH_CHRONO(<span style="color: #50a14f;">"db:comm"</span>,
        <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">db</span> = communicateDatabase(*abcNext, universe);
      )
      WITH_CHRONO(<span style="color: #50a14f;">"db:io"</span>,
        doIOPhase(db);
      )
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__comm__:"</span> &lt;&lt;  iteration &lt;&lt; <span style="color: #50a14f;">"th database io phase DONE\n"</span>;
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMPUTE DOUBLES ===================================================={{{1</span>
    OCD_Barrier(universe);
    <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>isFakeTuple(i)) {
      WITH_RANK &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th doubles\n"</span>;
      WITH_CHRONO(<span style="color: #50a14f;">"oneshot-unwrap"</span>,
      WITH_CHRONO(<span style="color: #50a14f;">"unwrap"</span>,
      WITH_CHRONO(<span style="color: #50a14f;">"unwrap:doubles"</span>,
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: <span style="color: #a626a4;">decltype</span>(unions){&amp;abph, &amp;hhha, &amp;taphh, &amp;tabhh}) {
          u-&gt;unwrapAll(abc);
        }
      )))
      WITH_CHRONO(<span style="color: #50a14f;">"oneshot-doubles"</span>,
      WITH_CHRONO(<span style="color: #50a14f;">"doubles"</span>,
        doublesContribution( abc, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv
                          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VABCI</span>
                          , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, abc)
                          , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC, abc)
                          , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, abc)
                          , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BA, abc)
                          , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::CA, abc)
                          , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::CB, abc)
                          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VHHHA</span>
                          , hhha.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, abc)
                          , hhha.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, abc)
                          , hhha.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::C, abc)
                          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TA</span>
                          , taphh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, abc)
                          , taphh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, abc)
                          , taphh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::C, abc)
                          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TABIJ</span>
                          , tabhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, abc)
                          , tabhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC, abc)
                          , tabhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, abc)
                          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TIJK</span>
                          , Tijk.data()
                          );
        WITH_RANK &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th doubles done\n"</span>;
      ))
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMPUTE SINGLES =================================================== {{{1</span>
    OCD_Barrier(universe);
    <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>isFakeTuple(i)) {
      WITH_CHRONO(<span style="color: #50a14f;">"oneshot-unwrap"</span>,
      WITH_CHRONO(<span style="color: #50a14f;">"unwrap"</span>,
      WITH_CHRONO(<span style="color: #50a14f;">"unwrap:singles"</span>,
        abhh.unwrapAll(abc);
      )))
      WITH_CHRONO(<span style="color: #50a14f;">"reorder"</span>,
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">I</span>(0); I &lt; Zijk.size(); I++) Zijk[I] = Tijk[I];
      )
      WITH_CHRONO(<span style="color: #50a14f;">"singles"</span>,
        singlesContribution( No, Nv, abc
                          , Tai.data()
                          , abhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, abc)
                          , abhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC, abc)
                          , abhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, abc)
                          , Zijk.data());
      )
    }


    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMPUTE ENERGY ==================================================== {{{1</span>
    <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>isFakeTuple(i)) {
      <span style="color: #c18401;">double</span> <span style="color: #8b4513;">tupleEnergy</span>(0.);

      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">distinct</span>(0);
      <span style="color: #a626a4;">if</span> (abc[0] == abc[1]) distinct++;
      <span style="color: #a626a4;">if</span> (abc[1] == abc[2]) distinct--;
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">epsabc</span>(epsa[abc[0]] + epsa[abc[1]] + epsa[abc[2]]);

      WITH_CHRONO(<span style="color: #50a14f;">"energy"</span>,
        <span style="color: #a626a4;">if</span> ( distinct == 0)
          tupleEnergy = getEnergyDistinct(epsabc, epsi, Tijk, Zijk);
        <span style="color: #a626a4;">else</span>
          tupleEnergy = getEnergySame(epsabc, epsi, Tijk, Zijk);
      )

<span style="color: #e44649;">#if</span> <span style="color: #e44649;">defined</span>(HAVE_OCD) || <span style="color: #e44649;">defined</span>(ATRIP_PRINT_TUPLES)
      tupleEnergies[abc] = tupleEnergy;
<span style="color: #e44649;">#endif</span>

      energy += tupleEnergy;

    }

    <span style="color: #a626a4;">if</span> (isFakeTuple(i)) {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">fake iterations should also unwrap whatever they got</span>
      WITH_RANK &lt;&lt; iteration
                &lt;&lt; <span style="color: #50a14f;">"th unwrapping because of fake in "</span>
                &lt;&lt; i &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: unions) u-&gt;unwrapAll(abc);
    }

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
    <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">u</span>: unions) {
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__dups__:"</span>
                &lt;&lt; iteration
                &lt;&lt; <span style="color: #50a14f;">"-th n"</span> &lt;&lt; u-&gt;name &lt;&lt; <span style="color: #50a14f;">" checking duplicates\n"</span>;
      u-&gt;checkForDuplicates();
    }
<span style="color: #e44649;">#endif</span>


    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">CLEANUP UNIONS ===================================================={{{1</span>
    OCD_Barrier(universe);
    <span style="color: #a626a4;">if</span> (abcNext) {
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th cleaning up.......\n"</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: unions) {

        u-&gt;unwrapAll(abc);
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__:n"</span> &lt;&lt; u-&gt;name  &lt;&lt; <span style="color: #50a14f;">" :it "</span> &lt;&lt; iteration
                  &lt;&lt; <span style="color: #50a14f;">" :abc "</span> &lt;&lt; pretty_print(abc)
                  &lt;&lt; <span style="color: #50a14f;">" :abcN "</span> &lt;&lt; pretty_print(*abcNext)
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">slice</span>: u-&gt;slices)
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__:guts:"</span> &lt;&lt; slice.info &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        u-&gt;clearUnusedSlicesForNext(*abcNext);

        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__: checking validity\n"</span>;

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check for validity of the slices</span>
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">type</span>: u-&gt;sliceTypes) {
          <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, type);
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span>: u-&gt;slices) {
          <span style="color: #a626a4;">if</span> ( slice.info.type == type
             &amp;&amp; slice.info.tuple == tuple
             &amp;&amp; slice.isDirectlyFetchable()
             ) {
            <span style="color: #a626a4;">if</span> (slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Dispatched)
              <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"This slice should not be undispatched! "</span>
                                     + pretty_print(slice.info));
          }
        }
        }
<span style="color: #e44649;">#endif</span>


      }
    }

      WITH_RANK &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th cleaning up....... DONE\n"</span>;

    <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono[<span style="color: #50a14f;">"iterations"</span>].stop();
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ITERATION END ====================================================={{{1</span>

  }
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">END OF MAIN LOOP</span>

  MPI_Barrier(universe);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PRINT TUPLES ========================================================={{{1</span>
<span style="color: #e44649;">#if</span> <span style="color: #e44649;">defined</span>(HAVE_OCD) || <span style="color: #e44649;">defined</span>(ATRIP_PRINT_TUPLES)
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"tuple energies"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 0; i &lt; np; i++) {
    MPI_Barrier(universe);
    <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: tupleEnergies) {
      <span style="color: #a626a4;">if</span> (i == rank)
        <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; pair.first[0]
                  &lt;&lt; <span style="color: #50a14f;">" "</span> &lt;&lt; pair.first[1]
                  &lt;&lt; <span style="color: #50a14f;">" "</span> &lt;&lt; pair.first[2]
                  &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setprecision(15) &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setw(23)
                  &lt;&lt; <span style="color: #50a14f;">" tupleEnergy: "</span> &lt;&lt; pair.second
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>
                  ;
    }
  }
<span style="color: #e44649;">#endif</span>

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMMUNICATE THE ENERGIES ============================================={{{1</span>
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"COMMUNICATING ENERGIES \n"</span>;
  <span style="color: #c18401;">double</span> <span style="color: #8b4513;">globalEnergy</span> = 0;
  MPI_Reduce(&amp;energy, &amp;globalEnergy, 1, MPI_DOUBLE, MPI_SUM, 0, universe);

  WITH_RANK &lt;&lt; <span style="color: #50a14f;">"local energy "</span> &lt;&lt; energy &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(0, <span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"Energy: "</span>
    &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setprecision(15) &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setw(23)
    &lt;&lt; (- globalEnergy) &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::endl;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PRINT TIMINGS {{{1</span>
  <span style="color: #a626a4;">if</span> (in.chrono)
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono)
    LOG(0,<span style="color: #50a14f;">"atrip:chrono"</span>) &lt;&lt; pair.first &lt;&lt; <span style="color: #50a14f;">" "</span>
                          &lt;&lt; pair.second.count() &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::endl;


  LOG(0, <span style="color: #50a14f;">"atrip:flops(doubles)"</span>)
    &lt;&lt; nIterations * doublesFlops / <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono[<span style="color: #50a14f;">"doubles"</span>].count() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(0, <span style="color: #50a14f;">"atrip:flops(iterations)"</span>)
    &lt;&lt; nIterations * doublesFlops / <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::chrono[<span style="color: #50a14f;">"iterations"</span>].count() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: change the sign in  the getEnergy routines</span>
  <span style="color: #a626a4;">return</span> { - globalEnergy };

}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org0de53b1" class="outline-3">
<h3 id="org0de53b1"><span class="section-number-3">1.10</span> Debug</h3>
<div class="outline-text-3" id="text-1-10">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#define</span> <span style="color: #8b4513;">ATRIP_BENCHMARK</span>
<span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">#define ATRIP_DONT_SLICE</span>
<span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">#define ATRIP_WORKLOAD_DUMP</span>
<span style="color: #e44649;">#define</span> <span style="color: #8b4513;">ATRIP_USE_DGEMM</span>
<span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">#define ATRIP_PRINT_TUPLES</span>

<span style="color: #e44649;">#if</span><span style="color: #e44649; font-weight: bold;">n</span><span style="color: #e44649;">def</span> ATRIP_DEBUG
<span style="color: #e44649;">#define</span> <span style="color: #8b4513;">ATRIP_DEBUG</span> 1
<span style="color: #e44649;">#endif</span>

<span style="color: #e44649;">#if</span><span style="color: #e44649; font-weight: bold;">n</span><span style="color: #e44649;">def</span> LOG
<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">LOG</span>(<span style="color: #8b4513;">level</span>, <span style="color: #8b4513;">name</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0) <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#endif</span>

<span style="color: #e44649;">#if</span> ATRIP_DEBUG == 4
<span style="color: #e44649;">#  pragma</span> message(<span style="color: #50a14f;">"WARNING: You have OCD debugging ABC triples "</span>\
                  <span style="color: #50a14f;">"expect GB of output and consult your therapist"</span>)
<span style="color: #e44649;">#  include</span> <span style="color: #50a14f;">&lt;dbg.h&gt;</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">HAVE_OCD</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>) MPI_Barrier(com)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == r)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...) dbg(__VA_ARGS__)
<span style="color: #e44649;">#elif</span> ATRIP_DEBUG == 3
<span style="color: #e44649;">#  pragma</span> message(<span style="color: #50a14f;">"WARNING: You have crazy debugging ABC triples,"</span>\
                  <span style="color: #50a14f;">" expect GB of output"</span>)
<span style="color: #e44649;">#  include</span> <span style="color: #50a14f;">&lt;dbg.h&gt;</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == r)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...) dbg(__VA_ARGS__)
<span style="color: #e44649;">#elif</span> ATRIP_DEBUG == 2
<span style="color: #e44649;">#  pragma</span> message(<span style="color: #50a14f;">"WARNING: You have some debugging info for ABC triples"</span>)
<span style="color: #e44649;">#  include</span> <span style="color: #50a14f;">&lt;dbg.h&gt;</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == r)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...) dbg(__VA_ARGS__)
<span style="color: #e44649;">#else</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>) <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...)
<span style="color: #e44649;">#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd6baa53" class="outline-3">
<h3 id="orgd6baa53"><span class="section-number-3">1.11</span> Include header</h3>
<div class="outline-text-3" id="text-1-11">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Atrip.hpp&gt;</span>

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2021-11-04 Thu 15:23</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
