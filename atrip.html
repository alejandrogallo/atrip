
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ATRIP: An MPI-asynchronous implementation of CCSD(T) &#8212; Atrip  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="ATRIP: An MPI-asynchronous implementation of CCSD(T)" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="ATRIP: An MPI-asynchronous implementation of CCSD(T)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Atrip  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ATRIP: An MPI-asynchronous implementation of CCSD(T)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="atrip-an-mpi-asynchronous-implementation-of-ccsd-t">
<h1><a class="toc-backref" href="#id4">ATRIP: An MPI-asynchronous implementation of CCSD(T)</a><a class="headerlink" href="#atrip-an-mpi-asynchronous-implementation-of-ccsd-t" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#atrip-an-mpi-asynchronous-implementation-of-ccsd-t" id="id4">ATRIP: An MPI-asynchronous implementation of CCSD(T)</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction" id="id5">1 Introduction</a></p></li>
<li><p><a class="reference internal" href="#the-slice" id="id6">2 The slice</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id7">2.1 Introduction</a></p></li>
<li><p><a class="reference internal" href="#location" id="id8">2.2 Location</a></p></li>
<li><p><a class="reference internal" href="#type" id="id9">2.3 Type</a></p></li>
<li><p><a class="reference internal" href="#state" id="id10">2.4 State</a></p></li>
<li><p><a class="reference internal" href="#the-info-structure" id="id11">2.5 The Info structure</a></p></li>
<li><p><a class="reference internal" href="#name" id="id12">2.6 Name</a></p></li>
<li><p><a class="reference internal" href="#database" id="id13">2.7 Database</a></p></li>
<li><p><a class="reference internal" href="#mpi-types" id="id14">2.8 MPI Types</a></p></li>
<li><p><a class="reference internal" href="#static-utilities" id="id15">2.9 Static utilities</a></p></li>
<li><p><a class="reference internal" href="#attributes" id="id16">2.10 Attributes</a></p></li>
<li><p><a class="reference internal" href="#member-functions" id="id17">2.11 Member functions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#utils" id="id18">3 Utils</a></p>
<ul>
<li><p><a class="reference internal" href="#pretty-printing" id="id19">3.1 Pretty printing</a></p></li>
<li><p><a class="reference internal" href="#chrono" id="id20">3.2 Chrono</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-rank-mapping" id="id21">4 The rank mapping</a></p></li>
<li><p><a class="reference internal" href="#the-slice-union" id="id22">5 The slice union</a></p></li>
<li><p><a class="reference internal" href="#tuples" id="id23">6 Tuples</a></p>
<ul>
<li><p><a class="reference internal" href="#tuples-types" id="id24">6.1 Tuples types</a></p></li>
<li><p><a class="reference internal" href="#distributing-the-tuples" id="id25">6.2 Distributing the tuples</a></p></li>
<li><p><a class="reference internal" href="#node-information" id="id26">6.3 Node information</a></p></li>
<li><p><a class="reference internal" href="#naive-list" id="id27">6.4 Naive list</a></p></li>
<li><p><a class="reference internal" href="#group-and-sort-list" id="id28">6.5 Group and sort list</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id29">6.5.1 Utils</a></p></li>
<li><p><a class="reference internal" href="#distribution" id="id30">6.5.2 Distribution</a></p></li>
<li><p><a class="reference internal" href="#main" id="id31">6.5.3 Main</a></p></li>
<li><p><a class="reference internal" href="#interface" id="id32">6.5.4 Interface</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#unions" id="id33">7 Unions</a></p></li>
<li><p><a class="reference internal" href="#equations" id="id34">8 Equations</a></p></li>
<li><p><a class="reference internal" href="#blas" id="id35">9 Blas</a></p></li>
<li><p><a class="reference internal" href="#atrip" id="id36">10 Atrip</a></p>
<ul>
<li><p><a class="reference internal" href="#header" id="id37">10.1 Header</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id38">10.2 Main</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#debug-and-logging" id="id39">11 Debug and Logging</a></p>
<ul>
<li><p><a class="reference internal" href="#macros" id="id40">11.1 Macros</a></p></li>
<li><p><a class="reference internal" href="#iteration-informer" id="id41">11.2 Iteration informer</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#include-header" id="id42">12 Include header</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id5">1 Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The algorithm uses two main data types, the <code class="docutils literal notranslate"><span class="pre">Slice</span></code> and the
<code class="docutils literal notranslate"><span class="pre">SliceUnion</span></code> as a container and resource manager of the <code class="docutils literal notranslate"><span class="pre">Slice</span></code>.</p>
</section>
<section id="the-slice">
<h2><a class="toc-backref" href="#id6">2 The slice</a><a class="headerlink" href="#the-slice" title="Permalink to this headline">¶</a></h2>
<p>The following section introduces the idea of a slice.</p>
<section id="id1">
<h3><a class="toc-backref" href="#id7">2.1 Introduction</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>A slice is the concept of a subset of values of a given tensor.
As an example, for the doubles amplitudes <span class="math notranslate nohighlight">\(T^{ab}_{ij}\)</span>, one need two kinds of objects:</p>
<ul class="simple">
<li><p>the object <span class="math notranslate nohighlight">\(\mathsf{T}(a)^b_{ij}\)</span> which for every <span class="math notranslate nohighlight">\(a\)</span> gets assigned the
tensor <span class="math notranslate nohighlight">\(T^{ab}_{ij}\)</span> of size <span class="math notranslate nohighlight">\(N_\mathrm{o}^2 \times N_\mathrm{v}\)</span></p></li>
<li><p>the object <span class="math notranslate nohighlight">\(\mathsf{T}(a,b)_{ij}\)</span> which for every pair of <span class="math notranslate nohighlight">\(a, b\)</span>
corresponds the <span class="math notranslate nohighlight">\(N_\mathrm{o}^2\)</span>-sized tensor <span class="math notranslate nohighlight">\(T^{ab}_{ij}\)</span>.</p></li>
</ul>
</section>
<section id="location">
<h3><a class="toc-backref" href="#id8">2.2 Location</a><a class="headerlink" href="#location" title="Permalink to this headline">¶</a></h3>
<p>Every slice set, for instance,</p>
<div class="math notranslate nohighlight">
\[S_k = \left\{
    a \mapsto \mathsf{T}(a)^{b}_{ij}
    \mid
    a \in A_k
    \right\}\]</div>
<p>where <span class="math notranslate nohighlight">\(A_k\)</span> is some subset of
<span class="math notranslate nohighlight">\(\mathsf{N}_\mathrm{v}\)</span>,
gets stored in some rank <span class="math notranslate nohighlight">\(k\)</span>.
In general however, the number of elements in <span class="math notranslate nohighlight">\(A_k\)</span> can be bigger
than the number of processes <span class="math notranslate nohighlight">\(n_p\)</span>. Therefore in order to uniquely
indentify a given slice in <span class="math notranslate nohighlight">\(S_k\)</span> we need two identifiers,
the rank <span class="math notranslate nohighlight">\(k\)</span>, which tells us in which core’s memory the slice is
allocated, and an additional tag which we will call <code class="docutils literal notranslate"><span class="pre">source</span></code>.</p>
<p>The datatype that simply models this state of affairs
is therefore a simple structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Location</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rank</span><span class="p">;</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">source</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="type">
<h3><a class="toc-backref" href="#id9">2.3 Type</a><a class="headerlink" href="#type" title="Permalink to this headline">¶</a></h3>
<p>Due to the permutation operators in the equations
it is noticeable that for every one dimensional
slice and triple <span class="math notranslate nohighlight">\((a,b,c)\)</span></p>
<div class="math notranslate nohighlight">
\[a \mapsto \mathsf{t}(a)\]</div>
<p>one needs at the same time
<span class="math notranslate nohighlight">\(\mathsf{t}(a)\)</span>,
<span class="math notranslate nohighlight">\(\mathsf{t}(b)\)</span> and
<span class="math notranslate nohighlight">\(\mathsf{t}(c)\)</span>.
For two dimensional slices, i.e., slices of the form</p>
<div class="math notranslate nohighlight">
\[(a,b) \mapsto \mathsf{t}(a,b)\]</div>
<p>one needs in the equations the slices
<span class="math notranslate nohighlight">\(\mathsf{t}(a,b)\)</span>,
<span class="math notranslate nohighlight">\(\mathsf{t}(b,c)\)</span> and
<span class="math notranslate nohighlight">\(\mathsf{t}(a,c)\)</span>.
In addition, in the case of diagrams where
the integral <span class="math notranslate nohighlight">\(V^{ab}_{ci}\)</span> appears,
we additionaly need the permuted slices
from before, i.e.
<span class="math notranslate nohighlight">\(\mathsf{t}(b,a)\)</span>,
<span class="math notranslate nohighlight">\(\mathsf{t}(c,b)\)</span> and
<span class="math notranslate nohighlight">\(\mathsf{t}(c,a)\)</span>.</p>
<p>This means, every slice has associated with it
a type which denotes which permutation it is.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">Type</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Two-parameter slices</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">AB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">BC</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">AC</span><span class="w"></span>
<span class="w">  </span><span class="c1">// for abci and the doubles</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">CB</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">BA</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">CA</span><span class="w"></span>
<span class="w">  </span><span class="c1">// The non-typed slice</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">Blank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">404</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="state">
<h3><a class="toc-backref" href="#id10">2.4 State</a><a class="headerlink" href="#state" title="Permalink to this headline">¶</a></h3>
<p>Every slice can be in different states and every state
denotes which function the slice is going to provide
and which relations they have between themselves.</p>
<dl class="simple">
<dt>Fetch</dt><dd><p>A slice is in state <code class="docutils literal notranslate"><span class="pre">Fetch</span></code> when it
has a valid data pointer that <strong>**must**</strong> be written to.
A <code class="docutils literal notranslate"><span class="pre">Fetch</span></code> slice should not live very long, this means
that after the database send and receive phase,
<code class="docutils literal notranslate"><span class="pre">Fetch</span></code> slices should be changed into <code class="docutils literal notranslate"><span class="pre">Dispatched</span></code>
in order to start the process of writing to the
data pointer from some other rank.</p>
</dd>
<dt>Dispatched</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">Dispatched</span></code> slice indicates that at some point
send and receive MPI calls have been dispatched
in order to get the data.
However, the calls have just been dispatched and there
is no warranty for the data to be there, for that,
the slice must be unwrapped.</p>
</dd>
<dt>Ready</dt><dd><p><code class="docutils literal notranslate"><span class="pre">Ready</span></code> means that the data pointer can be read from
directly.</p>
</dd>
<dt>SelfSufficient</dt><dd><p>A slice is <code class="docutils literal notranslate"><span class="pre">SelfSufficient</span></code> when its contents are located
in the same rank that it lives, so that it does not have to
fetch from no other rank.
This is important in order to handle the data pointers correctly
and in order to save calls to MPI receive and send functions.</p>
</dd>
<dt>Recycled</dt><dd><p><code class="docutils literal notranslate"><span class="pre">Recycled</span></code> means that this slice gets its data pointer from another
slice, so it should not be written to</p>
</dd>
<dt>Acceptor</dt><dd><p><code class="docutils literal notranslate"><span class="pre">Acceptor</span></code> means that the slice can accept a new slice, it is
the counterpart of the <code class="docutils literal notranslate"><span class="pre">Blank</span></code> type, but for states</p>
</dd>
</dl>
<p>Again the implementation is a simple enum type.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Dispatched</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">SelfSufficient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">911</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Recycled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Acceptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">405</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="the-info-structure">
<h3><a class="toc-backref" href="#id11">2.5 The Info structure</a><a class="headerlink" href="#the-info-structure" title="Permalink to this headline">¶</a></h3>
<p>Every slice has an information structure associated with it
that keeps track of the <strong>**variable**</strong> type, state and so on.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Info</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// which part of a,b,c the slice holds</span>
<span class="w">  </span><span class="n">PartialTuple</span><span class="w"> </span><span class="n">tuple</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// The type of slice for the user to retrieve the correct one</span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// What is the state of the slice</span>
<span class="w">  </span><span class="n">State</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Where the slice is to be retrieved</span>
<span class="w">  </span><span class="n">Location</span><span class="w"> </span><span class="n">from</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If the data are actually to be found in this other slice</span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="n">recycling</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">Info</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">tuple</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">{</span><span class="n">Blank</span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">{</span><span class="n">Acceptor</span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="n">recycling</span><span class="p">{</span><span class="n">Blank</span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">using</span><span class="w"> </span><span class="n">Ty_x_Tu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="w"> </span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="n">PartialTuple</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="name">
<h3><a class="toc-backref" href="#id12">2.6 Name</a><a class="headerlink" href="#name" title="Permalink to this headline">¶</a></h3>
<p>CCSD(T) needs in this algorithm 5 types of tensor slices,
namely
<span class="math notranslate nohighlight">\(V^{ij}_{ka}\)</span>, <span class="math notranslate nohighlight">\(V^{ab}_{ci}\)</span>,
<span class="math notranslate nohighlight">\(V^{ab}_{ij}\)</span>
and two times <span class="math notranslate nohighlight">\(T^{ab}_{ij}\)</span>.
The reason why we need two times the doubles
amplitudes is because in the doubles contribution
to the energy, the <span class="math notranslate nohighlight">\(T\)</span> amplidutes will be sliced
through one parameter for the particle contribution
and through two parameters for the hole contribution.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">Name</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">TA</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">VIJKA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">101</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">VABCI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">TABIJ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">201</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">VABIJ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">202</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="database">
<h3><a class="toc-backref" href="#id13">2.7 Database</a><a class="headerlink" href="#database" title="Permalink to this headline">¶</a></h3>
<p>The database is a simple representation of the slices of a slice union.
Every element of the database is given by the name of the tensor it
represents and the internal information structure.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">LocalDatabaseElement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Name</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Info</span><span class="w"> </span><span class="n">info</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>A local database (of a given rank) and the global database is thus simply
a vector of these elements.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">LocalDatabase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalDatabaseElement</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Database</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LocalDatabase</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mpi-types">
<h3><a class="toc-backref" href="#id14">2.8 MPI Types</a><a class="headerlink" href="#mpi-types" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">mpi</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="nf">vector</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">DT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Type_vector</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Type_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="nf">sliceLocation</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// create a sliceLocation to measure in the current architecture</span>
<span class="w">    </span><span class="c1">// the packing of the struct</span>
<span class="w">    </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Location</span><span class="w"> </span><span class="n">measure</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lengths</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">types</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">usizeDt</span><span class="p">(),</span><span class="w"> </span><span class="n">usizeDt</span><span class="p">()};</span><span class="w"></span>

<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Location</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span><span class="w"></span>
<span class="w">                  </span><span class="s">&quot;The Location packing is wrong in your compiler&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// measure the displacements in the struct</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Aint</span><span class="w"> </span><span class="n">base_address</span><span class="p">,</span><span class="w"> </span><span class="n">displacements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">,</span><span class="w">        </span><span class="o">&amp;</span><span class="n">base_address</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">rank</span><span class="p">,</span><span class="w">   </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">displacements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_Aint_diff</span><span class="p">(</span><span class="n">displacements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">base_address</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">MPI_Type_create_struct</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">lengths</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">displacements</span><span class="p">,</span><span class="w"> </span><span class="n">types</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Type_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="nf">usizeDt</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">MPI_UINT64_T</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="nf">sliceInfo</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Info</span><span class="w"> </span><span class="n">measure</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lengths</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">types</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">usizeDt</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">Type</span><span class="p">),</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">State</span><span class="p">),</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">sliceLocation</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">Type</span><span class="p">),</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TODO: Why this does not work on intel mpi?</span>
<span class="w">        </span><span class="cm">/*, MPI_UINT64_T*/</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">Type</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Enum type not 4 bytes long&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">State</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Enum State not 4 bytes long&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">Name</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Enum Name not 4 bytes long&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// create the displacements from the info measurement struct</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Aint</span><span class="w"> </span><span class="n">base_address</span><span class="p">,</span><span class="w"> </span><span class="n">displacements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">,</span><span class="w">             </span><span class="o">&amp;</span><span class="n">base_address</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">    </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">type</span><span class="p">,</span><span class="w">        </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">state</span><span class="p">,</span><span class="w">       </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">from</span><span class="p">,</span><span class="w">        </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">recycling</span><span class="p">,</span><span class="w">   </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">displacements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_Aint_diff</span><span class="p">(</span><span class="n">displacements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">base_address</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">MPI_Type_create_struct</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">lengths</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">displacements</span><span class="p">,</span><span class="w"> </span><span class="n">types</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Type_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="nf">localDatabaseElement</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">LocalDatabaseElement</span><span class="w"> </span><span class="n">measure</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lengths</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">types</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="nc">Name</span><span class="p">),</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">sliceInfo</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// measure the displacements in the struct</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Aint</span><span class="w"> </span><span class="n">base_address</span><span class="p">,</span><span class="w"> </span><span class="n">displacements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">,</span><span class="w">      </span><span class="o">&amp;</span><span class="n">base_address</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Get_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">measure</span><span class="p">.</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">displacements</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">displacements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_Aint_diff</span><span class="p">(</span><span class="n">displacements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">base_address</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">LocalDatabaseElement</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">measure</span><span class="p">)</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Measure has bad size&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">MPI_Type_create_struct</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">lengths</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">displacements</span><span class="p">,</span><span class="w"> </span><span class="n">types</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Type_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vector</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LocalDatabaseElement</span><span class="p">),</span><span class="w"> </span><span class="n">MPI_CHAR</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// TODO: write tests in order to know if this works</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="static-utilities">
<h3><a class="toc-backref" href="#id15">2.9 Static utilities</a><a class="headerlink" href="#static-utilities" title="Permalink to this headline">¶</a></h3>
<p>This section presents some functions which are useful to work with
slices and are inside the namespace created by the slice struct.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">subtupleBySlice</span></code> gives to every <code class="docutils literal notranslate"><span class="pre">Slice::Type</span></code>
its meaning in terms of the triples <span class="math notranslate nohighlight">\((a,b,c)\)</span>.</p>
<p>Notice that since in general the relation
<span class="math notranslate nohighlight">\(a &lt; b &lt; c\)</span> holds (in our implementation), the case
of one-dimensional parametrizations <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> is well
defined.</p>
<p>The function should only throw if there is an implementation
error where the <code class="docutils literal notranslate"><span class="pre">Slice::Type</span></code> enum has been expanded and this
function has not been updated accordingly.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"></span>
<span class="n">PartialTuple</span><span class="w"> </span><span class="nf">subtupleBySlice</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">sliceType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">sliceType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">AB</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">BC</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">AC</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">CB</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">BA</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nl">CA</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w">  </span><span class="nl">A</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w">  </span><span class="nl">B</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w">  </span><span class="nl">C</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="s">&quot;Switch statement not exhaustive!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the context of cleaning up slices during the main loop,
it is important to check if a given slice has some slices
referencing to it in quality of recycled slices.</p>
<p>This function should therefore return a vector of pointers
of slices referencing to the given slice’s info, when
the length of the vector is zero, then there are no dangling
links.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">hasRecycledReferencingToIt</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slices</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">Info</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">info</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="n">slices</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w">  </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"></span>
<span class="w">       </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"></span>
<span class="w">       </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Recycled</span><span class="w"></span>
<span class="w">       </span><span class="p">)</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The rest of the coming functions are utilities in order to find in a vector
of slices a given slice by reference. Mostly they are merely convenience
wrappers to the standard library function <code class="docutils literal notranslate"><span class="pre">std::find_if</span></code>.</p>
<p>They are named as <code class="docutils literal notranslate"><span class="pre">find&lt;...&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;...&gt;</span></code> represents some condition
and must always return a reference to the found slice, i.e., <code class="docutils literal notranslate"><span class="pre">Slice&amp;</span></code>.
<code class="docutils literal notranslate"><span class="pre">Atrip</span></code> relies on these functions to find the sought for slices,
therefore these functions will throw a <code class="docutils literal notranslate"><span class="pre">std::domain_error</span></code> if the
given slice could not be found.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">findOneByType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slices</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sliceIt</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                     </span><span class="p">[</span><span class="o">&amp;</span><span class="n">type</span><span class="p">](</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                       </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">                     </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="n">WITH_CRAZY_DEBUG</span><span class="w"></span>
<span class="w">    </span><span class="n">WITH_RANK</span><span class="w"></span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">__ looking for &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sliceIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">&quot;Slice by type not found!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">sliceIt</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&amp;</span><span class="w"></span>
<span class="n">findRecycledSource</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slices</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Info</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sliceIt</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                   </span><span class="p">[</span><span class="o">&amp;</span><span class="n">info</span><span class="p">](</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                     </span><span class="k">return</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"></span>
<span class="w">                         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"></span>
<span class="w">                         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">State</span><span class="o">::</span><span class="n">Recycled</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"></span>
<span class="w">                         </span><span class="p">;</span><span class="w"></span>
<span class="w">                   </span><span class="p">});</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_CRAZY_DEBUG</span><span class="w"></span>
<span class="w">  </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__slice__:find: recycling source of &quot;</span><span class="w"></span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sliceIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Slice not found: &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                           </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; rank: &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">)</span><span class="w"></span>
<span class="w">                           </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__slice__:find: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">sliceIt</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">sliceIt</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">findByTypeAbc</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slices</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">subtupleBySlice</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sliceIt</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                     </span><span class="p">[</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tuple</span><span class="p">](</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                       </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"></span>
<span class="w">                           </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"></span>
<span class="w">                           </span><span class="p">;</span><span class="w"></span>
<span class="w">                     </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="n">WITH_CRAZY_DEBUG</span><span class="w"></span>
<span class="w">    </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__slice__:find:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and tuple &quot;</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">tuple</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sliceIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Slice not found: &quot;</span><span class="w"></span>
<span class="w">                             </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">tuple</span><span class="p">)</span><span class="w"></span>
<span class="w">                             </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"></span>
<span class="w">                             </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">type</span><span class="p">)</span><span class="w"></span>
<span class="w">                             </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; rank: &quot;</span><span class="w"></span>
<span class="w">                             </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">)</span><span class="w"></span>
<span class="w">                             </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">sliceIt</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">findByInfo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slices</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Info</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sliceIt</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                   </span><span class="p">[</span><span class="o">&amp;</span><span class="n">info</span><span class="p">](</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                     </span><span class="c1">// TODO: maybe implement comparison in Info struct</span>
<span class="w">                     </span><span class="k">return</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"></span>
<span class="w">                         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"></span>
<span class="w">                         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"></span>
<span class="w">                         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w"></span>
<span class="w">                         </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="w"></span>
<span class="w">                          </span><span class="p">;</span><span class="w"></span>
<span class="w">                   </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="n">WITH_CRAZY_DEBUG</span><span class="w"></span>
<span class="w">  </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__slice__:find:looking for &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sliceIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Slice by info not found: &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">info</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">sliceIt</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="attributes">
<h3><a class="toc-backref" href="#id16">2.10 Attributes</a><a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>A slice object does not own data, it is just a container
or a pointer to data together with additional bookkeeping facilities.</p>
<p>It includes an info structure with the information about the slice,
<code class="docutils literal notranslate"><span class="pre">Type</span></code>, <code class="docutils literal notranslate"><span class="pre">State</span></code> etc, which will be later communicated to other ranks.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="w"> </span><span class="n">info</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>A pointer to data is also necessary for the <code class="docutils literal notranslate"><span class="pre">Slice</span></code> but not necessary
to be communicated to other ranks. The <code class="docutils literal notranslate"><span class="pre">Slice</span></code> should never allocate
or deallocate itself the pointer.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="w">  </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>An <code class="docutils literal notranslate"><span class="pre">MPI_Request</span></code> handle is also included so that the slices that are
to receive data through MPI can know which request they belong to.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MPI_Request</span><span class="w"> </span><span class="n">request</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>For practical purposes in MPI calls, the number of elements in <code class="docutils literal notranslate"><span class="pre">data</span></code> is also included.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="member-functions">
<h3><a class="toc-backref" href="#id17">2.11 Member functions</a><a class="headerlink" href="#member-functions" title="Permalink to this headline">¶</a></h3>
<p>It is important to note that a ready slice should not be recycled from
any other slice, so that it can have access by itself to the data.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">markReady</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Blank</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following function asks wether or not
the slice has effectively been unwrapped or not,
i.e., wether or not the data are accessible and already
there. This can only happen in two ways, either
is the slice <code class="docutils literal notranslate"><span class="pre">Ready</span></code> or it is <code class="docutils literal notranslate"><span class="pre">SelfSufficient</span></code>,
i.e., the data pointed to was pre-distributed to the current node.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">isUnwrapped</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ready</span><span class="w"></span>
<span class="w">      </span><span class="o">||</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SelfSufficient</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">isUnwrappable</span></code> answers which slices can be unwrapped
potentially. Unwrapped slices can be unwrapped again idempotentially.
Also <code class="docutils literal notranslate"><span class="pre">Recycled</span></code> slices can be unwrapped, i.e. the slices pointed to by them
will be unwrapped.
The only other possibility is that the slice has been dispatched
in the past and can be unwrapped. The case where the state
is <code class="docutils literal notranslate"><span class="pre">Dispatched</span></code> is the canonical intuitive case where a real process
of unwrapping, i.e. waiting for the data to get through the network,
is done.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">isUnwrappable</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">isUnwrapped</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="o">||</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Recycled</span><span class="w"></span>
<span class="w">      </span><span class="o">||</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Dispatched</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isDirectlyFetchable</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ready</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Dispatched</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">free</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">Blank</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">Acceptor</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">Blank</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">data</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isFree</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w">       </span><span class="o">==</span><span class="w"> </span><span class="n">PartialTuple</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w">        </span><span class="o">==</span><span class="w"> </span><span class="n">Blank</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w">       </span><span class="o">==</span><span class="w"> </span><span class="n">Acceptor</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w">   </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="w">   </span><span class="o">==</span><span class="w"> </span><span class="n">Blank</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">data</span><span class="w">             </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">       </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">isRecylable</span></code> answers the question, which slices can be recycled.</p>
<p>A slice can only be recycled if it is Fetch or Ready and has
a valid datapointer.</p>
<p>In particular, SelfSufficient are not recyclable, since it is easier
just to create a SelfSufficient slice than deal with data dependencies.</p>
<p>Furthermore, a recycled slice is not recyclable, if this is the case
then it is either bad design or a bug.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isRecyclable</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Dispatched</span><span class="w"></span>
<span class="w">         </span><span class="o">||</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ready</span><span class="w"></span>
<span class="w">         </span><span class="o">||</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Fetch</span><span class="w"></span>
<span class="w">         </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">hasValidDataPointer</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">hasValidDataPointer</span></code> describes if a slice has a valid
data pointer.</p>
<p>This is important to know if the slice has some data to it, also
some structural checks are done, so that it should not be <code class="docutils literal notranslate"><span class="pre">Acceptor</span></code>
or <code class="docutils literal notranslate"><span class="pre">Blank</span></code>, if this is the case then it is a bug.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">hasValidDataPointer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w">       </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Acceptor</span><span class="w"></span>
<span class="w">      </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w">  </span><span class="o">!=</span><span class="w"> </span><span class="n">Blank</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The function
<code class="docutils literal notranslate"><span class="pre">unwrapAndMarkReady</span></code>
calls the low-level MPI functions
in order to wait whenever the state of the slice is correct.
The main behaviour of the function should</p>
<ul class="simple">
<li><p>return if state is <code class="docutils literal notranslate"><span class="pre">Ready</span></code>, since then there is nothing to be done.</p></li>
<li><p>throw if the state is not <code class="docutils literal notranslate"><span class="pre">Dispatched</span></code>, only a dispatched slice
can be unwrapped through MPI.</p></li>
<li><p>throw if an MPI error happens.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unwrapAndMarkReady</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ready</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Dispatched</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">&quot;Can&#39;t unwrap a non-ready, non-dispatched slice!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">markReady</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">MPI_Status</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__slice__:mpi: waiting &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">errorCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_Wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">status</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errorCode</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MPI_SUCCESS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="s">&quot;MPI ERROR HAPPENED....&quot;</span><span class="p">;</span><span class="w"></span>

<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="n">errorString</span><span class="p">[</span><span class="n">MPI_MAX_ERROR_STRING</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">errorSize</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">MPI_Error_string</span><span class="p">(</span><span class="n">errorCode</span><span class="p">,</span><span class="w"> </span><span class="n">errorString</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">errorSize</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__slice__:mpi: status &quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;{ .source=&quot;</span><span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">MPI_SOURCE</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, .tag=&quot;</span><span class="w">       </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">MPI_TAG</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, .error=&quot;</span><span class="w">     </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">MPI_ERROR</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, .errCode=&quot;</span><span class="w">   </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">errorCode</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, .err=&quot;</span><span class="w">       </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">errorString</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; }&quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="utils">
<h2><a class="toc-backref" href="#id18">3 Utils</a><a class="headerlink" href="#utils" title="Permalink to this headline">¶</a></h2>
<p>This section presents some utilities</p>
<section id="pretty-printing">
<h3><a class="toc-backref" href="#id19">3.1 Pretty printing</a><a class="headerlink" href="#pretty-printing" title="Permalink to this headline">¶</a></h3>
<p>The pretty printing uses the <a class="reference external" href="https://github.com/sharkdp/dbg-macro">dbg-macro</a> package.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="cp">#if ATRIP_DEBUG &gt; 2</span>
<span class="w">    </span><span class="n">dbg</span><span class="o">::</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="chrono">
<h3><a class="toc-backref" href="#id20">3.2 Chrono</a><a class="headerlink" href="#chrono" title="Permalink to this headline">¶</a></h3>
<p>The chrono is just a simple wrapper for a high resolution clock
that can be found in the <code class="docutils literal notranslate"><span class="pre">std::chrono</span></code> namespace of the standard library.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define WITH_CHRONO(__chrono_name, ...)         \</span>
<span class="cp">  Atrip::chrono[__chrono_name].start();         \</span>
<span class="cp">  __VA_ARGS__                                   \</span>
<span class="cp">  Atrip::chrono[__chrono_name].stop();</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Timer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">duration</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Event</span><span class="w"> </span><span class="n">_start</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">start</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">stop</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">duration</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">_start</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">clear</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">duration</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">count</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">Timings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Timer</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="the-rank-mapping">
<h2><a class="toc-backref" href="#id21">4 The rank mapping</a><a class="headerlink" href="#the-rank-mapping" title="Permalink to this headline">¶</a></h2>
<p>This section introduces the concept of rank mapping,
which defines how slices will be allocated to every
rank.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Slice.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Tuples.hpp&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">RankMap</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RANK_ROUND_ROBIN</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">lengths</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ClusterInfo</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">RankMap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lens</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np_</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">comm</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">lengths</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="p">(</span><span class="n">np_</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">lengths</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">lengths</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                            </span><span class="mi">1UL</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">()))</span><span class="w"></span>
<span class="w">      </span><span class="p">,</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">(</span><span class="n">getClusterInfo</span><span class="p">(</span><span class="n">comm</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="n">lengths</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Location</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">RANK_ROUND_ROBIN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">source</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"></span>
<span class="w">          </span><span class="n">rankPosition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">source</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">ranksPerNode</span><span class="w"></span>
<span class="w">                       </span><span class="o">+</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">rankInfos</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">].</span><span class="n">localRank</span><span class="w"></span>
<span class="w">                       </span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">rankPosition</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">nNodes</span><span class="w"></span>
<span class="w">             </span><span class="o">+</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">rankInfos</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">].</span><span class="n">nodeId</span><span class="w"></span>
<span class="w">             </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nSources</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">size_t</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>


<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPaddingRank</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">          </span><span class="o">?</span><span class="w"> </span><span class="nb">false</span><span class="w"></span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isSourcePadding</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nSources</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">isPaddingRank</span><span class="p">(</span><span class="n">rank</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Location</span><span class="w"></span>
<span class="w">    </span><span class="n">find</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Type</span><span class="w"> </span><span class="n">sliceType</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// tuple = {11, 8} when abc = {11, 8, 9} and sliceType = AB</span>
<span class="w">      </span><span class="c1">// tuple = {11, 0} when abc = {11, 8, 9} and sliceType = A</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">subtupleBySlice</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">sliceType</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"></span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">lengths</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">RANK_ROUND_ROBIN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"></span>

<span class="w">          </span><span class="c1">// the node that will be assigned to</span>
<span class="w">            </span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">nNodes</span><span class="w"></span>

<span class="w">          </span><span class="c1">// how many times it has been assigned to the node</span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="n">s_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">nNodes</span><span class="w"></span>

<span class="w">          </span><span class="c1">// which local rank in the node should be</span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="n">localRank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">ranksPerNode</span><span class="w"></span>

<span class="w">          </span><span class="c1">// and the local source (how many times we chose this local rank)</span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="n">localSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">ranksPerNode</span><span class="w"></span>
<span class="w">          </span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// find the localRank-th entry in clusterInfo</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">rankInfos</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">                       </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">rankInfos</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                       </span><span class="p">[</span><span class="n">nodeId</span><span class="p">,</span><span class="w"> </span><span class="n">localRank</span><span class="p">](</span><span class="n">RankInfo</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ri</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                         </span><span class="k">return</span><span class="w"> </span><span class="n">ri</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nodeId</span><span class="w"></span>
<span class="w">                             </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ri</span><span class="p">.</span><span class="n">localRank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">localRank</span><span class="w"></span>
<span class="w">                             </span><span class="p">;</span><span class="w"></span>
<span class="w">                       </span><span class="p">});</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">clusterInfo</span><span class="p">.</span><span class="n">rankInfos</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="s">&quot;FATAL! Error in node distribution of the slices&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">globalRank</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">localSource</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">rank</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="the-slice-union">
<h2><a class="toc-backref" href="#id22">5 The slice union</a><a class="headerlink" href="#the-slice-union" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Debug.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Slice.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/RankMap.hpp&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">SliceUnion</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="w">    </span><span class="nf">sliceIntoBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">iteration</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">from</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * This function should enforce an important property of a SliceUnion.</span>
<span class="cm">     * Namely, there can be no two Slices of the same nature.</span>
<span class="cm">     *</span>
<span class="cm">     * This means that there can be at most one slice with a given Ty_x_Tu.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">checkForDuplicates</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Ty_x_Tu</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tytus</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="n">slices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">isFree</span><span class="p">())</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">tytus</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="p">});</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tytu</span><span class="o">:</span><span class="w"> </span><span class="n">tytus</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="n">tytus</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tytus</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">tytu</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="s">&quot;Invariance violated, more than one slice with same Ty_x_Tu&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Ty_x_Tu</span><span class="o">&gt;</span><span class="w"> </span><span class="n">neededSlices</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Ty_x_Tu</span><span class="o">&gt;</span><span class="w"> </span><span class="n">needed</span><span class="p">(</span><span class="n">sliceTypes</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="c1">// build the needed vector</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">sliceTypes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">sliceTypes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                     </span><span class="n">needed</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">                     </span><span class="p">[</span><span class="o">&amp;</span><span class="n">abc</span><span class="p">](</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Type</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                       </span><span class="k">auto</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">subtupleBySlice</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w"></span>
<span class="w">                       </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">tuple</span><span class="p">);</span><span class="w"></span>
<span class="w">                     </span><span class="p">});</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">needed</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* buildLocalDatabase</span>
<span class="cm">     *</span>
<span class="cm">     * It should build a database of slices so that we know what is needed</span>
<span class="cm">     * to fetch in the next iteration represented by the tuple &#39;abc&#39;.</span>
<span class="cm">     *</span>
<span class="cm">     * 1. The algorithm works as follows, we build a database of the all</span>
<span class="cm">     * the slice types that we need together with their tuple.</span>
<span class="cm">     *</span>
<span class="cm">     * 2. Look in the SliceUnion if we already have this tuple,</span>
<span class="cm">     * if we already have it mark it (TODO)</span>
<span class="cm">     *</span>
<span class="cm">     * 3. If we don&#39;t have the tuple, look for a (state=acceptor, type=blank)</span>
<span class="cm">     * slice and mark this slice as type=Fetch with the corresponding type</span>
<span class="cm">     * and tuple.</span>
<span class="cm">     *</span>
<span class="cm">     * NOTE: The algorithm should certify that we always have enough blank</span>
<span class="cm">     * slices.</span>
<span class="cm">     *</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"></span>
<span class="w">    </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">LocalDatabase</span><span class="w"> </span><span class="n">buildLocalDatabase</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">LocalDatabase</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">needed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neededSlices</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__:needed:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">needed</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// BUILD THE DATABASE</span>
<span class="w">      </span><span class="c1">// we need to loop over all sliceTypes that this TensorUnion</span>
<span class="w">      </span><span class="c1">// is representing and find out how we will get the corresponding</span>
<span class="w">      </span><span class="c1">// slice for the abc we are considering right now.</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pair</span><span class="o">:</span><span class="w"> </span><span class="n">needed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">from</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">rankMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w"></span>

<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__:want:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="n">slices</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__:guts:ocd &quot;</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; pt &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__: checking if exact match&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// FIRST: look up if there is already a *Ready* slice matching what we</span>
<span class="w">          </span><span class="c1">// need</span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">it</span><span class="w"></span>
<span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                           </span><span class="p">[</span><span class="o">&amp;</span><span class="n">tuple</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">](</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                             </span><span class="k">return</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tuple</span><span class="w"></span>
<span class="w">                                 </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">                                    </span><span class="c1">// we only want another slice when it</span>
<span class="w">                                    </span><span class="c1">// has already ready-to-use data</span>
<span class="w">                                 </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">isUnwrappable</span><span class="p">()</span><span class="w"></span>
<span class="w">                                 </span><span class="p">;</span><span class="w"></span>
<span class="w">                           </span><span class="p">});</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// if we find this slice, it means that we don&#39;t have to do anything</span>
<span class="w">            </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__: EXACT: found EXACT in name=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"></span>
<span class="w">                      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; for tuple &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">                      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ptr &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"></span>
<span class="w">                      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">});</span><span class="w"></span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__: checking if recycle&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="c1">// Try to find a recyling possibility ie. find a slice with the same</span>
<span class="w">        </span><span class="c1">// tuple and that has a valid data pointer.</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">recycleIt</span><span class="w"></span>
<span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                         </span><span class="p">[</span><span class="o">&amp;</span><span class="n">tuple</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">](</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                           </span><span class="k">return</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tuple</span><span class="w"></span>
<span class="w">                               </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">                               </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">isRecyclable</span><span class="p">()</span><span class="w"></span>
<span class="w">                               </span><span class="p">;</span><span class="w"></span>
<span class="w">                         </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="c1">// if we find this recylce, then we find a Blank slice</span>
<span class="w">        </span><span class="c1">// (which should exist by construction :THINK)</span>
<span class="w">        </span><span class="c1">//</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">recycleIt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">blank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">findOneByType</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Blank</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="c1">// TODO: formalize this through a method to copy information</span>
<span class="w">          </span><span class="c1">//       from another slice</span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recycleIt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Recycled</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recycleIt</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">});</span><span class="w"></span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__: RECYCLING: n&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; get &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; from &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">recycleIt</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ptr &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">recycleIt</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                    </span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// in this case we have to create a new slice</span>
<span class="w">        </span><span class="c1">// this means that we should have a blank slice at our disposal</span>
<span class="w">        </span><span class="c1">// and also the freePointers should have some elements inside,</span>
<span class="w">        </span><span class="c1">// so we pop a data pointer from the freePointers container</span>
<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__: none work, doing new&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__: NEW: finding blank in &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; for type &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; for tuple &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                    </span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">blank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">findOneByType</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Blank</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Handle self sufficiency</span>
<span class="w">          </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w"></span>
<span class="w">                           </span><span class="o">?</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">SelfSufficient</span><span class="w"></span>
<span class="w">                           </span><span class="o">:</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Fetch</span><span class="w"></span>
<span class="w">                           </span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">SelfSufficient</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">blank</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sources</span><span class="p">[</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="p">].</span><span class="n">data</span><span class="p">();</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">freePointers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="n">stream</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;No more free pointers &quot;</span><span class="w"></span>
<span class="w">                     </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;for type &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">                     </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and name &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"></span>
<span class="w">                      </span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">str</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">dataPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">freePointers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">freePointers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">dataPointer</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">blank</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">dataPointer</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">blank</span><span class="p">.</span><span class="n">info</span><span class="p">});</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="n">slices</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__db__:guts:ocd:__end__ &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">info</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>


<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Garbage collect slices not needed for the next iteration.</span>
<span class="cm">     *</span>
<span class="cm">     * It will throw if it tries to gc a slice that has not been</span>
<span class="cm">     * previously unwrapped, as a safety mechanism.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">clearUnusedSlicesForNext</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">needed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">neededSlices</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// CLEAN UP SLICES, FREE THE ONES THAT ARE NOT NEEDED ANYMORE</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">slice</span><span class="o">:</span><span class="w"> </span><span class="n">slices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// if the slice is free, then it was not used anyways</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">isFree</span><span class="p">())</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>


<span class="w">        </span><span class="c1">// try to find the slice in the needed slices list</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">found</span><span class="w"></span>
<span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">needed</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">needed</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                         </span><span class="p">[</span><span class="o">&amp;</span><span class="n">slice</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Ty_x_Tu</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tytu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                           </span><span class="k">return</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tytu</span><span class="p">.</span><span class="n">second</span><span class="w"></span>
<span class="w">                               </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tytu</span><span class="p">.</span><span class="n">first</span><span class="w"></span>
<span class="w">                               </span><span class="p">;</span><span class="w"></span>
<span class="w">                         </span><span class="p">});</span><span class="w"></span>

<span class="w">        </span><span class="c1">// if we did not find slice in needed, then erase it</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">needed</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">          </span><span class="c1">// We have to be careful about the data pointer,</span>
<span class="w">          </span><span class="c1">// for SelfSufficient, the data pointer is a source pointer</span>
<span class="w">          </span><span class="c1">// of the slice, so we should just wipe it.</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// For Ready slices, we have to be careful if there are some</span>
<span class="w">          </span><span class="c1">// recycled slices depending on it.</span>
<span class="w">          </span><span class="kt">bool</span><span class="w"> </span><span class="n">freeSlicePointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// allow to gc unwrapped and recycled, never Fetch,</span>
<span class="w">          </span><span class="c1">// if we have a Fetch slice then something has gone very wrong.</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">slice</span><span class="p">.</span><span class="n">isUnwrapped</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Recycled</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">throw</span><span class="w"></span>
<span class="w">              </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">&quot;Trying to garbage collect &quot;</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot; a non-unwrapped slice! &quot;</span><span class="w"></span>
<span class="w">                                </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slice</span><span class="p">)</span><span class="w"></span>
<span class="w">                                </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">));</span><span class="w"></span>

<span class="w">          </span><span class="c1">// it can be that our slice is ready, but it has some hanging</span>
<span class="w">          </span><span class="c1">// references lying around in the form of a recycled slice.</span>
<span class="w">          </span><span class="c1">// Of course if we need the recycled slice the next iteration</span>
<span class="w">          </span><span class="c1">// this would be fatal, because we would then free the pointer</span>
<span class="w">          </span><span class="c1">// of the slice and at some point in the future we would</span>
<span class="w">          </span><span class="c1">// overwrite it. Therefore, we must check if slice has some</span>
<span class="w">          </span><span class="c1">// references in slices and if so then</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//  - we should mark those references as the original (since the data</span>
<span class="w">          </span><span class="c1">//    pointer should be the same)</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//  - we should make sure that the data pointer of slice</span>
<span class="w">          </span><span class="c1">//    does not get freed.</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">WITH_OCD</span><span class="w"> </span><span class="n">WITH_RANK</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__gc__:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;checking for data recycled dependencies</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">recycled</span><span class="w"></span>
<span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">hasRecycledReferencingToIt</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">recycled</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">newReady</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recycled</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">              </span><span class="n">WITH_OCD</span><span class="w"> </span><span class="n">WITH_RANK</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__gc__:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;swaping recycled &quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">newReady</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="n">newReady</span><span class="o">-&gt;</span><span class="n">markReady</span><span class="p">();</span><span class="w"></span>
<span class="w">              </span><span class="n">assert</span><span class="p">(</span><span class="n">newReady</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="n">freeSlicePointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">recycled</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">auto</span><span class="w"> </span><span class="n">newRecyled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recycled</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="n">newRecyled</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newReady</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">WITH_OCD</span><span class="w"> </span><span class="n">WITH_RANK</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__gc__:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;updating recycled &quot;</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">newRecyled</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="c1">// if the slice is self sufficient, do not dare touching the</span>
<span class="w">          </span><span class="c1">// pointer, since it is a pointer to our sources in our rank.</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w">  </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">SelfSufficient</span><span class="w"></span>
<span class="w">             </span><span class="o">||</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Recycled</span><span class="w"></span>
<span class="w">             </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">freeSlicePointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="c1">// make sure we get its data pointer to be used later</span>
<span class="w">          </span><span class="c1">// only for non-recycled, since it can be that we need</span>
<span class="w">          </span><span class="c1">// for next iteration the data of the slice that the recycled points</span>
<span class="w">          </span><span class="c1">// to</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">freeSlicePointer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">freePointers</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;~~~:cl(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"></span>
<span class="w">                      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; added to freePointer &quot;</span><span class="w"></span>
<span class="w">                      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">freePointers</span><span class="p">)</span><span class="w"></span>
<span class="w">                      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">WITH_OCD</span><span class="w"> </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__gc__:not touching the free Pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>

<span class="w">          </span><span class="c1">// at this point, let us blank the slice</span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;~~~:cl(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; freeing up slice &quot;</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// TODO: make this possible because of Templates</span>
<span class="w">                    </span><span class="c1">// TODO: there is a deduction error here</span>
<span class="w">                    </span><span class="c1">// &lt;&lt; &quot; info &quot; &lt;&lt; slice.info</span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">slice</span><span class="p">.</span><span class="n">free</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// CONSTRUCTOR</span>
<span class="w">    </span><span class="n">SliceUnion</span><span class="p">(</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sliceTypes_</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sliceLength_</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">paramLength</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Name</span><span class="w"> </span><span class="n">name_</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nSliceBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="w">              </span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="o">:</span><span class="w"> </span><span class="n">rankMap</span><span class="p">(</span><span class="n">paramLength</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">global_world</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">world</span><span class="p">(</span><span class="n">child_world</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">(</span><span class="n">global_world</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">sliceLength</span><span class="p">(</span><span class="n">sliceLength_</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">sources</span><span class="p">(</span><span class="n">rankMap</span><span class="p">.</span><span class="n">nSources</span><span class="p">(),</span><span class="w"></span>
<span class="w">                        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">                          </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">sliceLength</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                           </span><span class="n">sliceLength</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                           </span><span class="mi">1UL</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">())))</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">(</span><span class="n">name_</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">sliceTypes</span><span class="p">(</span><span class="n">sliceTypes_</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">sliceBuffers</span><span class="p">(</span><span class="n">nSliceBuffers</span><span class="p">,</span><span class="w"> </span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"></span>
<span class="w">              </span><span class="c1">//, slices(2 * sliceTypes.size(), Slice&lt;F&gt;{ sources[0].size() })</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// constructor begin</span>

<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;INIT SliceUnion: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">slices</span><span class="w"></span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sliceTypes</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">      </span><span class="c1">// TODO: think exactly    ^------------------- about this number</span>

<span class="w">      </span><span class="c1">// initialize the freePointers with the pointers to the buffers</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">sliceBuffers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">sliceBuffers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                     </span><span class="n">std</span><span class="o">::</span><span class="n">inserter</span><span class="p">(</span><span class="n">freePointers</span><span class="p">,</span><span class="w"> </span><span class="n">freePointers</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span><span class="w"></span>
<span class="w">                     </span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">data</span><span class="p">();</span><span class="w"> </span><span class="p">});</span><span class="w"></span>



<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;rankMap.nSources &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rankMap</span><span class="p">.</span><span class="n">nSources</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#slices &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#slices[0] &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#sources &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sources</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#sources[0] &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#freePointers &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">freePointers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#sliceBuffers &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sliceBuffers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#sliceBuffers[0] &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sliceBuffers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#sliceLength &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sliceLength</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#paramLength &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">paramLength</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;GB*&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="n">sources</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sliceBuffers</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"></span>
<span class="w">                            </span><span class="o">*</span><span class="w"> </span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">                            </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">                            </span><span class="o">/</span><span class="w"> </span><span class="mf">1073741824.0</span><span class="w"></span>
<span class="w">                           </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// constructor ends</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sourceTensor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="n">CTF</span><span class="o">::</span><span class="n">World</span><span class="w"> </span><span class="nf">w</span><span class="p">(</span><span class="n">world</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sliceLength</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">syms</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="n">NS</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">__sliceLength</span><span class="p">(</span><span class="n">sliceLength</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">sliceLength</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">Tensor</span><span class="w"> </span><span class="nf">toSliceInto</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">__sliceLength</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                         </span><span class="n">syms</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                         </span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;slicing... </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// setUp sources</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">it</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rankMap</span><span class="p">.</span><span class="n">nSources</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"></span>
<span class="w">          </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rankMap</span><span class="p">.</span><span class="n">isSourcePadding</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_OCD</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Init:toSliceInto it-&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :: source &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">sliceIntoBuffer</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">toSliceInto</span><span class="p">,</span><span class="w"> </span><span class="n">sourceTensor</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * \brief Send asynchronously only if the state is Fetch</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">otherRank</span><span class="w"></span>
<span class="w">             </span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">LocalDatabaseElement</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">el</span><span class="w"></span>
<span class="w">             </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">MPI_Request</span><span class="w"> </span><span class="n">request</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="n">sendData_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Fetch</span><span class="p">)</span><span class="w"> </span><span class="n">sendData_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// TODO: remove this because I have SelfSufficient</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">otherRank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w">      </span><span class="n">sendData_p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sendData_p</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">MPI_Isend</span><span class="p">(</span><span class="w"> </span><span class="n">sources</span><span class="p">[</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="p">].</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">sources</span><span class="p">[</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">traits</span><span class="o">::</span><span class="n">mpi</span><span class="o">::</span><span class="n">datatypeOf</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">otherRank</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">request</span><span class="w"></span>
<span class="w">               </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CRAZY_DEBUG</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;sent to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">otherRank</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * \brief Receive asynchronously only if the state is Fetch</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">receive</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Info</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">findByInfo</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Fetch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TODO: do it through the slice class</span>
<span class="w">        </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Dispatched</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">MPI_Request</span><span class="w"> </span><span class="n">request</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">slice</span><span class="p">.</span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">MPI_Irecv</span><span class="p">(</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">size</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">traits</span><span class="o">::</span><span class="n">mpi</span><span class="o">::</span><span class="n">datatypeOf</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="p">.</span><span class="n">request</span><span class="w"></span>
<span class="w">                </span><span class="c1">//, MPI_STATUS_IGNORE</span>
<span class="w">                 </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">unwrapAll</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">sliceTypes</span><span class="p">)</span><span class="w"> </span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">F</span><span class="o">*</span><span class="w"> </span><span class="n">unwrapSlice</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CRAZY_DEBUG</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__unwrap__:slice &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; w n &quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; abc&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">findByTypeAbc</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">//WITH_RANK &lt;&lt; &quot;__unwrap__:info &quot; &lt;&lt; slice.info &lt;&lt; &quot;\n&quot;;</span>
<span class="w">      </span><span class="k">switch</span><span class="w">  </span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Dispatched</span><span class="o">:</span><span class="w"></span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__unwrap__:Fetch: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; info &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">slice</span><span class="p">.</span><span class="n">unwrapAndMarkReady</span><span class="p">();</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">SelfSufficient</span><span class="o">:</span><span class="w"></span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__unwrap__:SelfSufficient: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; info &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Ready</span><span class="o">:</span><span class="w"></span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__unwrap__:READY: UNWRAPPED ALREADY&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; info &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Recycled</span><span class="o">:</span><span class="w"></span>
<span class="w">          </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__unwrap__:RECYCLED &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slice</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; info &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">recycling</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Fetch</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Acceptor</span><span class="o">:</span><span class="w"></span>
<span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">&quot;Can&#39;t unwrap an acceptor or fetch slice!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">&quot;Unknown error unwrapping slice!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">RankMap</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rankMap</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">world</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">universe</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sliceLength</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sources</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">slices</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Name</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sliceTypes</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sliceBuffers</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">F</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">freePointers</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&amp;</span><span class="w"></span>
<span class="w">  </span><span class="n">unionByName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">unions</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Name</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sliceUnionIt</span><span class="w"></span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">unions</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">unions</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                      </span><span class="p">[</span><span class="o">&amp;</span><span class="n">name</span><span class="p">](</span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">                      </span><span class="p">});</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sliceUnionIt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">unions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">stream</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;SliceUnion(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;) not found!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="n">stream</span><span class="p">.</span><span class="n">str</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="o">**</span><span class="n">sliceUnionIt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="tuples">
<h2><a class="toc-backref" href="#id23">6 Tuples</a><a class="headerlink" href="#tuples" title="Permalink to this headline">¶</a></h2>
<p>This section introduces the types for tuples <span class="math notranslate nohighlight">\((a,b,c)\)</span>
as well as their distribution to nodes and cores.</p>
<section id="tuples-types">
<h3><a class="toc-backref" href="#id24">6.1 Tuples types</a><a class="headerlink" href="#tuples-types" title="Permalink to this headline">¶</a></h3>
<p>The main tuple types are simple type aliases for finite-size arrays.
A tuple is thus simply 3 natural numbers <span class="math notranslate nohighlight">\((a,b,c)\)</span>
whereas a partial tuple is a two dimensional subset of these three.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">PartialTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">ABCTuples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ABCTuple</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">constexpr</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="n">FAKE_TUPLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="n">INVALID_TUPLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="distributing-the-tuples">
<h3><a class="toc-backref" href="#id25">6.2 Distributing the tuples</a><a class="headerlink" href="#distributing-the-tuples" title="Permalink to this headline">¶</a></h3>
<p>In general it is our task to distribute all the tuples
<span class="math notranslate nohighlight">\((a,b,c)\)</span> among the ranks. Every distribution should
make sure to allocate the same amount of tuples to every rank,
padding the list with <code class="docutils literal notranslate"><span class="pre">FAKE_TUPLE</span></code> elements as necessary.</p>
<p>The interface that we propose for this is simplye</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">TuplesDistribution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">ABCTuples</span><span class="w"> </span><span class="nf">getTuples</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">universe</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">tupleIsFake</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FAKE_TUPLE</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="node-information">
<h3><a class="toc-backref" href="#id26">6.3 Node information</a><a class="headerlink" href="#node-information" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>nodeList</dt><dd><p>List of hostnames of size <span class="math notranslate nohighlight">\(N_n\)</span></p>
</dd>
<dt>nodeInfos</dt><dd><p>List of (hostname, local rank Id)
of size <span class="math notranslate nohighlight">\(N_p\)</span>, i.e., size of ranks
where local rank id goes from 0 to 48.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">getNodeNames</span></code> gets the names of the nodes used,
i.e., the size of the resulting vector gives the
number of nodes.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getNodeNames</span><span class="p">(</span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">comm</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">np</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nodeList</span><span class="p">(</span><span class="n">np</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">nodeName</span><span class="p">[</span><span class="n">MPI_MAX_PROCESSOR_NAME</span><span class="p">]</span><span class="w"></span>
<span class="w">     </span><span class="p">,</span><span class="w"> </span><span class="n">nodeNames</span><span class="p">[</span><span class="n">np</span><span class="o">*</span><span class="n">MPI_MAX_PROCESSOR_NAME</span><span class="p">]</span><span class="w"></span>
<span class="w">     </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nameLengths</span><span class="p">(</span><span class="n">np</span><span class="p">)</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">(</span><span class="n">np</span><span class="p">)</span><span class="w"></span>
<span class="w">                 </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nameLength</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Get_processor_name</span><span class="p">(</span><span class="n">nodeName</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nameLength</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Allgather</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nameLength</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">MPI_INT</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">nameLengths</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">MPI_INT</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">comm</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">off</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">off</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nameLengths</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Allgatherv</span><span class="p">(</span><span class="n">nodeName</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">nameLengths</span><span class="p">[</span><span class="n">rank</span><span class="p">],</span><span class="w"></span>
<span class="w">                 </span><span class="n">MPI_BYTE</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">nodeNames</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">nameLengths</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                 </span><span class="n">off</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                 </span><span class="n">MPI_BYTE</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">comm</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodeNames</span><span class="p">[</span><span class="n">off</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="w"> </span><span class="n">nameLengths</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">nodeList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">nodeList</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">getNodeInfos</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">RankInfo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nodeId</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">globalRank</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">localRank</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ranksPerNode</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">A</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">A</span><span class="w"> </span><span class="n">unique</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">result</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">result</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">result</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">result</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">result</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">last</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">result</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RankInfo</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">getNodeInfos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">nodeNames</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RankInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">uniqueNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unique</span><span class="p">(</span><span class="n">nodeNames</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">uniqueNames</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">uniqueNames</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">uniqueNames</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">uniqueNames</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">it</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">localRanks</span><span class="p">(</span><span class="n">uniqueNames</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">globalRank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">nodeNames</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nodeId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">name</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">nodeId</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">globalRank</span><span class="o">++</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">localRanks</span><span class="p">[</span><span class="n">nodeId</span><span class="p">]</span><span class="o">++</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="w"></span>
<span class="w">                      </span><span class="n">std</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="n">nodeNames</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">nodeNames</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
<span class="w">                      </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ClusterInfo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nNodes</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">ranksPerNode</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RankInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rankInfos</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">ClusterInfo</span><span class="w"></span>
<span class="nf">getClusterInfo</span><span class="p">(</span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">comm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNodeNames</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">rankInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNodeInfos</span><span class="p">(</span><span class="n">names</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ClusterInfo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">unique</span><span class="p">(</span><span class="n">names</span><span class="p">).</span><span class="n">size</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="n">rankInfos</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ranksPerNode</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">rankInfos</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="naive-list">
<h3><a class="toc-backref" href="#id27">6.4 Naive list</a><a class="headerlink" href="#naive-list" title="Permalink to this headline">¶</a></h3>
<p>The naive implementation of the global tuples list is simple
three for loops creating tuples of the sort
<span class="math notranslate nohighlight">\((a,b,c)\)</span> where the following conditions are met at the same time:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(a \leq b \leq c\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(a \neq b \land b \neq c\)</span></p></li>
</ul>
<p>This means,
<span class="math notranslate nohighlight">\((1, 2, 3) , (1, 1, 3) , (1, 2, 2)\)</span>
are acceptable tuples wherease <span class="math notranslate nohighlight">\((2, 1, 1)\)</span> and <span class="math notranslate nohighlight">\((1, 1, 1)\)</span> are not.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ABCTuples</span><span class="w"> </span><span class="nf">getTuplesList</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"></span>
<span class="w">    </span><span class="c1">// total number of tuples for the problem</span>
<span class="w">       </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>

<span class="w">    </span><span class="c1">// all ranks should have the same number of tuples_per_rank</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">tuples_per_rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">size_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// start index for the global tuples list</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuples_per_rank</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rank</span><span class="w"></span>

<span class="w">    </span><span class="c1">// end index for the global tuples list</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuples_per_rank</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;tuples_per_rank = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuples_per_rank</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;start, end = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ABCTuples</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">tuples_per_rank</span><span class="p">,</span><span class="w"> </span><span class="n">FAKE_TUPLE</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w">             </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">             </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="n">result</span><span class="p">[</span><span class="n">r</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">g</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>and all tuples would simply be</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ABCTuples</span><span class="w"> </span><span class="nf">getAllTuplesList</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ABCTuples</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">[</span><span class="n">u</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">getTupleList</span></code> we can easily define a tuple distribution like</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">NaiveDistribution</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TuplesDistribution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ABCTuples</span><span class="w"> </span><span class="nf">getTuples</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">universe</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">np</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getTuplesList</span><span class="p">(</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">np</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="group-and-sort-list">
<h3><a class="toc-backref" href="#id28">6.5 Group and sort list</a><a class="headerlink" href="#group-and-sort-list" title="Permalink to this headline">¶</a></h3>
<section id="id2">
<h4><a class="toc-backref" href="#id29">6.5.1 Utils</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Provides the node on which the slice-element is found</span>
<span class="c1">// Right now we distribute the slices in a round robin fashion</span>
<span class="c1">// over the different nodes (NOTE: not mpi ranks but nodes)</span>
<span class="kr">inline</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">isOnNode</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">tuple</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">nNodes</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>


<span class="c1">// return the node (or all nodes) where the elements of this</span>
<span class="c1">// tuple are located</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getTupleNodes</span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">nTuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="p">,</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="p">,</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">unique</span><span class="p">(</span><span class="n">nTuple</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Info</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nNodes</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nodeId</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="distribution">
<h4><a class="toc-backref" href="#id30">6.5.2 Distribution</a><a class="headerlink" href="#distribution" title="Permalink to this headline">¶</a></h4>
<p>wording: home element = element which is located on the given node</p>
<ol class="arabic simple">
<li><p>we distribute the tuples such that each tuple has at least one ‘home element’</p></li>
<li><p>we sort each tuple in a way that the ‘home element’ are the fastest indices</p></li>
<li><p>we sort the list of tuples on every node</p></li>
<li><p>we resort the tuples that for every tuple abc the following holds: a&lt;b&lt;c</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ABCTuples</span><span class="w"> </span><span class="nf">specialDistribution</span><span class="p">(</span><span class="n">Info</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">ABCTuples</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">allTuples</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">ABCTuples</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nNodes</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nNodes</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ABCTuples</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">container1d</span><span class="p">(</span><span class="n">nNodes</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">container2d</span><span class="p">(</span><span class="n">nNodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">container3d</span><span class="p">(</span><span class="n">nNodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nNodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Going through all &quot;</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">allTuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; tuples in &quot;</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; nodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// build container-n-d&#39;s</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">allTuples</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// one which node(s) are the tuple elements located...</span>
<span class="w">    </span><span class="c1">// put them into the right container</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTupleNodes</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">nNodes</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">_nodes</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">container1d</span><span class="p">[</span><span class="n">_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">container2d</span><span class="p">[</span><span class="w"> </span><span class="n">_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">                   </span><span class="o">+</span><span class="w"> </span><span class="n">_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">                   </span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">container3d</span><span class="p">[</span><span class="w"> </span><span class="n">_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">                   </span><span class="o">+</span><span class="w"> </span><span class="n">_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">                   </span><span class="o">+</span><span class="w"> </span><span class="n">_nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nNodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">                   </span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Building 1-d containers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// DISTRIBUTE 1-d containers</span>
<span class="w">  </span><span class="c1">// every tuple which is only located at one node belongs to this node</span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">_tuples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container1d</span><span class="p">[</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">_tuples</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">INVALID_TUPLE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">_tuples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">_tuples</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Building 2-d containers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// DISTRIBUTE 2-d containers</span>
<span class="w">  </span><span class="c1">//the tuples which are located at two nodes are half/half given to these nodes</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">yx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">yx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">container2d</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">yx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">_tuples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container2d</span><span class="p">[</span><span class="n">yx</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yx</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">         </span><span class="c1">// remeber: yx = idy * nNodes + idx</span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">idy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">n_half</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_tuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">         </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbeg</span><span class="p">,</span><span class="w"> </span><span class="n">nend</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">nbeg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_half</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">nend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_half</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">idy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">nbeg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_half</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">nend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_tuples</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// either idx or idy is my node</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nextra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nend</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nbeg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nextra</span><span class="p">,</span><span class="w"> </span><span class="n">INVALID_TUPLE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">_tuples</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nbeg</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">_tuples</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nend</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">Building 3-d containers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// DISTRIBUTE 3-d containers</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">zyx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">zyx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">container3d</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">zyx</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">_tuples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container3d</span><span class="p">[</span><span class="n">zyx</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zyx</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">idy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">zyx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">         </span><span class="c1">// remember: zyx = idx + idy * nNodes + idz * nNodes^2</span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">idz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zyx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nNodes</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nNodes</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">n_third</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_tuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">         </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbeg</span><span class="p">,</span><span class="w"> </span><span class="n">nend</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">nbeg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_third</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">nend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_third</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">idy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">nbeg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_third</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">nend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_third</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">idz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">nbeg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_third</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">nend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_tuples</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// either idx or idy or idz is my node</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nextra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nend</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nbeg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nextra</span><span class="p">,</span><span class="w"> </span><span class="n">INVALID_TUPLE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">_tuples</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nbeg</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">_tuples</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nend</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">swapping tuples...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">   *  sort part of group-and-sort algorithm</span>
<span class="cm">   *  every tuple on a given node is sorted in a way that</span>
<span class="cm">   *  the &#39;home elements&#39; are the fastest index.</span>
<span class="cm">   *  1:yyy 2:yyn(x) 3:yny(x) 4:ynn(x) 5:nyy 6:nyn(x) 7:nny 8:nnn</span>
<span class="cm">   */</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nt</span><span class="o">:</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="p">){</span><span class="w"> </span><span class="c1">// 1234</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="p">){</span><span class="w"> </span><span class="c1">// 24</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="n">nt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nt</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">         </span><span class="c1">// switch first and last</span>
<span class="w">        </span><span class="n">nt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="p">){</span><span class="w"> </span><span class="c1">// 3</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="n">nt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nt</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">         </span><span class="c1">// switch first two</span>
<span class="w">        </span><span class="n">nt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w">   </span><span class="c1">// 56</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">isOnNode</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">nNodes</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 6</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">nt</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="n">nt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nt</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">         </span><span class="c1">// switch last two</span>
<span class="w">        </span><span class="n">nt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">sorting list of tuples...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">//now we sort the list of tuples</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">restoring tuples...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// we bring the tuples abc back in the order a&lt;b&lt;c</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">)</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>

<span class="cp">#if ATRIP_DEBUG &gt; 1</span>
<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;checking for validity of &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">anyInvalid</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">any_of</span><span class="p">(</span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="p">[](</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">INVALID_TUPLE</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">anyInvalid</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="s">&quot;Some tuple is invalid in group-and-sort algorithm&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">nodeId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">returning tuples...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="main">
<h4><a class="toc-backref" href="#id31">6.5.3 Main</a><a class="headerlink" href="#main" title="Permalink to this headline">¶</a></h4>
<p>The main routine should return the list of tuples to be handled by the current rank.</p>
<p>Let <span class="math notranslate nohighlight">\(N_p\)</span> be the number of ranks or processes.
Let <span class="math notranslate nohighlight">\(N_n\)</span> be the number of nodes or sockets.</p>
<p>Then we have the following</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Global</span> <span class="n">rank</span> <span class="o">|</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span>
<span class="n">key</span>         <span class="o">|</span> <span class="k">global</span> <span class="n">rank</span>
<span class="n">nodeId</span>      <span class="o">|</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span>
<span class="n">Local</span> <span class="n">rank</span>  <span class="o">|</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="n">intra</span> <span class="n">color</span> <span class="o">|</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ABCTuple</span><span class="o">&gt;</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">np</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ABCTuple</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nodeNames</span><span class="p">(</span><span class="n">getNodeNames</span><span class="p">(</span><span class="n">universe</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unique</span><span class="p">(</span><span class="n">nodeNames</span><span class="p">).</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">nodeInfos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNodeInfos</span><span class="p">(</span><span class="n">nodeNames</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// We want to construct a communicator which only contains of one</span>
<span class="w">  </span><span class="c1">// element per node</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">computeDistribution</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">localRank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ABCTuple</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">nodeTuples</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">computeDistribution</span><span class="w"></span>
<span class="w">      </span><span class="o">?</span><span class="w"> </span><span class="n">specialDistribution</span><span class="p">(</span><span class="n">Info</span><span class="p">{</span><span class="n">nNodes</span><span class="p">,</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">nodeId</span><span class="p">},</span><span class="w"></span>
<span class="w">                            </span><span class="n">getAllTuplesList</span><span class="p">(</span><span class="n">Nv</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ABCTuple</span><span class="o">&gt;</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;got nodeTuples</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// now we have to send the data from **one** rank on each node</span>
<span class="w">  </span><span class="c1">// to all others ranks of this node</span>
<span class="w">    </span><span class="k">const</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">nodeId</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">localRank</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>


<span class="w">  </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">INTRA_COMM</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm_split</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">INTRA_COMM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Every node has to distribute <strong>**at least**</strong>
<code class="docutils literal notranslate"><span class="pre">nodeTuples.size()</span> <span class="pre">/</span> <span class="pre">nodeInfos[rank].ranksPerNode</span></code>
tuples among the ranks.</p>
<p>We have to communicate this quantity among all nodes.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="w">  </span><span class="n">tuplesPerRankLocal</span><span class="w"></span>
<span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">ranksPerNode</span><span class="w"></span>
<span class="w">     </span><span class="o">+</span><span class="w"> </span><span class="kt">size_t</span><span class="p">(</span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">ranksPerNode</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">     </span><span class="p">;</span><span class="w"></span>

<span class="kt">size_t</span><span class="w"> </span><span class="n">tuplesPerRankGlobal</span><span class="p">;</span><span class="w"></span>

<span class="n">MPI_Reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tuplesPerRankLocal</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="o">&amp;</span><span class="n">tuplesPerRankGlobal</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">MPI_UINT64_T</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">MPI_MAX</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>

<span class="n">MPI_Bcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tuplesPerRankGlobal</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">MPI_UINT64_T</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>

<span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Tuples per rank: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">tuplesPerRankGlobal</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ranks per node &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">ranksPerNode</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#nodes &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nNodes</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Now we have the tuples that every rank has to have, i.e.,
<code class="docutils literal notranslate"><span class="pre">tuplesPerRankGlobal</span></code>.</p>
<p>However before this,
the tuples in <code class="docutils literal notranslate"><span class="pre">nodeTuples</span></code> now have to be sent from the local rank
in every node to all the ranks in the given node,
and we have to make sure that every rank inside a given node
gets the same amount of tuples, in this case it should be
<code class="docutils literal notranslate"><span class="pre">tuplesPerRankLocal</span></code>, and in our node the total number
of tuples should be <code class="docutils literal notranslate"><span class="pre">tuplesPerRankLocal</span> <span class="pre">*</span> <span class="pre">nodeInfos[rank].ranksPerNode</span></code>,
however this might not be the case up to now due to divisibility issues.</p>
<p>Up to now we have exactly <code class="docutils literal notranslate"><span class="pre">nodeTuples.size()</span></code> tuples, we have to make sure by
resizing that the condition above is met, i.e., so we can resize
and add some fake tuples at the end as padding.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">totalTuples</span><span class="w"></span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">tuplesPerRankGlobal</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nodeInfos</span><span class="p">[</span><span class="n">rank</span><span class="p">].</span><span class="n">ranksPerNode</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">computeDistribution</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// pad with FAKE_TUPLEs</span>
<span class="w">  </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"></span>
<span class="w">                    </span><span class="n">totalTuples</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"></span>
<span class="w">                    </span><span class="n">FAKE_TUPLE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>And now we can simply scatter the tuples in nodeTuples and send
<code class="docutils literal notranslate"><span class="pre">tuplesPerRankGlobal</span></code> to the different ranks in the node,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// construct mpi type for abctuple</span>
<span class="w">  </span><span class="n">MPI_Datatype</span><span class="w"> </span><span class="n">MPI_ABCTUPLE</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Type_vector</span><span class="p">(</span><span class="n">nodeTuples</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_UINT64_T</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MPI_ABCTUPLE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Type_commit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MPI_ABCTUPLE</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;scattering tuples </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">result</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">tuplesPerRankGlobal</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Scatter</span><span class="p">(</span><span class="n">nodeTuples</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">              </span><span class="n">tuplesPerRankGlobal</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">MPI_ABCTUPLE</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">result</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">              </span><span class="n">tuplesPerRankGlobal</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">MPI_ABCTUPLE</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">INTRA_COMM</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">MPI_Type_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MPI_ABCTUPLE</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The next step is sending the tuples in the local root rank
to the other ranks in the node, this we do with the MPI function
<code class="docutils literal notranslate"><span class="pre">MPI_Scatterv</span></code>.
Every rank gets <code class="docutils literal notranslate"><span class="pre">tuplesPerRankLocal</span></code> tuples and
the <code class="docutils literal notranslate"><span class="pre">nodeTuples</span></code> vector is now homogeneous and divisible by the number
of ranks per node in our node.
Therefore, the <code class="docutils literal notranslate"><span class="pre">displacements</span></code> are simply the vector</p>
<div class="math notranslate nohighlight">
\[\left\{
  k * \mathrm{tuplesPerNodeLocal}
  \mid
  k \in
  \left\{ 0
        , \ldots
        , \#\text{ranks in node} - 1
        \right\}
  \right\}\]</div>
<p>and the <code class="docutils literal notranslate"><span class="pre">sendCounts</span></code> vector is simply the constant vector
<code class="docutils literal notranslate"><span class="pre">tuplesPerRankLocal</span></code> of size <code class="docutils literal notranslate"><span class="pre">ranksPerNode</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="interface">
<h4><a class="toc-backref" href="#id32">6.5.4 Interface</a><a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h4>
<p>The distribution interface will then simply be</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Distribution</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TuplesDistribution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ABCTuples</span><span class="w"> </span><span class="nf">getTuples</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">universe</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="n">Nv</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="unions">
<h2><a class="toc-backref" href="#id33">7 Unions</a><a class="headerlink" href="#unions" title="Permalink to this headline">¶</a></h2>
<p>Every slice pertaining to every different tensor
is sliced differently.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/SliceUnion.hpp&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">sliceIntoVector</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">toSlice</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">low</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">up</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">origin</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">originLow</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">originUp</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Thank you CTF for forcing me to do this</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">up</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">toSlice_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="n">up</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">up</span><span class="p">.</span><span class="n">end</span><span class="p">()}</span><span class="w"></span>
<span class="w">                   </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">low</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">low</span><span class="p">.</span><span class="n">end</span><span class="p">()}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">,</span><span class="w"> </span><span class="n">origin_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="n">originUp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">originUp</span><span class="p">.</span><span class="n">end</span><span class="p">()}</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">originLow</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">originLow</span><span class="p">.</span><span class="n">end</span><span class="p">()}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">WITH_OCD</span><span class="w"></span>
<span class="w">    </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;slicing into &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">toSlice_</span><span class="p">.</span><span class="n">up</span><span class="p">)</span><span class="w"></span>
<span class="w">                          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">toSlice_</span><span class="p">.</span><span class="n">low</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; from &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">origin_</span><span class="p">.</span><span class="n">up</span><span class="p">)</span><span class="w"></span>
<span class="w">                   </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">origin_</span><span class="p">.</span><span class="n">low</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="cp">#ifndef ATRIP_DONT_SLICE</span>
<span class="w">    </span><span class="n">toSlice</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="w"> </span><span class="n">toSlice_</span><span class="p">.</span><span class="n">low</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">toSlice_</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">origin_</span><span class="p">.</span><span class="n">low</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="n">origin_</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">toSlice</span><span class="p">.</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">TAPHH</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TAPHH</span><span class="p">(</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">         </span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">C</span><span class="p">}</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the slices</span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Nv</span><span class="p">}</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">TA</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">sourceTensor</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">sliceIntoBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">from</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sliceLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sliceLength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rankMap</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">),</span><span class="w"> </span><span class="n">it</span><span class="p">});</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"></span>


<span class="w">      </span><span class="n">sliceIntoVector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sources</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w">   </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">    </span><span class="p">{</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">};</span><span class="w"></span>


<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">HHHA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">HHHA</span><span class="p">(</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">C</span><span class="p">}</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the slices</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Nv</span><span class="p">}</span><span class="w">         </span><span class="c1">// size of the parametrization</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">VIJKA</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">sourceTensor</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">sliceIntoBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">from</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sliceLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rankMap</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">),</span><span class="w"> </span><span class="n">it</span><span class="p">})</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">sliceIntoVector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sources</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w">   </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">    </span><span class="p">{</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ABPH</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABPH</span><span class="p">(</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AB</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BC</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AC</span><span class="w"></span>
<span class="w">                           </span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BA</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">CB</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">CA</span><span class="w"></span>
<span class="w">                           </span><span class="p">}</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the slices</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">Nv</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the parametrization</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">VABCI</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">sourceTensor</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">sliceIntoBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">from</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sliceLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sliceLength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rankMap</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">),</span><span class="w"> </span><span class="n">it</span><span class="p">})</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"></span>


<span class="w">      </span><span class="n">sliceIntoVector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sources</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w">   </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">       </span><span class="p">{</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ABHH</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABHH</span><span class="p">(</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AB</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BC</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AC</span><span class="p">}</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the slices</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">Nv</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the parametrization</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">VABIJ</span><span class="w"></span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">sourceTensor</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">sliceIntoBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">from</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from</span><span class="p">.</span><span class="n">lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sliceLength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rankMap</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">),</span><span class="w"> </span><span class="n">it</span><span class="p">})</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">sliceIntoVector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sources</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w">   </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">       </span><span class="p">{</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">);</span><span class="w"></span>


<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">};</span><span class="w"></span>


<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">TABHH</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">TABHH</span><span class="p">(</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">         </span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">sourceTensor</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AB</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BC</span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AC</span><span class="p">}</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the slices</span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">Nv</span><span class="p">}</span><span class="w"> </span><span class="c1">// size of the parametrization</span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">child_world</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">global_world</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">TABIJ</span><span class="w"></span>
<span class="w">                          </span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">sourceTensor</span><span class="p">);</span><span class="w"></span>
<span class="w">         </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">sliceIntoBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">from</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// TODO: maybe generalize this with ABHH</span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from</span><span class="p">.</span><span class="n">lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sliceLength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rankMap</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">),</span><span class="w"> </span><span class="n">it</span><span class="p">})</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">sliceIntoVector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sources</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w">   </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">       </span><span class="p">{</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">}</span><span class="w"></span>
<span class="w">                        </span><span class="p">);</span><span class="w"></span>


<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="equations">
<h2><a class="toc-backref" href="#id34">8 Equations</a><a class="headerlink" href="#equations" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="cpf">&lt;atrip/Slice.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;atrip/Blas.hpp&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">getEnergyDistinct</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">epsabc</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">epsi</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Tijk_</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Zijk_</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">blockSize</span><span class="o">=</span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">F</span><span class="w"> </span><span class="nf">energy</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">epsi</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">kk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">kk</span><span class="o">&lt;</span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">kk</span><span class="o">+=</span><span class="n">blockSize</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">kend</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="o">+</span><span class="n">blockSize</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">jj</span><span class="p">(</span><span class="n">kk</span><span class="p">);</span><span class="w"> </span><span class="n">jj</span><span class="o">&lt;</span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">+=</span><span class="n">blockSize</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">jend</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="o">+</span><span class="n">blockSize</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">ii</span><span class="p">(</span><span class="n">jj</span><span class="p">);</span><span class="w"> </span><span class="n">ii</span><span class="o">&lt;</span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">+=</span><span class="n">blockSize</span><span class="p">){</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">iend</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">+</span><span class="n">blockSize</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">(</span><span class="n">kk</span><span class="p">);</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kend</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="nf">ek</span><span class="p">(</span><span class="n">epsi</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">jstart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="p">(</span><span class="n">jstart</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">jend</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">              </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ej</span><span class="p">(</span><span class="n">epsi</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
<span class="w">              </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">facjk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="kt">size_t</span><span class="w"> </span><span class="n">istart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">(</span><span class="n">istart</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iend</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"></span>
<span class="w">                    </span><span class="nf">ei</span><span class="p">(</span><span class="n">epsi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">facij</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">denominator</span><span class="p">(</span><span class="n">epsabc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ei</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ej</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ek</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="p">])</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="p">])</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="p">])</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="p">])</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">Z</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="p">]))</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="p">]))</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="p">]))</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="p">]))</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="p">]))</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">_F</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="p">]))</span><span class="w"></span>
<span class="w">                  </span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">U</span><span class="w"></span>
<span class="w">                              </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">V</span><span class="w"></span>
<span class="w">                              </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">W</span><span class="w"></span>
<span class="w">                              </span><span class="o">+</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="w"></span>
<span class="w">                              </span><span class="o">+</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Y</span><span class="w"></span>
<span class="w">                              </span><span class="o">+</span><span class="w"> </span><span class="n">_F</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                   </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                   </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                     </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_F</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">energy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">denominator</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">facjk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">facij</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"> </span><span class="c1">// i</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="c1">// j</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="c1">// k</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="c1">// ii</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="c1">// jj</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// kk</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">real</span><span class="p">(</span><span class="n">energy</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">getEnergySame</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">epsabc</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">epsi</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Tijk_</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Zijk_</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">blockSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">epsi</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">F</span><span class="w"> </span><span class="n">energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">kk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">kk</span><span class="o">&lt;</span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">kk</span><span class="o">+=</span><span class="n">blockSize</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">kend</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="w"> </span><span class="n">kk</span><span class="o">+</span><span class="n">blockSize</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">jj</span><span class="p">(</span><span class="n">kk</span><span class="p">);</span><span class="w"> </span><span class="n">jj</span><span class="o">&lt;</span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">+=</span><span class="n">blockSize</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">jend</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="w"> </span><span class="n">jj</span><span class="o">+</span><span class="n">blockSize</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">ii</span><span class="p">(</span><span class="n">jj</span><span class="p">);</span><span class="w"> </span><span class="n">ii</span><span class="o">&lt;</span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">ii</span><span class="o">+=</span><span class="n">blockSize</span><span class="p">){</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">iend</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="w"> </span><span class="n">ii</span><span class="o">+</span><span class="n">blockSize</span><span class="p">,</span><span class="w"> </span><span class="n">No</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="p">(</span><span class="n">kk</span><span class="p">);</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">kend</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="nf">ek</span><span class="p">(</span><span class="n">epsi</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">jstart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="p">(</span><span class="n">jstart</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">jend</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="nf">facjk</span><span class="p">(</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span><span class="w"></span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="nf">ej</span><span class="p">(</span><span class="n">epsi</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">istart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">(</span><span class="n">istart</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iend</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"></span>
<span class="w">                  </span><span class="nf">ei</span><span class="p">(</span><span class="n">epsi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">facij</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">denominator</span><span class="p">(</span><span class="n">epsabc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ei</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ej</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ek</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="p">])</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="p">])</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">(</span><span class="n">Zijk_</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="p">])</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="p">]))</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="p">]))</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">maybeConjugate</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tijk_</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">j</span><span class="p">]))</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">                  </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">U</span><span class="w"></span>
<span class="w">                             </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">V</span><span class="w"></span>
<span class="w">                             </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">W</span><span class="w"></span>
<span class="w">                             </span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">energy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">denominator</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">facjk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">facij</span><span class="p">;</span><span class="w"></span>
<span class="w">              </span><span class="p">}</span><span class="w"> </span><span class="c1">// i</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="c1">// j</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="c1">// k</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="c1">// ii</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="c1">// jj</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// kk</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">real</span><span class="p">(</span><span class="n">energy</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">singlesContribution</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="o">&amp;</span><span class="n">abc</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">Tph</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VABij</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VACij</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VBCij</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">*</span><span class="n">Zijk</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ijk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w">  </span><span class="n">jk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"></span>
<span class="w">                </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">Zijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Tph</span><span class="p">[</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VBCij</span><span class="p">[</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">Zijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Tph</span><span class="p">[</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VACij</span><span class="p">[</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">Zijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">Tph</span><span class="p">[</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VABij</span><span class="p">[</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">doublesContribution</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="o">&amp;</span><span class="n">abc</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">No</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Nv</span><span class="w"></span>
<span class="w">    </span><span class="c1">// -- VABCI</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VABph</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VACph</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VBCph</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VBAph</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VCAph</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VCBph</span><span class="w"></span>
<span class="w">    </span><span class="c1">// -- VHHHA</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VhhhA</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VhhhB</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">VhhhC</span><span class="w"></span>
<span class="w">    </span><span class="c1">// -- TA</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">TAphh</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">TBphh</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">TCphh</span><span class="w"></span>
<span class="w">    </span><span class="c1">// -- TABIJ</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">TABhh</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">TAChh</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">TBChh</span><span class="w"></span>
<span class="w">    </span><span class="c1">// -- TIJK</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">*</span><span class="n">Tijk</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="w">              </span><span class="p">,</span><span class="w"> </span><span class="n">NoNo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">NoNv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">Nv</span><span class="w"></span>
<span class="w">              </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="cp">#if defined(ATRIP_USE_DGEMM)</span>
<span class="w">  </span><span class="cp">#define _IJK_(i, j, k) i + j*No + k*NoNo</span>
<span class="w">  </span><span class="cp">#define REORDER(__II, __JJ, __KK)                                 \</span>
<span class="cp">    WITH_CHRONO(&quot;doubles:reorder&quot;,                                  \</span>
<span class="cp">    for (size_t k = 0; k &lt; No; k++)                                 \</span>
<span class="cp">    for (size_t j = 0; j &lt; No; j++)                                 \</span>
<span class="cp">    for (size_t i = 0; i &lt; No; i++) {                               \</span>
<span class="cp">      Tijk[_IJK_(i, j, k)] += _t_buffer[_IJK_(__II, __JJ, __KK)];   \</span>
<span class="cp">    }                                                               \</span>
<span class="cp">    )</span>
<span class="w">  </span><span class="cp">#define DGEMM_PARTICLES(__A, __B)      \</span>
<span class="cp">    atrip::xgemm&lt;F&gt;( &quot;T&quot;                 \</span>
<span class="cp">                   , &quot;N&quot;                 \</span>
<span class="cp">                   , (int const*)&amp;NoNo   \</span>
<span class="cp">                   , (int const*)&amp;No     \</span>
<span class="cp">                   , (int const*)&amp;Nv     \</span>
<span class="cp">                   , &amp;one                \</span>
<span class="cp">                   , __A                 \</span>
<span class="cp">                   , (int const*)&amp;Nv     \</span>
<span class="cp">                   , __B                 \</span>
<span class="cp">                   , (int const*)&amp;Nv     \</span>
<span class="cp">                   , &amp;zero               \</span>
<span class="cp">                   , _t_buffer.data()    \</span>
<span class="cp">                   , (int const*)&amp;NoNo   \</span>
<span class="cp">                   );</span>
<span class="w">  </span><span class="cp">#define DGEMM_HOLES(__A, __B, __TRANSB)    \</span>
<span class="cp">    atrip::xgemm&lt;F&gt;( &quot;N&quot;                     \</span>
<span class="cp">                   , __TRANSB                \</span>
<span class="cp">                   , (int const*)&amp;NoNo       \</span>
<span class="cp">                   , (int const*)&amp;No         \</span>
<span class="cp">                   , (int const*)&amp;No         \</span>
<span class="cp">                   , &amp;m_one                  \</span>
<span class="cp">                   , __A                     \</span>
<span class="cp">                   , (int const*)&amp;NoNo       \</span>
<span class="cp">                   , __B                     \</span>
<span class="cp">                   , (int const*)&amp;No         \</span>
<span class="cp">                   , &amp;zero                   \</span>
<span class="cp">                   , _t_buffer.data()        \</span>
<span class="cp">                   , (int const*)&amp;NoNo       \</span>
<span class="cp">                   );</span>
<span class="w">  </span><span class="cp">#define MAYBE_CONJ(_conj, _buffer)                 \</span>
<span class="cp">    for (size_t __i = 0; __i &lt; NoNoNo; ++__i)        \</span>
<span class="cp">      _conj[__i] = maybeConjugate&lt;F&gt;(_buffer[__i]);  \</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">NoNoNo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">No</span><span class="o">*</span><span class="n">NoNo</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_t_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_t_buffer</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">NoNoNo</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">F</span><span class="w"> </span><span class="n">one</span><span class="p">{</span><span class="mf">1.0</span><span class="p">},</span><span class="w"> </span><span class="n">m_one</span><span class="p">{</span><span class="mf">-1.0</span><span class="p">},</span><span class="w"> </span><span class="n">zero</span><span class="p">{</span><span class="mf">0.0</span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;double:reorder&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NoNoNo</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">Tijk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="p">})</span><span class="w"></span>

<span class="w">    </span><span class="c1">// TOMERGE: replace chronos</span>
<span class="w">    </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:holes&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="c1">// Holes part %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_vhhh</span><span class="p">(</span><span class="n">NoNoNo</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// VhhhC[i + k*No + L*NoNo] * TABhh[L + j*No]; H1</span>
<span class="w">        </span><span class="n">MAYBE_CONJ</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">,</span><span class="w"> </span><span class="n">VhhhC</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:holes:1&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_HOLES</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">TABhh</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;N&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// VhhhC[j + k*No + L*NoNo] * TABhh[i + L*No]; H0</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:holes:2&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_HOLES</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">TABhh</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;T&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="c1">// VhhhB[i + j*No + L*NoNo] * TAChh[L + k*No]; H5</span>
<span class="w">        </span><span class="n">MAYBE_CONJ</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">,</span><span class="w"> </span><span class="n">VhhhB</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:holes:3&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_HOLES</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">TAChh</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;N&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// VhhhB[k + j*No + L*NoNo] * TAChh[i + L*No]; H3</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:holes:4&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_HOLES</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">TAChh</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;T&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="c1">// VhhhA[j + i*No + L*NoNo] * TBChh[L + k*No]; H1</span>
<span class="w">        </span><span class="n">MAYBE_CONJ</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">,</span><span class="w"> </span><span class="n">VhhhA</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:holes:5&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_HOLES</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">TBChh</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;N&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// VhhhA[k + i*No + L*NoNo] * TBChh[j + L*No]; H4</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:holes:6&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_HOLES</span><span class="p">(</span><span class="n">_vhhh</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">TBChh</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;T&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="cp">#undef MAYBE_CONJ</span>

<span class="w">    </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:particles&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="c1">// Particle part %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="w">        </span><span class="c1">// TAphh[E + i*Nv + j*NoNv] * VBCph[E + k*Nv]; P0</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:particles:1&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_PARTICLES</span><span class="p">(</span><span class="n">TAphh</span><span class="p">,</span><span class="w"> </span><span class="n">VBCph</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TAphh[E + i*Nv + k*NoNv] * VCBph[E + j*Nv]; P3</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:particles:2&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_PARTICLES</span><span class="p">(</span><span class="n">TAphh</span><span class="p">,</span><span class="w"> </span><span class="n">VCBph</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TCphh[E + k*Nv + i*NoNv] * VABph[E + j*Nv]; P5</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:particles:3&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_PARTICLES</span><span class="p">(</span><span class="n">TCphh</span><span class="p">,</span><span class="w"> </span><span class="n">VABph</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TCphh[E + k*Nv + j*NoNv] * VBAph[E + i*Nv]; P2</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:particles:4&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_PARTICLES</span><span class="p">(</span><span class="n">TCphh</span><span class="p">,</span><span class="w"> </span><span class="n">VBAph</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TBphh[E + j*Nv + i*NoNv] * VACph[E + k*Nv]; P1</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:particles:5&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_PARTICLES</span><span class="p">(</span><span class="n">TBphh</span><span class="p">,</span><span class="w"> </span><span class="n">VACph</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TBphh[E + j*Nv + k*NoNv] * VCAph[E + i*Nv]; P4</span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles:particles:6&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">DGEMM_PARTICLES</span><span class="p">(</span><span class="n">TBphh</span><span class="p">,</span><span class="w"> </span><span class="n">VCAph</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">REORDER</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="cp">#undef REORDER</span>
<span class="w">  </span><span class="cp">#undef DGEMM_HOLES</span>
<span class="w">  </span><span class="cp">#undef DGEMM_PARTICLES</span>
<span class="w">  </span><span class="cp">#undef _IJK_</span>
<span class="w">  </span><span class="cp">#else</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ijk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">NoNo</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w">  </span><span class="n">jk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">No</span><span class="w"></span>
<span class="w">                </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// :important</span>
<span class="w">      </span><span class="c1">// HOLE DIAGRAMS: TABHH and VHHHA</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">No</span><span class="p">;</span><span class="w"> </span><span class="n">L</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="c1">// t[abLj] * V[Lcik]        H1</span>
<span class="w">        </span><span class="c1">// t[baLi] * V[Lcjk]        H0      TODO: conjugate T for complex</span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">TABhh</span><span class="p">[</span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">No</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VhhhC</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">NoNo</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">TABhh</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">No</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VhhhC</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">NoNo</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="c1">// t[acLk] * V[Lbij]        H5</span>
<span class="w">        </span><span class="c1">// t[caLi] * V[Lbkj]        H3</span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">TAChh</span><span class="p">[</span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">No</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VhhhB</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">NoNo</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">TAChh</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">No</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VhhhB</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">NoNo</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="c1">// t[bcLk] * V[Laji]        H2</span>
<span class="w">        </span><span class="c1">// t[cbLj] * V[Laki]        H4</span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">TBChh</span><span class="p">[</span><span class="n">L</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">No</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VhhhA</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">NoNo</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">TBChh</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">No</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VhhhA</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">No</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="o">*</span><span class="n">NoNo</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// PARTILCE DIAGRAMS: TAPHH and VABPH</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">E</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// t[aEij] * V[bcEk]        P0</span>
<span class="w">        </span><span class="c1">// t[aEik] * V[cbEj]        P3 // TODO: CHECK THIS ONE, I DONT KNOW</span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">TAphh</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">NoNv</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VBCph</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">Nv</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">TAphh</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">NoNv</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VCBph</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">Nv</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="c1">// t[cEki] * V[abEj]        P5</span>
<span class="w">        </span><span class="c1">// t[cEkj] * V[baEi]        P2</span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">TCphh</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">NoNv</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VABph</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">Nv</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">TCphh</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">NoNv</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VBAph</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">Nv</span><span class="p">];</span><span class="w"></span>

<span class="w">        </span><span class="c1">// t[bEji] * V[acEk]        P1</span>
<span class="w">        </span><span class="c1">// t[bEjk] * V[caEi]        P4</span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">TBphh</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">NoNv</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VACph</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">Nv</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Tijk</span><span class="p">[</span><span class="n">ijk</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">TBphh</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="o">*</span><span class="n">NoNv</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">VCAph</span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">Nv</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="blas">
<h2><a class="toc-backref" href="#id35">9 Blas</a><a class="headerlink" href="#blas" title="Permalink to this headline">¶</a></h2>
<p>The main matrix-matrix multiplication method used in this algorithm
is mainly using the <code class="docutils literal notranslate"><span class="pre">DGEMM</span></code> function, which we declare as
<code class="docutils literal notranslate"><span class="pre">extern</span></code> since it should be known only at link-time.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">dgemm_</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transa</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transb</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">lda</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldb</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldc</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">zgemm_</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transa</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transb</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">lda</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldb</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldc</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">xgemm</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transa</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transb</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">F</span><span class="w"> </span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">lda</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldb</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">F</span><span class="w"> </span><span class="o">*</span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">F</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">dgemm_</span><span class="p">(</span><span class="n">transa</span><span class="p">,</span><span class="w"> </span><span class="n">transb</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">lda</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">ldb</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">ldc</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">xgemm</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transa</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">transb</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">alpha</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">lda</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldb</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Complex</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ldc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">zgemm_</span><span class="p">(</span><span class="n">transa</span><span class="p">,</span><span class="w"> </span><span class="n">transb</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">lda</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">ldb</span><span class="p">,</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">ldc</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="atrip">
<h2><a class="toc-backref" href="#id36">10 Atrip</a><a class="headerlink" href="#atrip" title="Permalink to this headline">¶</a></h2>
<section id="header">
<h3><a class="toc-backref" href="#id37">10.1 Header</a><a class="headerlink" href="#header" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span><span class="cp"></span>


<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Utils.hpp&gt;</span><span class="cp"></span>

<span class="cp">#define ADD_ATTRIBUTE(_type, _name, _default)   \</span>
<span class="cp">  _type _name = _default;                       \</span>
<span class="cp">  Input&amp; with_ ## _name(_type i) {              \</span>
<span class="cp">    _name = i;                                  \</span>
<span class="cp">    return *this;                               \</span>
<span class="cp">  }</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">Atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Timings</span><span class="w"> </span><span class="n">chrono</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Input</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">ei</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Tph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Tpphh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Vpphh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Vhhhp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                        </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Vppph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                        </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">Input</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">with_epsilon_i</span><span class="p">(</span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ei</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">Input</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">with_epsilon_a</span><span class="p">(</span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">Input</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">with_Tai</span><span class="p">(</span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Tph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">Input</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">with_Tabij</span><span class="p">(</span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Tpphh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">Input</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">with_Vabij</span><span class="p">(</span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Vpphh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">Input</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">with_Vijka</span><span class="p">(</span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Vhhhp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">Input</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">with_Vabci</span><span class="p">(</span><span class="n">CTF</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Vppph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">enum</span><span class="w"> </span><span class="nc">TuplesDistribution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">NAIVE</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">GROUP_AND_SORT</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">};</span><span class="w"></span>

<span class="w">      </span><span class="n">ADD_ATTRIBUTE</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">rankRoundRobin</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ADD_ATTRIBUTE</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">chrono</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ADD_ATTRIBUTE</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">barrier</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ADD_ATTRIBUTE</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">maxIterations</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ADD_ATTRIBUTE</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">iterationMod</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ADD_ATTRIBUTE</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">percentageMod</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ADD_ATTRIBUTE</span><span class="p">(</span><span class="n">TuplesDistribution</span><span class="p">,</span><span class="w"> </span><span class="n">tuplesDistribution</span><span class="p">,</span><span class="w"> </span><span class="n">NAIVE</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Output</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">energy</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">=</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Output</span><span class="w"> </span><span class="n">run</span><span class="p">(</span><span class="n">Input</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="cp">#undef ADD_ATTRIBUTE</span>
</pre></div>
</div>
</section>
<section id="id3">
<h3><a class="toc-backref" href="#id38">10.2 Main</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Atrip.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Utils.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Equations.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/SliceUnion.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Unions.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RankMap</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">RANK_ROUND_ROBIN</span><span class="p">;</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RankMap</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">RANK_ROUND_ROBIN</span><span class="p">;</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RankMap</span><span class="o">&lt;</span><span class="n">Complex</span><span class="o">&gt;::</span><span class="n">RANK_ROUND_ROBIN</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">np</span><span class="p">;</span><span class="w"></span>
<span class="n">Timings</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span><span class="w"></span>

<span class="c1">// user printing block</span>
<span class="n">IterationDescriptor</span><span class="w"> </span><span class="n">IterationDescription</span><span class="o">::</span><span class="n">descriptor</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">atrip::registerIterationDescriptor</span><span class="p">(</span><span class="n">IterationDescriptor</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">IterationDescription</span><span class="o">::</span><span class="n">descriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Atrip::init</span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Atrip</span><span class="o">::</span><span class="n">np</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">Atrip</span><span class="o">::</span><span class="n">Output</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">Input</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">np</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">rank</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">universe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">wrld</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">ea</span><span class="o">-&gt;</span><span class="n">lens</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;No: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Nv: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;np: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// allocate the three scratches, see piecuch</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Tijk</span><span class="p">(</span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="p">)</span><span class="w"> </span><span class="c1">// doubles only (see piecuch)</span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">Zijk</span><span class="p">(</span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="o">*</span><span class="n">No</span><span class="p">)</span><span class="w"> </span><span class="c1">// singles + doubles (see piecuch)</span>
<span class="w">               </span><span class="c1">// we need local copies of the following tensors on every</span>
<span class="w">               </span><span class="c1">// rank</span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">epsi</span><span class="p">(</span><span class="n">No</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">epsa</span><span class="p">(</span><span class="n">Nv</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="p">,</span><span class="w"> </span><span class="n">Tai</span><span class="p">(</span><span class="n">No</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Nv</span><span class="p">)</span><span class="w"></span>
<span class="w">               </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">in</span><span class="p">.</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">read_all</span><span class="p">(</span><span class="n">epsi</span><span class="p">.</span><span class="n">data</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">in</span><span class="p">.</span><span class="n">ea</span><span class="o">-&gt;</span><span class="n">read_all</span><span class="p">(</span><span class="n">epsa</span><span class="p">.</span><span class="n">data</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">in</span><span class="p">.</span><span class="n">Tph</span><span class="o">-&gt;</span><span class="n">read_all</span><span class="p">(</span><span class="n">Tai</span><span class="p">.</span><span class="n">data</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">RankMap</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">RANK_ROUND_ROBIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">rankRoundRobin</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">RankMap</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">RANK_ROUND_ROBIN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Doing rank round robin slices distribution&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Doing node &gt; local rank round robin slices distribution&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="c1">// COMMUNICATOR CONSTRUCTION ========================================={{{1</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// Construct a new communicator living only on a single rank</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">child_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">child_rank</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">child_size</span><span class="w"></span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">crank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">child_size</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">child_comm</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">np</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">child_comm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">universe</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Comm_split</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="n">crank</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">child_comm</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">child_comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">child_rank</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">child_comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">child_size</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="c1">// BUILD SLICES PARAMETRIZED BY NV ==================================={{{1</span>
<span class="w">  </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;nv-slices&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;BUILD NV-SLICES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">TAPHH</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">taphh</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">.</span><span class="n">Tpphh</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">child_comm</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">HHHA</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w">  </span><span class="n">hhha</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">.</span><span class="n">Vhhhp</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">child_comm</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// BUILD SLICES PARAMETRIZED BY NV x NV =============================={{{1</span>
<span class="w">  </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;nv-nv-slices&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;BUILD NV x NV-SLICES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ABPH</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">abph</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">.</span><span class="n">Vppph</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">child_comm</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ABHH</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">abhh</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">.</span><span class="n">Vpphh</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">child_comm</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">TABHH</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tabhh</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">.</span><span class="n">Tpphh</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="n">child_comm</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// all tensors</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="w"> </span><span class="n">SliceUnion</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;*</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">unions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">&amp;</span><span class="n">taphh</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hhha</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">abph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">abhh</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tabhh</span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// get tuples for the current rank</span>
<span class="w">  </span><span class="n">TuplesDistribution</span><span class="w"> </span><span class="o">*</span><span class="n">distribution</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">tuplesDistribution</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">Input</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">TuplesDistribution</span><span class="o">::</span><span class="n">NAIVE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Using the naive distribution</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">distribution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NaiveDistribution</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Using the group-and-sort distribution</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">distribution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">group_and_sort</span><span class="o">::</span><span class="n">Distribution</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;BUILDING TUPLE LIST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;tuples:build&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tuplesList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distribution</span><span class="o">-&gt;</span><span class="n">getTuples</span><span class="p">(</span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nIterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuplesList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">_all_tuples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;#iterations: &quot;</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nIterations</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nIterations</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"></span>
<span class="w">      </span><span class="n">iterationMod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">percentageMod</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="o">?</span><span class="w"> </span><span class="n">nIterations</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">percentageMod</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">                  </span><span class="o">:</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">iterationMod</span><span class="w"></span>

<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="n">iteration1Percent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nIterations</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.01</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>



<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">isFakeTuple</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">tuplesList</span><span class="p">,</span><span class="w"> </span><span class="n">distribution</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">distribution</span><span class="o">-&gt;</span><span class="n">tupleIsFake</span><span class="p">(</span><span class="n">tuplesList</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>


<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Database</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Database</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">communicateDatabase</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="o">&amp;</span><span class="n">unions</span><span class="w"></span>
<span class="w">      </span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="w"></span>
<span class="w">      </span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">ABCTuple</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Database</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:comm:type:do&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="n">MPI_LDB_ELEMENT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">mpi</span><span class="o">::</span><span class="n">localDatabaseElement</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:comm:ldb&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">LocalDatabase</span><span class="w"> </span><span class="n">ldb</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tensor</span><span class="o">:</span><span class="w"> </span><span class="n">unions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tensorDb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tensor</span><span class="o">-&gt;</span><span class="n">buildLocalDatabase</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">ldb</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ldb</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">tensorDb</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">tensorDb</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">Database</span><span class="w"> </span><span class="n">db</span><span class="p">(</span><span class="n">np</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ldb</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">ldb</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;oneshot-db:comm:allgather&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:comm:allgather&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">MPI_Allgather</span><span class="p">(</span><span class="w"> </span><span class="n">ldb</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                       </span><span class="p">,</span><span class="w"> </span><span class="n">ldb</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">                       </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_LDB_ELEMENT</span><span class="w"></span>
<span class="w">                       </span><span class="p">,</span><span class="w"> </span><span class="n">db</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                       </span><span class="p">,</span><span class="w"> </span><span class="n">ldb</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">                       </span><span class="p">,</span><span class="w"> </span><span class="n">MPI_LDB_ELEMENT</span><span class="w"></span>
<span class="w">                       </span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">))</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:comm:type:free&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">MPI_Type_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MPI_LDB_ELEMENT</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">db</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">doIOPhase</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">unions</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">universe</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">Database</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">localDBLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">db</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sendTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">recvTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localDBLength</span><span class="w"></span>
<span class="w">         </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// RECIEVE PHASE ======================================================</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// At this point, we have already send to everyone that fits</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">db</span><span class="p">[</span><span class="n">rank</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localDBLength</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">localDBLength</span><span class="w"></span>
<span class="w">                </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">recvTag</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unionByName</span><span class="p">(</span><span class="n">unions</span><span class="p">,</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;:r&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;♯&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">recvTag</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; =&gt;&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; «n&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">name</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, t&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, s&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;»&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ⊙ {&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;⇐&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ∴ {&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">          </span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:io:recv&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">u</span><span class="p">.</span><span class="n">receive</span><span class="p">(</span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">recvTag</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="c1">// recv</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// SEND PHASE =========================================================</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">otherRank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">otherRank</span><span class="o">&lt;</span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">otherRank</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">db</span><span class="p">[</span><span class="n">otherRank</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localDBLength</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">localDBLength</span><span class="w"></span>
<span class="w">                </span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">sendTag</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">typename</span><span class="w"> </span><span class="nc">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">LocalDatabaseElement</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unionByName</span><span class="p">(</span><span class="n">unions</span><span class="p">,</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_DBG</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;:s&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;♯&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sendTag</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; =&gt;&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; «n&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">name</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, t&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, s&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;»&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ⊙ {&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;⇒&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">otherRank</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">from</span><span class="p">.</span><span class="n">source</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; ∴ {&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">el</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">          </span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:io:send&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">u</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">otherRank</span><span class="p">,</span><span class="w"> </span><span class="n">el</span><span class="p">,</span><span class="w"> </span><span class="n">sendTag</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="c1">// send phase</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// otherRank</span>


<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="cp">#if defined(HAVE_OCD) || defined(ATRIP_PRINT_TUPLES)</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">ABCTuple</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tupleEnergies</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">doublesFlops</span><span class="w"></span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="n">No</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="n">No</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="n">No</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="n">No</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="n">Nv</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">traits</span><span class="o">::</span><span class="n">isComplex</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="w"> </span><span class="mf">6.0</span><span class="w"></span>
<span class="w">    </span><span class="o">/</span><span class="w"> </span><span class="mf">1e9</span><span class="w"></span>
<span class="w">    </span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// START MAIN LOOP ======================================================{{{1</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="nf">energy</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tuplesList</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">iteration</span><span class="o">++</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">[</span><span class="s">&quot;iterations&quot;</span><span class="p">].</span><span class="n">start</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// check overhead from chrono over all iterations</span>
<span class="w">    </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;start:stop&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{})</span><span class="w"></span>

<span class="w">    </span><span class="c1">// check overhead of doing a barrier at the beginning</span>
<span class="w">    </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;oneshot-mpi:barrier&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;mpi:barrier&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">barrier</span><span class="p">)</span><span class="w"> </span><span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iteration</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">iterationMod</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">iteration1Percent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IterationDescription</span><span class="o">::</span><span class="n">descriptor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">IterationDescription</span><span class="o">::</span><span class="n">descriptor</span><span class="p">({</span><span class="w"></span>
<span class="w">          </span><span class="n">iteration</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">nIterations</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">[</span><span class="s">&quot;iterations&quot;</span><span class="p">].</span><span class="n">count</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;iteration &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nIterations</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;%]&quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">doublesFlops</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">[</span><span class="s">&quot;doubles&quot;</span><span class="p">].</span><span class="n">count</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;GF)&quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">doublesFlops</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">[</span><span class="s">&quot;iterations&quot;</span><span class="p">].</span><span class="n">count</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;GF)&quot;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>


<span class="w">      </span><span class="c1">// PRINT TIMINGS</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">chrono</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pair</span><span class="o">:</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">LOG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :: &quot;</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">count</span><span class="p">()</span><span class="w"></span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">ABCTuple</span><span class="w"> </span><span class="n">abc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isFakeTuple</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">                       </span><span class="o">?</span><span class="w"> </span><span class="n">tuplesList</span><span class="p">[</span><span class="n">tuplesList</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">                       </span><span class="o">:</span><span class="w"> </span><span class="n">tuplesList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"></span>
<span class="w">                 </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">abcNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">tuplesList</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="o">?</span><span class="w"> </span><span class="k">nullptr</span><span class="w"></span>
<span class="w">                            </span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tuplesList</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">                 </span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;with_rank&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :it &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :abc &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :abcN &quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">abcNext</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="o">*</span><span class="n">abcNext</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;None&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>


<span class="w">    </span><span class="c1">// COMM FIRST DATABASE ================================================{{{1</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__first__:first database ............ </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">communicateDatabase</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__first__:first database communicated </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__first__:first database io phase </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">doIOPhase</span><span class="p">(</span><span class="n">db</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__first__:first database io phase DONE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__first__::::Unwrapping all slices for first database</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">u</span><span class="o">:</span><span class="w"> </span><span class="n">unions</span><span class="p">)</span><span class="w"> </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">unwrapAll</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__first__::::Unwrapping slices for first database DONE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// COMM NEXT DATABASE ================================================={{{1</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">abcNext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__comm__:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;th communicating database</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:comm&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">communicateDatabase</span><span class="p">(</span><span class="o">*</span><span class="n">abcNext</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;db:io&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">doIOPhase</span><span class="p">(</span><span class="n">db</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__comm__:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;th database io phase DONE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// COMPUTE DOUBLES ===================================================={{{1</span>
<span class="w">    </span><span class="n">OCD_Barrier</span><span class="p">(</span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isFakeTuple</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-th doubles</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;oneshot-unwrap&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;unwrap&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;unwrap:doubles&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">u</span><span class="o">:</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">unions</span><span class="p">){</span><span class="o">&amp;</span><span class="n">abph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hhha</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">taphh</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tabhh</span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">unwrapAll</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">)))</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;oneshot-doubles&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;doubles&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">doublesContribution</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">Nv</span><span class="w"></span>
<span class="w">                              </span><span class="c1">// -- VABCI</span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">abph</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AB</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">abph</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AC</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">abph</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BC</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">abph</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BA</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">abph</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">CA</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">abph</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">CB</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="c1">// -- VHHHA</span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">hhha</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">hhha</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">hhha</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="c1">// -- TA</span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">taphh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">taphh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">taphh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="c1">// -- TABIJ</span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">tabhh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AB</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">tabhh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AC</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">tabhh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BC</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                              </span><span class="c1">// -- TIJK</span>
<span class="w">                              </span><span class="p">,</span><span class="w"> </span><span class="n">Tijk</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                              </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-th doubles done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// COMPUTE SINGLES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% {{{1</span>
<span class="w">    </span><span class="n">OCD_Barrier</span><span class="p">(</span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isFakeTuple</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;oneshot-unwrap&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;unwrap&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;unwrap:singles&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">abhh</span><span class="p">.</span><span class="n">unwrapAll</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">)))</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;reorder&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Zijk</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">I</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">Zijk</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tijk</span><span class="p">[</span><span class="n">I</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;singles&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">singlesContribution</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">No</span><span class="p">,</span><span class="w"> </span><span class="n">Nv</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="w"></span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">Tai</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"></span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">abhh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AB</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">abhh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">AC</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">abhh</span><span class="p">.</span><span class="n">unwrapSlice</span><span class="p">(</span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">BC</span><span class="p">,</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">Zijk</span><span class="p">.</span><span class="n">data</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>


<span class="w">    </span><span class="c1">// COMPUTE ENERGY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% {{{1</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isFakeTuple</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="nf">tupleEnergy</span><span class="p">(</span><span class="mf">0.</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="nf">distinct</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="n">distinct</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="n">distinct</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="nf">epsabc</span><span class="p">(</span><span class="n">epsa</span><span class="p">[</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">epsa</span><span class="p">[</span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">epsa</span><span class="p">[</span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]]);</span><span class="w"></span>

<span class="w">      </span><span class="n">WITH_CHRONO</span><span class="p">(</span><span class="s">&quot;energy&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">distinct</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">tupleEnergy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getEnergyDistinct</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">epsabc</span><span class="p">,</span><span class="w"> </span><span class="n">epsi</span><span class="p">,</span><span class="w"> </span><span class="n">Tijk</span><span class="p">,</span><span class="w"> </span><span class="n">Zijk</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">tupleEnergy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getEnergySame</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">epsabc</span><span class="p">,</span><span class="w"> </span><span class="n">epsi</span><span class="p">,</span><span class="w"> </span><span class="n">Tijk</span><span class="p">,</span><span class="w"> </span><span class="n">Zijk</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"></span>

<span class="cp">#if defined(HAVE_OCD) || defined(ATRIP_PRINT_TUPLES)</span>
<span class="w">      </span><span class="n">tupleEnergies</span><span class="p">[</span><span class="n">abc</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tupleEnergy</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">      </span><span class="n">energy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">tupleEnergy</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// TODO: remove this</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isFakeTuple</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// fake iterations should also unwrap whatever they got</span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;th unwrapping because of fake in &quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">u</span><span class="o">:</span><span class="w"> </span><span class="n">unions</span><span class="p">)</span><span class="w"> </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">unwrapAll</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">u</span><span class="o">:</span><span class="w"> </span><span class="n">unions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__dups__:&quot;</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"></span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-th n&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; checking duplicates</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">checkForDuplicates</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>


<span class="w">    </span><span class="c1">// CLEANUP UNIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{1</span>
<span class="w">    </span><span class="n">OCD_Barrier</span><span class="p">(</span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">abcNext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__gc__:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-th cleaning up.......</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">u</span><span class="o">:</span><span class="w"> </span><span class="n">unions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">unwrapAll</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__gc__:n&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">name</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :it &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :abc &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; :abcN &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="o">*</span><span class="n">abcNext</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// for (auto const&amp; slice: u-&gt;slices)</span>
<span class="w">        </span><span class="c1">//   WITH_RANK &lt;&lt; &quot;__gc__:guts:&quot; &lt;&lt; slice.info &lt;&lt; &quot;\n&quot;;</span>
<span class="w">        </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">clearUnusedSlicesForNext</span><span class="p">(</span><span class="o">*</span><span class="n">abcNext</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;__gc__: checking validity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="cp">#ifdef HAVE_OCD</span>
<span class="w">        </span><span class="c1">// check for validity of the slices</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sliceTypes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">subtupleBySlice</span><span class="p">(</span><span class="n">abc</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">slice</span><span class="o">:</span><span class="w"> </span><span class="n">u</span><span class="o">-&gt;</span><span class="n">slices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">type</span><span class="w"></span>
<span class="w">             </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">tuple</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tuple</span><span class="w"></span>
<span class="w">             </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">isDirectlyFetchable</span><span class="p">()</span><span class="w"></span>
<span class="w">             </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">.</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Slice</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">Dispatched</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;This slice should not be undispatched! &quot;</span><span class="w"></span>
<span class="w">                                     </span><span class="o">+</span><span class="w"> </span><span class="n">pretty_print</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">info</span><span class="p">));</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>


<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-th cleaning up....... DONE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">[</span><span class="s">&quot;iterations&quot;</span><span class="p">].</span><span class="n">stop</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ITERATION END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{1</span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// END OF MAIN LOOP</span>

<span class="w">  </span><span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">universe</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// PRINT TUPLES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{1</span>
<span class="cp">#if defined(HAVE_OCD) || defined(ATRIP_PRINT_TUPLES)</span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;tuple energies&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">np</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">universe</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pair</span><span class="o">:</span><span class="w"> </span><span class="n">tupleEnergies</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rank</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; tupleEnergy: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="w"></span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"></span>
<span class="w">                  </span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="c1">// COMMUNICATE THE ENERGIES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%{{{1</span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;COMMUNICATING ENERGIES </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">globalEnergy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MPI_Reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">energy</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">globalEnergy</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_DOUBLE</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_SUM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">universe</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">WITH_RANK</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;local energy &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">energy</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Atrip&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Energy: &quot;</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="w"> </span><span class="n">globalEnergy</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// PRINT TIMINGS {{{1</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">chrono</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pair</span><span class="o">:</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;atrip:chrono&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"></span>
<span class="w">                          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>


<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atrip:flops(doubles)&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nIterations</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">doublesFlops</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">[</span><span class="s">&quot;doubles&quot;</span><span class="p">].</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;atrip:flops(iterations)&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">nIterations</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">doublesFlops</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">chrono</span><span class="p">[</span><span class="s">&quot;iterations&quot;</span><span class="p">].</span><span class="n">count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// TODO: change the sign in  the getEnergy routines</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">globalEnergy</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
<span class="c1">// instantiate</span>
<span class="k">template</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">Output</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">Input</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="n">Atrip</span><span class="o">::</span><span class="n">Output</span><span class="w"> </span><span class="nf">Atrip::run</span><span class="p">(</span><span class="n">Atrip</span><span class="o">::</span><span class="n">Input</span><span class="o">&lt;</span><span class="n">Complex</span><span class="o">&gt;</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="debug-and-logging">
<h2><a class="toc-backref" href="#id39">11 Debug and Logging</a><a class="headerlink" href="#debug-and-logging" title="Permalink to this headline">¶</a></h2>
<section id="macros">
<h3><a class="toc-backref" href="#id40">11.1 Macros</a><a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<span class="cp">#define ATRIP_BENCHMARK</span>
<span class="c1">//#define ATRIP_DONT_SLICE</span>
<span class="cp">#ifndef ATRIP_DEBUG</span>
<span class="cp">#  define ATRIP_DEBUG 1</span>
<span class="cp">#endif</span>
<span class="c1">//#define ATRIP_WORKLOAD_DUMP</span>
<span class="cp">#define ATRIP_USE_DGEMM</span>
<span class="c1">//#define ATRIP_PRINT_TUPLES</span>

<span class="cp">#ifndef ATRIP_DEBUG</span>
<span class="cp">#define ATRIP_DEBUG 1</span>
<span class="cp">#endif</span>

<span class="cp">#if ATRIP_DEBUG == 4</span>
<span class="cp">#  pragma message(&quot;WARNING: You have OCD debugging ABC triples &quot;    \</span>
<span class="cp">                  &quot;expect GB of output and consult your therapist&quot;)</span>
<span class="cp">#</span><span class="w">  </span><span class="cp">include</span><span class="w"> </span><span class="cpf">&lt;dbg.h&gt;</span><span class="cp"></span>
<span class="cp">#  define HAVE_OCD</span>
<span class="cp">#  define OCD_Barrier(com) MPI_Barrier(com)</span>
<span class="cp">#  define WITH_OCD</span>
<span class="cp">#  define WITH_ROOT if (atrip::Atrip::rank == 0)</span>
<span class="cp">#  define WITH_SPECIAL(r) if (atrip::Atrip::rank == r)</span>
<span class="cp">#  define WITH_RANK std::cout &lt;&lt; atrip::Atrip::rank &lt;&lt; &quot;: &quot;</span>
<span class="cp">#  define WITH_CRAZY_DEBUG</span>
<span class="cp">#  define WITH_DBG</span>
<span class="cp">#  define DBG(...) dbg(__VA_ARGS__)</span>
<span class="cp">#elif ATRIP_DEBUG == 3</span>
<span class="cp">#  pragma message(&quot;WARNING: You have crazy debugging ABC triples,&quot;  \</span>
<span class="cp">                  &quot; expect GB of output&quot;)</span>
<span class="cp">#</span><span class="w">  </span><span class="cp">include</span><span class="w"> </span><span class="cpf">&lt;dbg.h&gt;</span><span class="cp"></span>
<span class="cp">#  define OCD_Barrier(com)</span>
<span class="cp">#  define WITH_OCD if (false)</span>
<span class="cp">#  define WITH_ROOT if (atrip::Atrip::rank == 0)</span>
<span class="cp">#  define WITH_SPECIAL(r) if (atrip::Atrip::rank == r)</span>
<span class="cp">#  define WITH_RANK std::cout &lt;&lt; atrip::Atrip::rank &lt;&lt; &quot;: &quot;</span>
<span class="cp">#  define WITH_CRAZY_DEBUG</span>
<span class="cp">#  define WITH_DBG</span>
<span class="cp">#  define DBG(...) dbg(__VA_ARGS__)</span>
<span class="cp">#elif ATRIP_DEBUG == 2</span>
<span class="cp">#  pragma message(&quot;WARNING: You have some debugging info for ABC triples&quot;)</span>
<span class="cp">#  define OCD_Barrier(com)</span>
<span class="cp">#  define WITH_OCD if (false)</span>
<span class="cp">#  define WITH_ROOT if (atrip::Atrip::rank == 0)</span>
<span class="cp">#  define WITH_SPECIAL(r) if (atrip::Atrip::rank == r)</span>
<span class="cp">#  define WITH_RANK std::cout &lt;&lt; atrip::Atrip::rank &lt;&lt; &quot;: &quot;</span>
<span class="cp">#  define WITH_CRAZY_DEBUG if (false)</span>
<span class="cp">#  define WITH_DBG</span>
<span class="cp">#  define DBG(...) dbg(__VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#  define OCD_Barrier(com)</span>
<span class="cp">#  define WITH_OCD if (false)</span>
<span class="cp">#  define WITH_ROOT if (false)</span>
<span class="cp">#  define WITH_SPECIAL(r) if (false)</span>
<span class="cp">#  define WITH_RANK if (false) std::cout &lt;&lt; atrip::Atrip::rank &lt;&lt; &quot;: &quot;</span>
<span class="cp">#  define WITH_DBG if (false)</span>
<span class="cp">#  define WITH_CRAZY_DEBUG if (false)</span>
<span class="cp">#  define DBG(...)</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>And users of the library can redefine the <code class="docutils literal notranslate"><span class="pre">LOG</span></code> macro
which in case of not being defined is defined as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef LOG</span>
<span class="cp">#define LOG(level, name) if (Atrip::rank == 0) std::cout &lt;&lt; name &lt;&lt; &quot;: &quot;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Furthermore, if you do not wish to see any output from ATRIP, simply
define <code class="docutils literal notranslate"><span class="pre">ATRIP_NO_OUTPUT</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef ATRIP_NO_OUTPUT</span>
<span class="cp">#  undef LOG</span>
<span class="cp">#  define LOG(level, name) if (false) std::cout &lt;&lt; name &lt;&lt; &quot;: &quot;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="iteration-informer">
<h3><a class="toc-backref" href="#id41">11.2 Iteration informer</a><a class="headerlink" href="#iteration-informer" title="Permalink to this headline">¶</a></h3>
<p>In general a code writer will want to write some messages in every iteration.
A developer then can register a function to be used in this sense.
The input of the function is an <a class="reference internal" href="#iterationdescriptor">IterationDescriptor</a> structure and the output
should be nothing.</p>
<div class="highlight-c++ notranslate" id="iterationdescriptor"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">atrip</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">IterationDescription</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">IterationDescriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">IterationDescription</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">IterationDescription</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">IterationDescriptor</span><span class="w"> </span><span class="n">descriptor</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">currentIteration</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">totalIterations</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">currentElapsedTime</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">registerIterationDescriptor</span><span class="p">(</span><span class="n">IterationDescriptor</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="include-header">
<h2><a class="toc-backref" href="#id42">12 Include header</a><a class="headerlink" href="#include-header" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atrip/Atrip.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">ATRIP: An MPI-asynchronous implementation of CCSD(T)</a><ul>
<li><a class="reference internal" href="#introduction">1 Introduction</a></li>
<li><a class="reference internal" href="#the-slice">2 The slice</a><ul>
<li><a class="reference internal" href="#id1">2.1 Introduction</a></li>
<li><a class="reference internal" href="#location">2.2 Location</a></li>
<li><a class="reference internal" href="#type">2.3 Type</a></li>
<li><a class="reference internal" href="#state">2.4 State</a></li>
<li><a class="reference internal" href="#the-info-structure">2.5 The Info structure</a></li>
<li><a class="reference internal" href="#name">2.6 Name</a></li>
<li><a class="reference internal" href="#database">2.7 Database</a></li>
<li><a class="reference internal" href="#mpi-types">2.8 MPI Types</a></li>
<li><a class="reference internal" href="#static-utilities">2.9 Static utilities</a></li>
<li><a class="reference internal" href="#attributes">2.10 Attributes</a></li>
<li><a class="reference internal" href="#member-functions">2.11 Member functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#utils">3 Utils</a><ul>
<li><a class="reference internal" href="#pretty-printing">3.1 Pretty printing</a></li>
<li><a class="reference internal" href="#chrono">3.2 Chrono</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-rank-mapping">4 The rank mapping</a></li>
<li><a class="reference internal" href="#the-slice-union">5 The slice union</a></li>
<li><a class="reference internal" href="#tuples">6 Tuples</a><ul>
<li><a class="reference internal" href="#tuples-types">6.1 Tuples types</a></li>
<li><a class="reference internal" href="#distributing-the-tuples">6.2 Distributing the tuples</a></li>
<li><a class="reference internal" href="#node-information">6.3 Node information</a></li>
<li><a class="reference internal" href="#naive-list">6.4 Naive list</a></li>
<li><a class="reference internal" href="#group-and-sort-list">6.5 Group and sort list</a><ul>
<li><a class="reference internal" href="#id2">6.5.1 Utils</a></li>
<li><a class="reference internal" href="#distribution">6.5.2 Distribution</a></li>
<li><a class="reference internal" href="#main">6.5.3 Main</a></li>
<li><a class="reference internal" href="#interface">6.5.4 Interface</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#unions">7 Unions</a></li>
<li><a class="reference internal" href="#equations">8 Equations</a></li>
<li><a class="reference internal" href="#blas">9 Blas</a></li>
<li><a class="reference internal" href="#atrip">10 Atrip</a><ul>
<li><a class="reference internal" href="#header">10.1 Header</a></li>
<li><a class="reference internal" href="#id3">10.2 Main</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debug-and-logging">11 Debug and Logging</a><ul>
<li><a class="reference internal" href="#macros">11.1 Macros</a></li>
<li><a class="reference internal" href="#iteration-informer">11.2 Iteration informer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#include-header">12 Include header</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="index.html"
                          title="previous chapter">ATRIP: An MPI-asynchronous implementation of CCSD(T)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/atrip.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="ATRIP: An MPI-asynchronous implementation of CCSD(T)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Atrip  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ATRIP: An MPI-asynchronous implementation of CCSD(T)</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1980, Alejandro Gallo.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>