<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-10-13 Wed 13:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ATRIP: An MPI-asynchronous implementation of CCSD(T)</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">ATRIP: An MPI-asynchronous implementation of CCSD(T)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org091893b">1. Implementation</a>
<ul>
<li><a href="#orgaa29036">1.1. The slice</a></li>
<li><a href="#org5f2200f">1.2. Utils</a></li>
<li><a href="#org3e490ce">1.3. The rank mapping</a></li>
<li><a href="#orgd818af6">1.4. The slice union</a></li>
<li><a href="#orga058e69">1.5. Tuples</a></li>
<li><a href="#org69680bd">1.6. Unions</a></li>
<li><a href="#orgfccf67b">1.7. Equations</a></li>
<li><a href="#org174086a">1.8. Blas</a></li>
<li><a href="#org51e9818">1.9. Atrip</a>
<ul>
<li><a href="#orgfe5d2c3">1.9.1. Main</a></li>
</ul>
</li>
<li><a href="#orgefe0704">1.10. Debug</a></li>
<li><a href="#orgaaf4662">1.11. Include header</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org091893b" class="outline-2">
<h2 id="org091893b"><span class="section-number-2">1</span> Implementation</h2>
<div class="outline-text-2" id="text-1">
<p>
The algorithm uses two main data types, the <code>Slice</code> and the
<code>SliceUnion</code> as a container and resource manager of the <code>Slice</code>.
</p>
</div>

<div id="outline-container-orgaa29036" class="outline-3">
<h3 id="orgaa29036"><span class="section-number-3">1.1</span> The slice</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;iostream&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;algorithm&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;vector&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;mpi.h&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Tuples.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Utils.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {


<span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Slice</span> {

  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">F</span> = <span style="color: #c18401;">double</span>;
</pre>
</div>

<p>
A slice is the concept of a subset of values of a given tensor.
As an example, for the doubles amplitudes \( T^{ab}_{ij} \), one need two kinds of objects:
</p>
<ul class="org-ul">
<li>the object \( \mathsf{T}(a)^b_{ij} \) which for every \( a \) gets assigned the
tensor \( T^{ab}_{ij} \) of size \( N_\mathrm{o}^2 \times N_\mathrm{v} \)</li>

<li>the object \( \mathsf{T}(a,b)_{ij} \) which for every pair of \( a, b \)
corresponds the \( N_\mathrm{o}^2 \)-sized tensor \( T^{ab}_{ij} \).</li>
</ul>



<div class="org-src-container">
<pre class="src src-c++">  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ASSOCIATED TYPES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Location</span> { <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>; <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">source</span>; };

  <span style="color: #a626a4;">enum</span> <span style="color: #c18401;">Type</span>
    { <span style="color: #8b4513;">A</span> = 10
    , <span style="color: #8b4513;">B</span>
    , <span style="color: #8b4513;">C</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Two-parameter slices</span>
    , <span style="color: #8b4513;">AB</span> = 20
    , <span style="color: #8b4513;">BC</span>
    , <span style="color: #8b4513;">AC</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for abci and the doubles</span>
    , <span style="color: #8b4513;">CB</span>
    , <span style="color: #8b4513;">BA</span>
    , <span style="color: #8b4513;">CA</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">The non-typed slice</span>
    , <span style="color: #8b4513;">Blank</span> = 404
    };

  <span style="color: #a626a4;">enum</span> <span style="color: #c18401;">State</span> {
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Fetch represents the state where a slice is to be fetched</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">and has a valid data pointer that can be written to</span>
    <span style="color: #8b4513;">Fetch</span> = 0,
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Dispatches represents the state that an MPI call has been</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">dispatched in order to get the data, but the data has not been</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">yet unwrapped, the data might be there or we might have to wait.</span>
    <span style="color: #8b4513;">Dispatched</span> = 2,
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Ready means that the data pointer can be read from</span>
    <span style="color: #8b4513;">Ready</span> = 1,
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Self sufficient is a slice when its contents are located</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">in the same rank that it lives, so that it does not have to</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">fetch from no one else.</span>
    <span style="color: #8b4513;">SelfSufficient</span> = 911,
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Recycled means that this slice gets its data pointer from another</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">slice, so it should not be written to</span>
    <span style="color: #8b4513;">Recycled</span> = 123,
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Acceptor means that the Slice can accept a new Slice, it is</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">the counterpart of the Blank type, but for states</span>
    <span style="color: #8b4513;">Acceptor</span> = 405
  };

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Info</span> {
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">which part of a,b,c the slice holds</span>
    <span style="color: #c18401;">PartialTuple</span> <span style="color: #8b4513;">tuple</span>;
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">The type of slice for the user to retrieve the correct one</span>
    <span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>;
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">What is the state of the slice</span>
    <span style="color: #c18401;">State</span> <span style="color: #8b4513;">state</span>;
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Where the slice is to be retrieved</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">NOTE: this can actually be computed from tuple</span>
    <span style="color: #c18401;">Location</span> <span style="color: #8b4513;">from</span>;
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">If the data are actually to be found in this other slice</span>
    <span style="color: #c18401;">Type</span> <span style="color: #8b4513;">recycling</span>;

    <span style="color: #0184bc;">Info</span>() : tuple{0,0}
           , type{Blank}
           , state{Acceptor}
           , from{0,0}
           , recycling{Blank}
           {}
  };

  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Ty_x_Tu</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">pair</span>&lt; <span style="color: #c18401;">Type</span>, <span style="color: #c18401;">PartialTuple</span> &gt;;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Names of the integrals that are considered in CCSD(T)</span>
  <span style="color: #a626a4;">enum</span> <span style="color: #c18401;">Name</span>
    { <span style="color: #8b4513;">TA</span>    = 100
    , <span style="color: #8b4513;">VIJKA</span> = 101
    , <span style="color: #8b4513;">VABCI</span> = 200
    , <span style="color: #8b4513;">TABIJ</span> = 201
    , <span style="color: #8b4513;">VABIJ</span> = 202
    };

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">DATABASE ==========================================================={{{1</span>
  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">LocalDatabaseElement</span> {
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name</span>;
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #8b4513;">info</span>;
  };
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">LocalDatabase</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">LocalDatabaseElement</span>&gt;;
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Database</span> = LocalDatabase;


    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">STATIC METHODS ===========================================================</span>
    <span style="color: #a0a1a7; font-weight: bold;">//</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">They are useful to organize the structure of slices</span>

    <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">mpi</span> {

      <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">vector</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span>, <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">DT</span>) {
        <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
        MPI_Type_vector(n, 1, 1, DT, &amp;dt);
        MPI_Type_commit(&amp;dt);
        <span style="color: #a626a4;">return</span> dt;
      }

      <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">sliceLocation</span> () {
        <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span> = 2;
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">create a sliceLocation to measure in the current architecture</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">the packing of the struct</span>
        <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Location</span> <span style="color: #8b4513;">measure</span>;
        <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
        <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">lengths</span>(n, 1);
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">types</span>[n] = {usizeDt(), usizeDt()};

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">measure the displacements in the struct</span>
        <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0;
        <span style="color: #c18401;">MPI_Aint</span> <span style="color: #8b4513;">displacements</span>[n];
        MPI_Get_address(&amp;measure.rank,   &amp;displacements[j++]);
        MPI_Get_address(&amp;measure.source, &amp;displacements[j++]);
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; n; i++) displacements[i] -= displacements[0];
        displacements[0] = 0;

        MPI_Type_create_struct(n, lengths.data(), displacements, types, &amp;dt);
        MPI_Type_commit(&amp;dt);
        <span style="color: #a626a4;">return</span> dt;
      }

      <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">enumDt</span>() { <span style="color: #a626a4;">return</span> MPI_INT; }
      <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">usizeDt</span>() { <span style="color: #a626a4;">return</span> MPI_UINT64_T; }

      <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">sliceInfo</span> () {
        <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span> = 5;
        <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
        <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #8b4513;">measure</span>;
        <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">lengths</span>(n, 1);
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">types</span>[n]
          = { vector(2, <span style="color: #c18401;">usizeDt</span>())
            , enumDt()
            , enumDt()
            , sliceLocation()
            , enumDt()
            };

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">create the displacements from the info measurement struct</span>
        <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0;
        <span style="color: #c18401;">MPI_Aint</span> <span style="color: #8b4513;">displacements</span>[n];
        MPI_Get_address(measure.tuple.data(), &amp;displacements[j++]);
        MPI_Get_address(&amp;measure.type,        &amp;displacements[j++]);
        MPI_Get_address(&amp;measure.state,       &amp;displacements[j++]);
        MPI_Get_address(&amp;measure.from,        &amp;displacements[j++]);
        MPI_Get_address(&amp;measure.recycling,   &amp;displacements[j++]);
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; n; i++) displacements[i] -= displacements[0];
        displacements[0] = 0;

        MPI_Type_create_struct(n, lengths.data(), displacements, types, &amp;dt);
        MPI_Type_commit(&amp;dt);
        <span style="color: #a626a4;">return</span> dt;
      }

      <span style="color: #a626a4;">static</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #0184bc;">localDatabaseElement</span> () {
        <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">n</span> = 2;
        <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">dt</span>;
        <span style="color: #c18401;">LocalDatabaseElement</span> <span style="color: #8b4513;">measure</span>;
        <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">lengths</span>(n, 1);
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Datatype</span> <span style="color: #8b4513;">types</span>[n]
          = { enumDt()
            , sliceInfo()
            };

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">measure the displacements in the struct</span>
        <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0;
        <span style="color: #c18401;">MPI_Aint</span> <span style="color: #8b4513;">displacements</span>[n];
        MPI_Get_address(&amp;measure.name, &amp;displacements[j++]);
        MPI_Get_address(&amp;measure.info, &amp;displacements[j++]);
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; n; i++) displacements[i] -= displacements[0];
        displacements[0] = 0;

        MPI_Type_create_struct(n, lengths.data(), displacements, types, &amp;dt);
        MPI_Type_commit(&amp;dt);
        <span style="color: #a626a4;">return</span> dt;
      }

    };

  <span style="color: #a626a4;">static</span>
  <span style="color: #c18401;">PartialTuple</span> <span style="color: #0184bc;">subtupleBySlice</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">abc</span>, <span style="color: #c18401;">Type</span> <span style="color: #8b4513;">sliceType</span>) {
    <span style="color: #a626a4;">switch</span> (sliceType) {
      <span style="color: #a626a4;">case</span> AB: <span style="color: #a626a4;">return</span> {abc[0], abc[1]};
      <span style="color: #a626a4;">case</span> BC: <span style="color: #a626a4;">return</span> {abc[1], abc[2]};
      <span style="color: #a626a4;">case</span> AC: <span style="color: #a626a4;">return</span> {abc[0], abc[2]};
      <span style="color: #a626a4;">case</span> CB: <span style="color: #a626a4;">return</span> {abc[2], abc[1]};
      <span style="color: #a626a4;">case</span> BA: <span style="color: #a626a4;">return</span> {abc[1], abc[0]};
      <span style="color: #a626a4;">case</span> CA: <span style="color: #a626a4;">return</span> {abc[2], abc[0]};
      <span style="color: #a626a4;">case</span>  A: <span style="color: #a626a4;">return</span> {abc[0], 0};
      <span style="color: #a626a4;">case</span>  B: <span style="color: #a626a4;">return</span> {abc[1], 0};
      <span style="color: #a626a4;">case</span>  C: <span style="color: #a626a4;">return</span> {abc[2], 0};
      <span style="color: #a626a4;">default</span>: <span style="color: #a626a4;">throw</span> <span style="color: #50a14f;">"Switch statement not exhaustive!"</span>;
    }
  }


    <span style="color: #50a14f; font-style: italic;">/**</span>
<span style="color: #50a14f; font-style: italic;">     * It is important here to return a reference to a Slice</span>
<span style="color: #50a14f; font-style: italic;">     * not to accidentally copy the associated buffer of the slice.</span>
<span style="color: #50a14f; font-style: italic;">     */</span>
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp; <span style="color: #0184bc;">findOneByType</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>) {
        <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
          = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                         [&amp;<span style="color: #8b4513;">type</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                           <span style="color: #a626a4;">return</span> type == s.info.type;
                         });
        <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
        <span style="color: #8b4513;">WITH_RANK</span>
          &lt;&lt; <span style="color: #50a14f;">"\t__ looking for "</span> &lt;&lt; type &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
          <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Slice by type not found!"</span>);
        <span style="color: #a626a4;">return</span> *sliceIt;
    }

    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * Check if an info has</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #a626a4;">static</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>*&gt; <span style="color: #0184bc;">hasRecycledReferencingToIt</span>
      ( <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>
      , <span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>
      ) {
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>*&gt; <span style="color: #8b4513;">result</span>;

      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">s</span>: slices)
        <span style="color: #a626a4;">if</span> (  s.info.recycling == info.type
           &amp;&amp; s.info.tuple == info.tuple
           &amp;&amp; s.info.state == Recycled
           ) result.push_back(&amp;s);

      <span style="color: #a626a4;">return</span> result;
    }

    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp;
    <span style="color: #0184bc;">findRecycledSource</span> (<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #8b4513;">info</span>) {
      <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
        = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                       [&amp;<span style="color: #8b4513;">info</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                         <span style="color: #a626a4;">return</span> info.recycling == s.info.type
                             &amp;&amp; info.tuple == s.info.tuple
                             &amp;&amp; <span style="font-weight: bold; text-decoration: underline;">State</span>::Recycled != s.info.state
                             ;
                       });

      <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
      <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__slice__:find: recycling source of "</span>
                &lt;&lt; pretty_print(info) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
        <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"Slice not found: "</span>
                               + pretty_print(info)
                               + <span style="color: #50a14f;">" rank: "</span>
                               + pretty_print(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank)
                               );
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__slice__:find: "</span> &lt;&lt; pretty_print(sliceIt-&gt;info) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">return</span> *sliceIt;
    }

    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp; <span style="color: #0184bc;">findByTypeAbc</span>
      ( <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>
      , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>
      , <span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>
      ) {
        <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, type);
        <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
          = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                         [&amp;<span style="color: #8b4513;">type</span>, &amp;<span style="color: #8b4513;">tuple</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                           <span style="color: #a626a4;">return</span> type == s.info.type
                               &amp;&amp; tuple == s.info.tuple
                               ;
                         });
        <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
        <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__slice__:find:"</span> &lt;&lt; type &lt;&lt; <span style="color: #50a14f;">" and tuple "</span>
                  &lt;&lt; pretty_print(tuple)
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
          <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"Slice not found: "</span>
                                 + pretty_print(tuple)
                                 + <span style="color: #50a14f;">", "</span>
                                 + pretty_print(type)
                                 + <span style="color: #50a14f;">" rank: "</span>
                                 + pretty_print(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank)
                                 );
        <span style="color: #a626a4;">return</span> *sliceIt;
    }

    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">Slice</span>&amp; <span style="color: #0184bc;">findByInfo</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">Slice</span>&gt; &amp;<span style="color: #8b4513;">slices</span>,
                             <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>) {
        <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceIt</span>
          = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                         [&amp;<span style="color: #8b4513;">info</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>) {
                           <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: maybe implement comparison in Info struct</span>
                           <span style="color: #a626a4;">return</span> info.type == s.info.type
                               &amp;&amp; info.state == s.info.state
                               &amp;&amp; info.tuple == s.info.tuple
                               &amp;&amp; info.from.rank == s.info.from.rank
                               &amp;&amp; info.from.source == s.info.from.source
                                ;
                         });
        <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
        <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__slice__:find:looking for "</span> &lt;&lt; pretty_print(info) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        <span style="color: #a626a4;">if</span> (sliceIt == slices.end())
          <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"Slice by info not found: "</span>
                                 + pretty_print(info));
        <span style="color: #a626a4;">return</span> *sliceIt;
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">SLICE DEFINITION  =================================================={{{1</span>

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ATTRIBUTES ============================================================</span>
    <span style="color: #c18401;">Info</span> <span style="color: #8b4513;">info</span>;
    <span style="color: #c18401;">F</span>  *<span style="color: #8b4513;">data</span>;
    <span style="color: #c18401;">MPI_Request</span> <span style="color: #8b4513;">request</span>;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">size</span>;

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">markReady</span>() <span style="color: #a626a4;">noexcept</span> {
      info.state = Ready;
      info.recycling = Blank;
    }

    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * This means that the data is there</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isUnwrapped</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> info.state == Ready
          || info.state == SelfSufficient
          ;
    }

    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isUnwrappable</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> isUnwrapped()
          || info.state == Recycled
          || info.state == Dispatched
          ;
    }

    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isDirectlyFetchable</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> info.state == Ready || info.state == Dispatched;
    }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">free</span>() <span style="color: #a626a4;">noexcept</span> {
      info.tuple      = {0, 0};
      info.type       = Blank;
      info.state      = Acceptor;
      info.from       = {0, 0};
      info.recycling  = Blank;
      data            = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>;
    }

    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isFree</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> info.tuple       == PartialTuple{0, 0}
          &amp;&amp; info.type        == Blank
          &amp;&amp; info.state       == Acceptor
          &amp;&amp; info.from.rank   == 0
          &amp;&amp; info.from.source == 0
          &amp;&amp; info.recycling   == Blank
          &amp;&amp; data             == <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
           ;
    }


    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * This function answers the question, which slices can be recycled.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * A slice can only be recycled if it is Fetch or Ready and has</span>
<span style="color: #a0a1a7;">     * a valid datapointer.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * In particular, SelfSufficient are not recyclable, since it is easier</span>
<span style="color: #a0a1a7;">     * just to create a SelfSufficient slice than deal with data dependencies.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * Furthermore, a recycled slice is not recyclable, if this is the case</span>
<span style="color: #a0a1a7;">     * then it is either bad design or a bug.</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isRecyclable</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> (  info.state == Dispatched
             || info.state == Ready
             || info.state == Fetch
             )
          &amp;&amp; hasValidDataPointer()
          ;
    }

    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * This function describes if a slice has a valid data pointer.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * This is important to know if the slice has some data to it, also</span>
<span style="color: #a0a1a7;">     * some structural checks are done, so that it should not be Acceptor</span>
<span style="color: #a0a1a7;">     * or Blank, if this is the case then it is a bug.</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">hasValidDataPointer</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> data       != <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
          &amp;&amp; info.state != Acceptor
          &amp;&amp; info.type  != Blank
          ;
    }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">unwrapAndMarkReady</span>() {
      <span style="color: #a626a4;">if</span> (info.state == Ready) <span style="color: #a626a4;">return</span>;
      <span style="color: #a626a4;">if</span> (info.state != Dispatched)
        <span style="color: #a626a4;">throw</span>
          <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Can't unwrap a non-ready, non-dispatched slice!"</span>);
      markReady();
      <span style="color: #c18401;">MPI_Status</span> <span style="color: #8b4513;">status</span>;
<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__slice__:mpi: waiting "</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">errorCode</span> = MPI_Wait(&amp;request, &amp;status);
      <span style="color: #a626a4;">if</span> (errorCode != MPI_SUCCESS)
        <span style="color: #a626a4;">throw</span> <span style="color: #50a14f;">"MPI ERROR HAPPENED...."</span>;

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
      <span style="color: #c18401;">char</span> <span style="color: #8b4513;">errorString</span>[MPI_MAX_ERROR_STRING];
      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">errorSize</span>;
      MPI_Error_string(errorCode, errorString, &amp;errorSize);

      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__slice__:mpi: status "</span>
                &lt;&lt; <span style="color: #50a14f;">"{ .source="</span>    &lt;&lt; status.MPI_SOURCE
                &lt;&lt; <span style="color: #50a14f;">", .tag="</span>       &lt;&lt; status.MPI_TAG
                &lt;&lt; <span style="color: #50a14f;">", .error="</span>     &lt;&lt; status.MPI_ERROR
                &lt;&lt; <span style="color: #50a14f;">", .errCode="</span>   &lt;&lt; errorCode
                &lt;&lt; <span style="color: #50a14f;">", .err="</span>       &lt;&lt; errorString
                &lt;&lt; <span style="color: #50a14f;">" }"</span>
                &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
    }

    <span style="color: #0184bc;">Slice</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">size_</span>)
      : info({})
      , data(<span style="font-weight: bold; text-decoration: underline;">nullptr</span>)
      , size(size_)
      {}


  }; <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">struct Slice</span>


<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">ostream</span>&amp; <span style="color: #a626a4;">operator</span><span style="color: #0184bc;">&lt;&lt;</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">ostream</span>&amp; <span style="color: #8b4513;">out</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Location</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">v</span>) {
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: remove me</span>
  out &lt;&lt; <span style="color: #50a14f;">"{.r("</span> &lt;&lt; v.rank &lt;&lt; <span style="color: #50a14f;">"), .s("</span> &lt;&lt; v.source &lt;&lt; <span style="color: #50a14f;">")};"</span>;
  <span style="color: #a626a4;">return</span> out;
}

<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">ostream</span>&amp; <span style="color: #a626a4;">operator</span><span style="color: #0184bc;">&lt;&lt;</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">ostream</span>&amp; <span style="color: #8b4513;">out</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">i</span>) {
  out &lt;&lt; <span style="color: #50a14f;">"&#171;t"</span> &lt;&lt; i.type &lt;&lt; <span style="color: #50a14f;">", s"</span> &lt;&lt; i.state &lt;&lt; <span style="color: #50a14f;">"&#187;"</span>
      &lt;&lt; <span style="color: #50a14f;">" &#8857; {"</span> &lt;&lt; i.from.rank &lt;&lt; <span style="color: #50a14f;">", "</span> &lt;&lt; i.from.source &lt;&lt; <span style="color: #50a14f;">"}"</span>
      &lt;&lt; <span style="color: #50a14f;">" &#8756; {"</span> &lt;&lt; i.tuple[0] &lt;&lt; <span style="color: #50a14f;">", "</span> &lt;&lt; i.tuple[1] &lt;&lt; <span style="color: #50a14f;">"}"</span>
      &lt;&lt; <span style="color: #50a14f;">" &#9842;t"</span> &lt;&lt; i.recycling
      ;
  <span style="color: #a626a4;">return</span> out;
}

} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">namespace atrip</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f2200f" class="outline-3">
<h3 id="org5f2200f"><span class="section-number-3">1.2</span> Utils</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;sstream&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;string&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;map&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;chrono&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;ctf.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {


  <span style="color: #a626a4;">template</span> &lt;<span style="color: #a626a4;">typename</span> <span style="color: #c18401;">T</span>&gt;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">string</span> <span style="color: #0184bc;">pretty_print</span>(<span style="color: #c18401;">T</span>&amp;&amp; <span style="color: #8b4513;">value</span>) {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">stringstream</span> <span style="color: #8b4513;">stream</span>;
<span style="color: #e44649;">#if</span> ATRIP_DEBUG &gt; 1
    <span style="font-weight: bold; text-decoration: underline;">dbg</span>::pretty_print(stream, <span style="font-weight: bold; text-decoration: underline;">std</span>::forward&lt;<span style="color: #c18401;">T</span>&gt;(value));
<span style="color: #e44649;">#endif</span>
    <span style="color: #a626a4;">return</span> stream.str();
  }

<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">WITH_CHRONO</span>(<span style="color: #8b4513;">__chrono</span>, ...) \
  __chrono.start(); <span style="color: #c18401;">__VA_ARGS__</span> <span style="color: #8b4513;">__chrono</span>.stop();

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Timer</span> {
    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Clock</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">chrono</span>::high_resolution_clock;
    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Event</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">chrono</span>::<span style="color: #c18401;">time_point</span>&lt;<span style="color: #c18401;">Clock</span>&gt;;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">chrono</span>::<span style="color: #c18401;">duration</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">duration</span>;
    <span style="color: #c18401;">Event</span> <span style="color: #8b4513;">_start</span>;
    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">start</span>() <span style="color: #a626a4;">noexcept</span> { _start = <span style="font-weight: bold; text-decoration: underline;">Clock</span>::now(); }
    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">stop</span>() <span style="color: #a626a4;">noexcept</span> { duration += <span style="font-weight: bold; text-decoration: underline;">Clock</span>::now() - _start; }
    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">clear</span>() <span style="color: #a626a4;">noexcept</span> { duration *= 0; }
    <span style="color: #a626a4;">inline</span> <span style="color: #c18401;">double</span> <span style="color: #0184bc;">count</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> { <span style="color: #a626a4;">return</span> duration.count(); }
  };
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Timings</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">map</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">string</span>, <span style="color: #c18401;">Timer</span>&gt;;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org3e490ce" class="outline-3">
<h3 id="org3e490ce"><span class="section-number-3">1.3</span> The rank mapping</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;vector&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;algorithm&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Slice.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {
  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">RankMap</span> {

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">lengths</span>;
    <span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">np</span>, <span style="color: #8b4513;">size</span>;

    <span style="color: #0184bc;">RankMap</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">lens</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np_</span>)
      : lengths(lens)
      , np(np_)
      , size(<span style="font-weight: bold; text-decoration: underline;">std</span>::accumulate(lengths.begin(), lengths.end(),
                            1UL, <span style="font-weight: bold; text-decoration: underline;">std</span>::multiplies&lt;<span style="color: #c18401;">size_t</span>&gt;()))
    { assert(lengths.size() &lt;= 2); }

    <span style="color: #c18401;">size_t</span> <span style="color: #0184bc;">find</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Location</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">p</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> p.source * np + p.rank;
    }

    <span style="color: #c18401;">size_t</span> <span style="color: #0184bc;">nSources</span>() <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> size / np + size_t(size % np != 0);
    }


    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isPaddingRank</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> size % np == 0
          ? <span style="font-weight: bold; text-decoration: underline;">false</span>
          : rank &gt; (size % np - 1)
          ;
    }

    <span style="color: #c18401;">bool</span> <span style="color: #0184bc;">isSourcePadding</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">source</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">return</span> source == nSources() &amp;&amp; isPaddingRank(rank);
    }

    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Location</span>
    <span style="color: #0184bc;">find</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">sliceType</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">tuple = {11, 8} when abc = {11, 8, 9} and sliceType = AB</span>
      <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, sliceType);

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">index</span>
        = tuple[0]
        + tuple[1] * (lengths.size() &gt; 1 ? lengths[0] : 0)
        ;

      <span style="color: #a626a4;">return</span>
        { index % np
        , index / np
        };
    }

  };

}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd818af6" class="outline-3">
<h3 id="orgd818af6"><span class="section-number-3">1.4</span> The slice union</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Debug.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Slice.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/RankMap.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">F</span> = <span style="color: #c18401;">double</span>;
    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">Tensor</span> = <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">F</span>&gt;;

    <span style="color: #a626a4;">virtual</span> <span style="color: #c18401;">void</span>
    <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">iteration</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) = 0;

    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * This function should enforce an important property of a SliceUnion.</span>
<span style="color: #a0a1a7;">     * Namely, there can be no two Slices of the same nature.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * This means that there can be at most one slice with a given Ty_x_Tu.</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">checkForDuplicates</span>() <span style="color: #a626a4;">const</span> {
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ty_x_Tu&gt; <span style="color: #8b4513;">tytus</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>: slices) {
        <span style="color: #a626a4;">if</span> (s.isFree()) <span style="color: #a626a4;">continue</span>;
        tytus.push_back({s.info.type, s.info.tuple});
      }

      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tytu</span>: tytus) {
        <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">std</span>::count(tytus.begin(), tytus.end(), tytu) &gt; 1)
          <span style="color: #a626a4;">throw</span> <span style="color: #50a14f;">"Invariance violated, more than one slice with same Ty_x_Tu"</span>;
      }

    }

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ty_x_Tu&gt; <span style="color: #0184bc;">neededSlices</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ty_x_Tu&gt; <span style="color: #8b4513;">needed</span>(sliceTypes.size());
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">build the needed vector</span>
      <span style="font-weight: bold; text-decoration: underline;">std</span>::transform(sliceTypes.begin(), sliceTypes.end(),
                     needed.begin(),
                     [&amp;<span style="color: #8b4513;">abc</span>](<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">type</span>) {
                       <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, type);
                       <span style="color: #a626a4;">return</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(type, tuple);
                     });
      <span style="color: #a626a4;">return</span> needed;
    }

    <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">buildLocalDatabase</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * It should build a database of slices so that we know what is needed</span>
<span style="color: #a0a1a7;">     * to fetch in the next iteration represented by the tuple 'abc'.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * 1. The algorithm works as follows, we build a database of the all</span>
<span style="color: #a0a1a7;">     * the slice types that we need together with their tuple.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * 2. Look in the SliceUnion if we already have this tuple,</span>
<span style="color: #a0a1a7;">     * if we already have it mark it (TODO)</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * 3. If we don't have the tuple, look for a (state=acceptor, type=blank)</span>
<span style="color: #a0a1a7;">     * slice and mark this slice as type=Fetch with the corresponding type</span>
<span style="color: #a0a1a7;">     * and tuple.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * NOTE: The algorithm should certify that we always have enough blank</span>
<span style="color: #a0a1a7;">     * slices.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabase</span> <span style="color: #0184bc;">buildLocalDatabase</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabase</span> <span style="color: #8b4513;">result</span>;

      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">needed</span> = neededSlices(abc);

      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:needed:"</span> &lt;&lt; pretty_print(<span style="color: #c18401;">needed</span>) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">BUILD THE DATABASE</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we need to loop over all sliceTypes that this TensorUnion</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">is representing and find out how we will get the corresponding</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">slice for the abc we are considering right now.</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: needed) {
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">type</span> = pair.first;
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">tuple</span> = pair.second;
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">from</span>  = rankMap.find(abc, <span style="color: #c18401;">type</span>);

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:want:"</span> &lt;&lt; pretty_print(pair) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>: slices)
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:guts:ocd "</span>
                    &lt;&lt; s.info &lt;&lt; <span style="color: #50a14f;">" pt "</span> &lt;&lt; s.data
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: checking if exact match"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
        {
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">FIRST: look up if there is already a *Ready* slice matching what we</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">need</span>
          <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">it</span>
            = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                           [&amp;<span style="color: #8b4513;">tuple</span>, &amp;<span style="color: #8b4513;">type</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">other</span>) {
                             <span style="color: #a626a4;">return</span> other.info.tuple == tuple
                                 &amp;&amp; other.info.type == type
                                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we only want another slice when it</span>
                                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">has already ready-to-use data</span>
                                 &amp;&amp; other.isUnwrappable()
                                 ;
                           });
          <span style="color: #a626a4;">if</span> (it != slices.end()) {
            <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we find this slice, it means that we don't have to do anything</span>
            WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: EXACT: found EXACT in name="</span> &lt;&lt; name
                      &lt;&lt; <span style="color: #50a14f;">" for tuple "</span> &lt;&lt; tuple[0] &lt;&lt; <span style="color: #50a14f;">", "</span> &lt;&lt; tuple[1]
                      &lt;&lt; <span style="color: #50a14f;">" ptr "</span> &lt;&lt; it-&gt;data
                      &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
            result.push_back({name, it-&gt;info});
            <span style="color: #a626a4;">continue</span>;
          }
        }

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: checking if recycle"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Try to find a recyling possibility ie. find a slice with the same</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">tuple and that has a valid data pointer.</span>
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">recycleIt</span>
          = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(slices.begin(), slices.end(),
                         [&amp;<span style="color: #8b4513;">tuple</span>, &amp;<span style="color: #8b4513;">type</span>](<span style="color: #c18401;">Slice</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">other</span>) {
                           <span style="color: #a626a4;">return</span> other.info.tuple == tuple
                               &amp;&amp; other.info.type != type
                               &amp;&amp; other.isRecyclable()
                               ;
                         });

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we find this recylce, then we find a Blank slice</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">(which should exist by construction :THINK)</span>
        <span style="color: #a0a1a7; font-weight: bold;">//</span>
        <span style="color: #a626a4;">if</span> (recycleIt != slices.end()) {
          <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">blank</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findOneByType(slices, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Blank);
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: formalize this through a method to copy information</span>
          <span style="color: #a0a1a7; font-weight: bold;">//       </span><span style="color: #a0a1a7;">from another slice</span>
          blank.data = recycleIt-&gt;data;
          blank.info.type = type;
          blank.info.tuple = tuple;
          blank.info.state = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled;
          blank.info.from = from;
          blank.info.recycling = recycleIt-&gt;info.type;
          result.push_back({name, blank.info});
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: RECYCLING: n"</span> &lt;&lt; name
                    &lt;&lt; <span style="color: #50a14f;">" "</span> &lt;&lt; pretty_print(abc)
                    &lt;&lt; <span style="color: #50a14f;">" get "</span> &lt;&lt; pretty_print(blank.info)
                    &lt;&lt; <span style="color: #50a14f;">" from "</span> &lt;&lt; pretty_print(recycleIt-&gt;info)
                    &lt;&lt; <span style="color: #50a14f;">" ptr "</span> &lt;&lt; recycleIt-&gt;data
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>
                    ;
          <span style="color: #a626a4;">continue</span>;
        }

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">in this case we have to create a new slice</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">this means that we should have a blank slice at our disposal</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">and also the freePointers should have some elements inside,</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">so we pop a data pointer from the freePointers container</span>
<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: none work, doing new"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>
        {
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__: NEW: finding blank in "</span> &lt;&lt; name
                    &lt;&lt; <span style="color: #50a14f;">" for type "</span> &lt;&lt; type
                    &lt;&lt; <span style="color: #50a14f;">" for tuple "</span> &lt;&lt; tuple[0] &lt;&lt; <span style="color: #50a14f;">", "</span> &lt;&lt; tuple[1]
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>
                    ;
          <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">blank</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findOneByType(slices, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Blank);
          blank.info.type = type;
          blank.info.tuple = tuple;
          blank.info.from = from;

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Handle self sufficiency</span>
          blank.info.state = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == from.rank
                           ? <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient
                           : <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch
                           ;
          <span style="color: #a626a4;">if</span> (blank.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient) {
            blank.data = sources[from.source].data();
          } <span style="color: #a626a4;">else</span> {
            <span style="color: #a626a4;">if</span> (freePointers.size() == 0)
              <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"No more free pointers!"</span>);
            <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">dataPointer</span> = freePointers.begin();
            freePointers.erase(dataPointer);
            blank.data = *dataPointer;
          }

          result.push_back({name, blank.info});
          <span style="color: #a626a4;">continue</span>;
        }

      }

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">s</span>: slices)
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__db__:guts:ocd:__end__ "</span> &lt;&lt; s.info &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
<span style="color: #e44649;">#endif</span>


      <span style="color: #a626a4;">return</span> result;

    }

    <span style="color: #a0a1a7; font-weight: bold;">/*</span>
<span style="color: #a0a1a7;">     * Garbage collect slices not needed for the next iteration.</span>
<span style="color: #a0a1a7;">     *</span>
<span style="color: #a0a1a7;">     * It will throw if it tries to gc a slice that has not been</span>
<span style="color: #a0a1a7;">     * previously unwrapped, as a safety mechanism.</span>
<span style="color: #a0a1a7; font-weight: bold;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">clearUnusedSlicesForNext</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">needed</span> = neededSlices(abc);

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">CLEAN UP SLICES, FREE THE ONES THAT ARE NOT NEEDED ANYMORE</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span>: slices) {
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if the slice is free, then it was not used anyways</span>
        <span style="color: #a626a4;">if</span> (slice.isFree()) <span style="color: #a626a4;">continue</span>;


        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">try to find the slice in the needed slices list</span>
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">found</span>
          = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(needed.begin(), needed.end(),
                         [&amp;<span style="color: #8b4513;">slice</span>] (<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Ty_x_Tu</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tytu</span>) {
                           <span style="color: #a626a4;">return</span> slice.info.tuple == tytu.second
                               &amp;&amp; slice.info.type == tytu.first
                               ;
                         });

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we did not find slice in needed, then erase it</span>
        <span style="color: #a626a4;">if</span> (found == needed.end()) {

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">We have to be careful about the data pointer,</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for SelfSufficient, the data pointer is a source pointer</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">of the slice, so we should just wipe it.</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">For Ready slices, we have to be careful if there are some</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">recycled slices depending on it.</span>
          <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">freeSlicePointer</span> = <span style="font-weight: bold; text-decoration: underline;">true</span>;

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">allow to gc unwrapped and recycled, never Fetch,</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if we have a Fetch slice then something has gone very wrong.</span>
          <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>slice.isUnwrapped() &amp;&amp; slice.info.state != <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled)
            <span style="color: #a626a4;">throw</span>
              <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Trying to garbage collect "</span>
                                <span style="color: #50a14f;">" a non-unwrapped slice! "</span>
                                + pretty_print(&amp;slice)
                                + pretty_print(slice.info));

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">it can be that our slice is ready, but it has some hanging</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">references lying around in the form of a recycled slice.</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Of course if we need the recycled slice the next iteration</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">this would be fatal, because we would then free the pointer</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">of the slice and at some point in the future we would</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">overwrite it. Therefore, we must check if slice has some</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">references in slices and if so then</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a0a1a7; font-weight: bold;">//  </span><span style="color: #a0a1a7;">- we should mark those references as the original (since the data</span>
          <span style="color: #a0a1a7; font-weight: bold;">//    </span><span style="color: #a0a1a7;">pointer should be the same)</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a0a1a7; font-weight: bold;">//  </span><span style="color: #a0a1a7;">- we should make sure that the data pointer of slice</span>
          <span style="color: #a0a1a7; font-weight: bold;">//    </span><span style="color: #a0a1a7;">does not get freed.</span>
          <span style="color: #a0a1a7; font-weight: bold;">//</span>
          <span style="color: #a626a4;">if</span> (slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ready) {
            <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span>
              &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; <span style="color: #50a14f;">"checking for data recycled dependencies\n"</span>;
            <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">recycled</span>
              = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::hasRecycledReferencingToIt(slices, slice.info);
            <span style="color: #a626a4;">if</span> (recycled.size()) {
              <span style="color: #c18401;">Slice</span>* <span style="color: #8b4513;">newReady</span> = recycled[0];
              <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span>
                &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; <span style="color: #50a14f;">"swaping recycled "</span>
                &lt;&lt; pretty_print(newReady-&gt;info)
                &lt;&lt; <span style="color: #50a14f;">" and "</span>
                &lt;&lt; pretty_print(slice.info)
                &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
              newReady-&gt;markReady();
              assert(newReady-&gt;data == slice.data);
              freeSlicePointer = <span style="font-weight: bold; text-decoration: underline;">false</span>;

              <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 1; i &lt; recycled.size(); i++) {
                <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">newRecyled</span> = recycled[i];
                newRecyled-&gt;info.recycling = newReady-&gt;info.type;
                <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span>
                  &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; <span style="color: #50a14f;">"updating recycled "</span>
                  &lt;&lt; pretty_print(newRecyled-&gt;info)
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
              }

            }
          }

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">if the slice is self sufficient, do not dare touching the</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">pointer, since it is a pointer to our sources in our rank.</span>
          <span style="color: #a626a4;">if</span> (  slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient
             || slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled
             ) {
            freeSlicePointer = <span style="font-weight: bold; text-decoration: underline;">false</span>;
          }

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">make sure we get its data pointer to be used later</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">only for non-recycled, since it can be that we need</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">for next iteration the data of the slice that the recycled points</span>
          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">to</span>
          <span style="color: #a626a4;">if</span> (freeSlicePointer) {
            freePointers.insert(slice.data);
            WITH_RANK &lt;&lt; <span style="color: #50a14f;">"~~~:cl("</span> &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">")"</span>
                      &lt;&lt; <span style="color: #50a14f;">" added to freePointer "</span>
                      &lt;&lt; pretty_print(freePointers)
                      &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          } <span style="color: #a626a4;">else</span> {
            <span style="color: #c18401;">WITH_OCD</span> <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__gc__:not touching the free Pointer\n"</span>;
          }

          <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">at this point, let us blank the slice</span>
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"~~~:cl("</span> &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">")"</span>
                    &lt;&lt; <span style="color: #50a14f;">" freeing up slice "</span>
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; slice.info
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          slice.free();
        }

      }
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">CONSTRUCTOR</span>
    <span style="color: #0184bc;">SliceUnion</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
              , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span>&gt; <span style="color: #8b4513;">sliceTypes_</span>
              , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">sliceLength_</span>
              , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">paramLength</span>
              , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
              , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
              , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
              , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name_</span>
              , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nSliceBuffers</span> = 4
              )
              : rankMap(paramLength, np)
              , world(child_world)
              , universe(global_world)
              , sliceLength(sliceLength_)
              , sources(rankMap.nSources(),
                        <span style="font-weight: bold; text-decoration: underline;">std</span>::vector&lt;<span style="color: #c18401;">F</span>&gt;
                          (<span style="font-weight: bold; text-decoration: underline;">std</span>::accumulate(sliceLength.begin(),
                                           sliceLength.end(),
                                           1UL, <span style="font-weight: bold; text-decoration: underline;">std</span>::multiplies&lt;<span style="color: #c18401;">size_t</span>&gt;())))
              , name(name_)
              , sliceTypes(sliceTypes_)
              , sliceBuffers(nSliceBuffers, sources[0])
              <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">, slices(2 * sliceTypes.size(), Slice{ sources[0].size() })</span>
    { <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">constructor begin</span>

      LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"INIT SliceUnion: "</span> &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

      slices
        = <span style="font-weight: bold; text-decoration: underline;">std</span>::vector&lt;<span style="color: #c18401;">Slice</span>&gt;(2 * sliceTypes.size(), { sources[0].size() });
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: think exactly ^------------------- about this number</span>

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">initialize the freePointers with the pointers to the buffers</span>
      <span style="font-weight: bold; text-decoration: underline;">std</span>::transform(sliceBuffers.begin(), sliceBuffers.end(),
                     <span style="font-weight: bold; text-decoration: underline;">std</span>::inserter(freePointers, freePointers.begin()),
                     [](<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">F</span>&gt; &amp;<span style="color: #8b4513;">vec</span>) { <span style="color: #a626a4;">return</span> vec.data(); });



      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"rankMap.nSources "</span>
                           &lt;&lt; rankMap.nSources() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#slices "</span>
                           &lt;&lt; slices.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#slices[0] "</span>
                           &lt;&lt; slices[0].size &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sources "</span>
                           &lt;&lt; sources.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sources[0] "</span>
                           &lt;&lt; sources[0].size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#freePointers "</span>
                           &lt;&lt; freePointers.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sliceBuffers "</span>
                           &lt;&lt; sliceBuffers.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sliceBuffers[0] "</span>
                           &lt;&lt; sliceBuffers[0].size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#sliceLength "</span>
                           &lt;&lt; sliceLength.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#paramLength "</span>
                           &lt;&lt; paramLength.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"GB*"</span> &lt;&lt; np &lt;&lt; <span style="color: #50a14f;">" "</span>
                           &lt;&lt; <span style="color: #c18401;">double</span>(sources.size() + sliceBuffers.size())
                            * sources[0].size()
                            * 8 * np
                            / 1073741824.0
                           &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">constructor ends</span>

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">init</span>(<span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>) {

      <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">World</span> <span style="color: #8b4513;">w</span>(world);
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span> = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank
              , <span style="color: #8b4513;">order</span> = sliceLength.size()
              ;
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">syms</span>(order, NS);
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">__sliceLength</span>(sliceLength.begin(), sliceLength.end());
      <span style="color: #c18401;">Tensor</span> <span style="color: #8b4513;">toSliceInto</span>(order,
                         __sliceLength.data(),
                         syms.data(),
                         w);
      LOG(1,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"slicing... \n"</span>;

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">setUp sources</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>(0); it &lt; rankMap.nSources(); ++it) {
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span>
          <span style="color: #8b4513;">source</span> = rankMap.isSourcePadding(rank, source) ? 0 : it;
        <span style="color: #c18401;">WITH_OCD</span>
        <span style="color: #8b4513;">WITH_RANK</span>
          &lt;&lt; <span style="color: #50a14f;">"Init:toSliceInto it-"</span> &lt;&lt; it
          &lt;&lt; <span style="color: #50a14f;">" :: source "</span> &lt;&lt; source &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        sliceIntoBuffer(source, toSliceInto, sourceTensor);
      }

    }

    <span style="color: #50a14f; font-style: italic;">/**</span>
<span style="color: #50a14f; font-style: italic;">     * \brief Send asynchronously only if the state is Fetch</span>
<span style="color: #50a14f; font-style: italic;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">send</span>( <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">otherRank</span>
             , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>
             , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">tag</span>) <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #c18401;">MPI_Request</span> <span style="color: #8b4513;">request</span>;
      <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">sendData_p</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;

      <span style="color: #a626a4;">if</span> (info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch) sendData_p = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: remove this because I have SelfSufficient</span>
      <span style="color: #a626a4;">if</span> (otherRank == info.from.rank)      sendData_p = <span style="font-weight: bold; text-decoration: underline;">false</span>;
      <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>sendData_p) <span style="color: #a626a4;">return</span>;

      MPI_Isend( <span style="color: #c18401;">sources</span>[info.from.source].data()
               , <span style="color: #c18401;">sources</span>[info.from.source].size()
               , MPI_DOUBLE <span style="color: #a0a1a7; font-weight: bold;">/* </span><span style="color: #a0a1a7;">TODO: adapt this with traits</span><span style="color: #a0a1a7; font-weight: bold;"> */</span>
               , otherRank
               , tag
               , universe
               , &amp;request
               );
      <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
      <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"sent to "</span> &lt;&lt; otherRank &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

    }

    <span style="color: #50a14f; font-style: italic;">/**</span>
<span style="color: #50a14f; font-style: italic;">     * \brief Receive asynchronously only if the state is Fetch</span>
<span style="color: #50a14f; font-style: italic;">     */</span>
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">receive</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Info</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">info</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">tag</span>) <span style="color: #a626a4;">noexcept</span> {
      <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findByInfo(slices, info);

      <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == info.from.rank) <span style="color: #a626a4;">return</span>;

      <span style="color: #a626a4;">if</span> (slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch) {
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: do it through the slice class</span>
        slice.info.state = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Dispatched;
        <span style="color: #c18401;">MPI_Request</span> <span style="color: #8b4513;">request</span>;
        slice.request = request;
        MPI_Irecv( slice.data
                 , slice.size
                 , MPI_DOUBLE <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: Adapt this with traits</span>
                 , info.from.rank
                 , tag
                 , universe
                 , &amp;slice.request
                <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">, MPI_STATUS_IGNORE</span>
                 );
      }
    }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">unwrapAll</span>(<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">type</span>: sliceTypes) unwrapSlice(type, abc);
    }

    <span style="color: #c18401;">F</span>* <span style="color: #0184bc;">unwrapSlice</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span> <span style="color: #8b4513;">type</span>, <span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>) {
      <span style="color: #c18401;">WITH_CRAZY_DEBUG</span>
      <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"__unwrap__:slice "</span> &lt;&lt; type &lt;&lt; <span style="color: #50a14f;">" w n "</span>
                &lt;&lt; name
                &lt;&lt; <span style="color: #50a14f;">" abc"</span> &lt;&lt; pretty_print(abc)
                &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::findByTypeAbc(slices, type, abc);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:info "</span> &lt;&lt; slice.info &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">switch</span>  (slice.info.state) {
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Dispatched:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:Fetch: "</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          slice.unwrapAndMarkReady();
          <span style="color: #a626a4;">return</span> slice.data;
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::SelfSufficient:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:SelfSufficient: "</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          <span style="color: #a626a4;">return</span> slice.data;
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Ready:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:READY: UNWRAPPED ALREADY"</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          <span style="color: #a626a4;">return</span> slice.data;
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Recycled:
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__unwrap__:RECYCLED "</span> &lt;&lt; &amp;slice
                    &lt;&lt; <span style="color: #50a14f;">" info "</span> &lt;&lt; pretty_print(slice.info)
                    &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
          <span style="color: #a626a4;">return</span> unwrapSlice(slice.info.recycling, abc);
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Fetch:
        <span style="color: #a626a4;">case</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Acceptor:
          <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Can't unwrap an acceptor or fetch slice!"</span>);
          <span style="color: #a626a4;">break</span>;
        <span style="color: #a626a4;">default</span>:
          <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"Unknown error unwrapping slice!"</span>);
      }
      <span style="color: #a626a4;">return</span> slice.data;
    }

    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">RankMap</span> <span style="color: #8b4513;">rankMap</span>;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">world</span>;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span>;
    <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">sliceLength</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">F</span>&gt; &gt; <span style="color: #8b4513;">sources</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="color: #c18401;">Slice</span> &gt; <span style="color: #8b4513;">slices</span>;
    <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name</span>;
    <span style="color: #a626a4;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Type</span>&gt; <span style="color: #8b4513;">sliceTypes</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">F</span>&gt; &gt; <span style="color: #8b4513;">sliceBuffers</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">set</span>&lt;<span style="color: #c18401;">F</span>*&gt; <span style="color: #8b4513;">freePointers</span>;

  };

  <span style="color: #c18401;">SliceUnion</span>&amp;
  <span style="color: #0184bc;">unionByName</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">SliceUnion</span>*&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">unions</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Name</span> <span style="color: #8b4513;">name</span>) {
      <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">sliceUnionIt</span>
        = <span style="font-weight: bold; text-decoration: underline;">std</span>::find_if(unions.begin(), unions.end(),
                      [&amp;<span style="color: #8b4513;">name</span>](<span style="color: #c18401;">SliceUnion</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">s</span>) {
                        <span style="color: #a626a4;">return</span> name == s-&gt;name;
                      });
      <span style="color: #a626a4;">if</span> (sliceUnionIt == unions.end())
        <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error(<span style="color: #50a14f;">"SliceUnion not found!"</span>);
      <span style="color: #a626a4;">return</span> **sliceUnionIt;
  }

}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga058e69" class="outline-3">
<h3 id="orga058e69"><span class="section-number-3">1.5</span> Tuples</h3>
<div class="outline-text-3" id="text-1-5">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;vector&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;array&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;numeric&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Utils.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Debug.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">ABCTuple</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">array</span>&lt;<span style="color: #c18401;">size_t</span>, 3&gt;;
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">PartialTuple</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">array</span>&lt;<span style="color: #c18401;">size_t</span>, 2&gt;;
  <span style="color: #a626a4;">using</span> <span style="color: #c18401;">ABCTuples</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;ABCTuple&gt;;

  <span style="color: #c18401;">ABCTuples</span> <span style="color: #0184bc;">getTuplesList</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>) {
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">n</span> = Nv * (Nv + 1) * (Nv + 2) / 6 - Nv;
    <span style="color: #c18401;">ABCTuples</span> <span style="color: #8b4513;">result</span>(n);
    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">u</span>(0);

    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">a</span>(0); a &lt; Nv; a++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">b</span>(a); b &lt; Nv; b++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">c</span>(b); c &lt; Nv; c++){
      <span style="color: #a626a4;">if</span> ( a == b &amp;&amp; b == c ) <span style="color: #a626a4;">continue</span>;
      result[u++] = {a, b, c};
    }

    <span style="color: #a626a4;">return</span> result;

  }


  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">pair</span>&lt;<span style="color: #c18401;">size_t</span>, <span style="color: #c18401;">size_t</span>&gt;
  <span style="color: #0184bc;">getABCRange</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>, <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">rank</span>, <span style="color: #c18401;">ABCTuples</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tuplesList</span>) {

    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">size_t</span>&gt; <span style="color: #8b4513;">n_tuples_per_rank</span>(np, tuplesList.size()/np);
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">how many valid tuples should we still verteilen to nodes</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">since the number of tuples is not divisible by the number of nodes</span>
        <span style="color: #8b4513;">nRoundRobin</span> = tuplesList.size() % np
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">every node must have the sanme amount of tuples in order for the</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">other nodes to receive and send somewhere, therefore</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">some nodes will get extra tuples but that are dummy tuples</span>
      , <span style="color: #8b4513;">nExtraInvalid</span> = (np - nRoundRobin) % np
      ;

    <span style="color: #a626a4;">if</span> (nRoundRobin) <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span> = 0; i &lt; np; i++) n_tuples_per_rank[i]++;

<span style="color: #e44649;">  #if</span> <span style="color: #e44649;">defined</span>(TODO)
    assert( tuplesList.size()
            ==
            ( <span style="font-weight: bold; text-decoration: underline;">std</span>::accumulate(n_tuples_per_rank.begin(),
                              n_tuples_per_rank.end(),
                              0UL,
                              <span style="font-weight: bold; text-decoration: underline;">std</span>::plus&lt;<span style="color: #c18401;">size_t</span>&gt;())
            + nExtraInvalid
            ));
<span style="color: #e44649;">  #endif</span>

    WITH_RANK &lt;&lt; <span style="color: #50a14f;">"nRoundRobin = "</span> &lt;&lt; nRoundRobin &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    WITH_RANK &lt;&lt; <span style="color: #50a14f;">"nExtraInvalid = "</span> &lt;&lt; nExtraInvalid &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    WITH_RANK &lt;&lt; <span style="color: #50a14f;">"ntuples = "</span> &lt;&lt; n_tuples_per_rank[rank] &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

    <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">it</span> = n_tuples_per_rank.begin();

    <span style="color: #a626a4;">return</span>
      { <span style="font-weight: bold; text-decoration: underline;">std</span>::accumulate(it, it + rank    , 0)
      , <span style="font-weight: bold; text-decoration: underline;">std</span>::accumulate(it, it + rank + 1, 0)
      };

  }

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org69680bd" class="outline-3">
<h3 id="org69680bd"><span class="section-number-3">1.6</span> Unions</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Since every tensor slice in a different way, we can override the slicing procedure
and define subclasses of slice unions.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/SliceUnion.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoVector</span>
    ( <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; &amp;<span style="color: #8b4513;">v</span>
    , <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; &amp;<span style="color: #8b4513;">toSlice</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">low</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">up</span>
    , <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">origin</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">originLow</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int64_t</span>&gt; <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">originUp</span>
    ) {
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Thank you CTF for forcing me to do this</span>
    <span style="color: #a626a4;">struct</span> { <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">int</span>&gt; <span style="color: #8b4513;">up</span>, <span style="color: #8b4513;">low</span>; }
        <span style="color: #8b4513;">toSlice_</span> = { {up.begin(), up.end()}
                   , {low.begin(), low.end()} }
      , <span style="color: #8b4513;">origin_</span> = { {originUp.begin(), originUp.end()}
                  , {originLow.begin(), originLow.end()} }
      ;

    <span style="color: #c18401;">WITH_OCD</span>
    <span style="color: #8b4513;">WITH_RANK</span> &lt;&lt; <span style="color: #50a14f;">"slicing into "</span> &lt;&lt; pretty_print(toSlice_.up)
                          &lt;&lt; <span style="color: #50a14f;">","</span> &lt;&lt; pretty_print(toSlice_.low)
              &lt;&lt; <span style="color: #50a14f;">" from "</span> &lt;&lt; pretty_print(origin_.up)
                   &lt;&lt; <span style="color: #50a14f;">","</span> &lt;&lt; pretty_print(origin_.low)
              &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

<span style="color: #e44649;">#if</span><span style="color: #e44649; font-weight: bold;">n</span><span style="color: #e44649;">def</span> ATRIP_DONT_SLICE
    toSlice.slice( toSlice_.low.data()
                 , toSlice_.up.data()
                 , 0.0
                 , origin
                 , origin_.low.data()
                 , origin_.up.data()
                 , 1.0);
    memcpy(v.data(), toSlice.data, <span style="color: #a626a4;">sizeof</span>(<span style="color: #c18401;">double</span>) * v.size());
<span style="color: #e44649;">#endif</span>

  }


  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">TAPHH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">TAPHH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
         ) : SliceUnion( sourceTensor
                       , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::C}
                       , {Nv, No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                       , {Nv}
                       , np
                       , child_world
                       , global_world
                       , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::TA
                       , 4) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span>
    {
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = sliceLength[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">a</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it});
              ;


      sliceIntoVector( sources[it]
                     , to,   {0, 0, 0},    {Nv, No, No}
                     , from, {a, 0, 0, 0}, {a+1, Nv, No, No}
                     );

    }

  };


  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">HHHA</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">HHHA</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
        ) : SliceUnion( sourceTensor
                      , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::C}
                      , {No, No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                      , {Nv}         <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                      , np
                      , child_world
                      , global_world
                      , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::VIJKA
                      , 4) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span>
    {

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">No</span> = sliceLength[0]
              , <span style="color: #8b4513;">a</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              ;

      sliceIntoVector( sources[it]
                     , to,   {0, 0, 0},    {No, No, No}
                     , from, {0, 0, 0, a}, {No, No, No, a+1}
                     );

    }
  };

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">ABPH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">ABPH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
        ) : SliceUnion( sourceTensor
                      , { <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC
                        , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BA, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::CB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::CA
                        }
                      , {Nv, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                      , {Nv, Nv} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                      , np
                      , child_world
                      , global_world
                      , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::VABCI
                      , 2*6) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span> {

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = sliceLength[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">el</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              , <span style="color: #8b4513;">a</span> = el % Nv
              , <span style="color: #8b4513;">b</span> = el / Nv
              ;


      sliceIntoVector( sources[it]
                     , to,   {0, 0},       {Nv, No}
                     , from, {a, b, 0, 0}, {a+1, b+1, Nv, No}
                     );

    }

  };

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">ABHH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">ABHH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
        , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
        , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
        ) : SliceUnion( sourceTensor
                      , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC}
                      , {No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                      , {Nv, Nv} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                      , np
                      , child_world
                      , global_world
                      , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::VABIJ
                      , 6) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span> {

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = from.lens[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">el</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              , <span style="color: #8b4513;">a</span> = el % Nv
              , <span style="color: #8b4513;">b</span> = el / Nv
              ;

      sliceIntoVector( sources[it]
                     , to,   {0, 0},       {No, No}
                     , from, {a, b, 0, 0}, {a+1, b+1, No, No}
                     );


    }

  };


  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">TABHH</span> : <span style="color: #a626a4;">public</span> <span style="color: #c18401;">SliceUnion</span> {
    <span style="color: #0184bc;">TABHH</span>( <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">sourceTensor</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
         , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">np</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_world</span>
         , <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">global_world</span>
         ) : SliceUnion( sourceTensor
                       , {<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, <span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC}
                       , {No, No} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the slices</span>
                       , {Nv, Nv} <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">size of the parametrization</span>
                       , np
                       , child_world
                       , global_world
                       , <span style="font-weight: bold; text-decoration: underline;">Slice</span>::TABIJ
                       , 6) {
           init(sourceTensor);
         }

    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">sliceIntoBuffer</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">it</span>, <span style="color: #c18401;">Tensor</span> &amp;<span style="color: #8b4513;">to</span>, <span style="color: #c18401;">Tensor</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">from</span>) <span style="color: #a626a4;">override</span> {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: maybe generalize this with ABHH</span>

      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">Nv</span> = from.lens[0]
              , <span style="color: #8b4513;">No</span> = sliceLength[1]
              , <span style="color: #8b4513;">el</span> = rankMap.find({<span style="color: #a626a4;">static_cast</span>&lt;<span style="color: #c18401;">size_t</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank), it})
              , <span style="color: #8b4513;">a</span> = el % Nv
              , <span style="color: #8b4513;">b</span> = el / Nv
              ;

      sliceIntoVector( sources[it]
                     , to,   {0, 0},       {No, No}
                     , from, {a, b, 0, 0}, {a+1, b+1, No, No}
                     );


    }

  };

}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgfccf67b" class="outline-3">
<h3 id="orgfccf67b"><span class="section-number-3">1.7</span> Equations</h3>
<div class="outline-text-3" id="text-1-7">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once

<span style="color: #e44649;">#include</span><span style="color: #50a14f;">&lt;atrip/Slice.hpp&gt;</span>
<span style="color: #e44649;">#include</span><span style="color: #50a14f;">&lt;atrip/Blas.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #c18401;">double</span> <span style="color: #0184bc;">getEnergyDistinct</span>
    ( <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">epsabc</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">epsi</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Tijk_</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Zijk_</span>
    ) {
    <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">blockSize</span>=16;
    <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>(0.);
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span> = epsi.size();
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kk</span>=0; kk&lt;No; kk+=blockSize){
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min(No, kk+blockSize) );
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jj</span>(kk); jj&lt;No; jj+=blockSize){
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( No, jj+blockSize) );
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ii</span>(jj); ii&lt;No; ii+=blockSize){
          <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">iend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( No, ii+blockSize) );
          <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span>(kk); k &lt; kend; k++){
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ek</span>(epsi[k]);
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jstart</span> = jj &gt; k ? jj : k;
            <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>(jstart); j &lt; jend; j++){
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ej</span>(epsi[j]);
              <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facjk</span>( j == k ? 0.5 : 1.0);
              <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">istart</span> = ii &gt; j ? ii : j;
              <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>(istart); i &lt; iend; i++){
                <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ei</span>(epsi[i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facij</span> ( i==j ? 0.5 : 1.0);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">denominator</span>(epsabc - ei - ej - ek);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">U</span>(Zijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">V</span>(Zijk_[i + No*k + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">W</span>(Zijk_[j + No*i + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">X</span>(Zijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">Y</span>(Zijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">Z</span>(Zijk_[k + No*j + No*No*i]);

                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">A</span>(Tijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">B</span>(Tijk_[i + No*k + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">C</span>(Tijk_[j + No*i + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">D</span>(Tijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">E</span>(Tijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">F</span>(Tijk_[k + No*j + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">value</span>(3.0*(<span style="color: #c18401;">A</span>*<span style="color: #8b4513;">U</span>+B*V+C*W+D*X+E*Y+F*Z)
                            +((U+X+Y)-2.0*(V+W+Z))*(A+D+E)
                            +((V+W+Z)-2.0*(U+X+Y))*(B+C+F));
                energy += 2.0*value / denominator * facjk * facij;
              } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i</span>
            } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">j</span>
          } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">k</span>
        } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ii</span>
      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">jj</span>
    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">kk</span>
    <span style="color: #a626a4;">return</span> energy;
  }


  <span style="color: #c18401;">double</span> <span style="color: #0184bc;">getEnergySame</span>
    ( <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">epsabc</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">epsi</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Tijk_</span>
    , <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">Zijk_</span>
    ) {
    <span style="color: #a626a4;">constexpr</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">blockSize</span> = 16;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span> = epsi.size();
    <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>(0.);
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kk</span>=0; kk&lt;No; kk+=blockSize){
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">kend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( kk+blockSize, No) );
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jj</span>(kk); jj&lt;No; jj+=blockSize){
        <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( jj+blockSize, No) );
        <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ii</span>(jj); ii&lt;No; ii+=blockSize){
          <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">iend</span>( <span style="font-weight: bold; text-decoration: underline;">std</span>::min( ii+blockSize, No) );
          <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span>(kk); k &lt; kend; k++){
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ek</span>(epsi[k]);
            <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">jstart</span> = jj &gt; k ? jj : k;
            <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>(jstart); j &lt; jend; j++){
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facjk</span>( j == k ? 0.5 : 1.0);
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ej</span>(epsi[j]);
              <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">istart</span> = ii &gt; j ? ii : j;
              <span style="color: #a626a4;">for</span>(<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>(istart); i &lt; iend; i++){
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">ei</span>(epsi[i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">facij</span> ( i==j ? 0.5 : 1.0);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">denominator</span>(epsabc - ei - ej - ek);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">U</span>(Zijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">V</span>(Zijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">W</span>(Zijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">A</span>(Tijk_[i + No*j + No*No*k]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">B</span>(Tijk_[j + No*k + No*No*i]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">C</span>(Tijk_[k + No*i + No*No*j]);
                <span style="color: #c18401;">double</span> <span style="color: #8b4513;">value</span>(3.0*( <span style="color: #c18401;">A</span>*<span style="color: #8b4513;">U</span> + B*V + C*W) - (A+B+C)*(U+V+W));
                energy += 2.0*value / denominator * facjk * facij;
              } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">i</span>
            } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">j</span>
          } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">k</span>
        } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ii</span>
      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">jj</span>
    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">kk</span>
    <span style="color: #a626a4;">return</span> energy;
  }

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">singlesContribution</span>
    ( <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span>
    , <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span>
    , <span style="color: #a626a4;">const</span> <span style="color: #c18401;">ABCTuple</span> &amp;<span style="color: #8b4513;">abc</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">Tph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VABij</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VACij</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VBCij</span>
    , <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">Zijk</span>
    ) {
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">a</span>(abc[0]), <span style="color: #8b4513;">b</span>(abc[1]), <span style="color: #8b4513;">c</span>(abc[2]);
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span>=0; k &lt; No; k++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span>=0; i &lt; No; i++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span>=0; j &lt; No; j++) {
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ijk</span> = i + j*No + k*No*No
                ,  <span style="color: #8b4513;">jk</span> = j + No * k
                ;
      Zijk[ijk] += Tph[ a + i * Nv ] * VBCij[ j + k * No ];
      Zijk[ijk] += Tph[ b + j * Nv ] * VACij[ i + k * No ];
      Zijk[ijk] += Tph[ c + k * Nv ] * VABij[ i + j * No ];
    }
  }

  <span style="color: #c18401;">void</span> <span style="color: #0184bc;">doublesContribution</span>
    ( <span style="color: #a626a4;">const</span> <span style="color: #c18401;">ABCTuple</span> &amp;<span style="color: #8b4513;">abc</span>
    , <span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">No</span>
    , <span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">Nv</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VABCI</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VABph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VACph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VBCph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VBAph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VCAph</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VCBph</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VHHHA</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VhhhA</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VhhhB</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">VhhhC</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TA</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TAphh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TBphh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TCphh</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TABIJ</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TABhh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TAChh</span>
    , <span style="color: #c18401;">double</span> <span style="color: #a626a4;">const</span>* <span style="color: #8b4513;">TBChh</span>
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TIJK</span>
    , <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">Tijk</span>
    , <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="color: #c18401;">Timings</span>&amp; <span style="color: #8b4513;">chrono</span>
    ) {

    <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">t_reorder</span> = chrono[<span style="color: #50a14f;">"doubles:reorder"</span>];
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">a</span> = abc[0], <span style="color: #8b4513;">b</span> = abc[1], <span style="color: #8b4513;">c</span> = abc[2]
              , <span style="color: #8b4513;">NoNo</span> = No*No, <span style="color: #8b4513;">NoNv</span> = No*Nv
              ;

<span style="color: #e44649;">  #if</span> <span style="color: #e44649;">defined</span>(ATRIP_USE_DGEMM)
<span style="color: #e44649;">  #define</span> <span style="color: #0184bc;">_IJK_</span>(<span style="color: #8b4513;">i</span>, <span style="color: #8b4513;">j</span>, <span style="color: #8b4513;">k</span>) i + j*No + k*NoNo
<span style="color: #e44649;">  #define</span> <span style="color: #0184bc;">REORDER</span>(<span style="color: #8b4513;">__II</span>, <span style="color: #8b4513;">__JJ</span>, <span style="color: #8b4513;">__KK</span>)                                 \
    t_reorder.start();                                              \
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span> = 0; k &lt; No; k++)                                 \
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0; j &lt; No; j++)                                 \
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 0; i &lt; No; i++) {                               \
      Tijk[_IJK_(i, j, k)] += _t_buffer[_IJK_(__II, __JJ, __KK)];   \
    }                                                               \
    t_reorder.stop();
<span style="color: #e44649;">  #define</span> <span style="color: #0184bc;">DGEMM_PARTICLES</span>(<span style="color: #8b4513;">__A</span>, <span style="color: #8b4513;">__B</span>)    \
    <span style="font-weight: bold; text-decoration: underline;">atrip</span>::dgemm_( <span style="color: #50a14f;">"T"</span>                 \
                , <span style="color: #50a14f;">"N"</span>                 \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo   \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No     \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;Nv     \
                , &amp;one                \
                , __A                 \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;Nv     \
                , __B                 \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;Nv     \
                , &amp;zero               \
                , _t_buffer.data()    \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo   \
                );
<span style="color: #e44649;">  #define</span> <span style="color: #0184bc;">DGEMM_HOLES</span>(<span style="color: #8b4513;">__A</span>, <span style="color: #8b4513;">__B</span>, <span style="color: #8b4513;">__TRANSB</span>)  \
    <span style="font-weight: bold; text-decoration: underline;">atrip</span>::dgemm_( <span style="color: #50a14f;">"N"</span>                     \
                , __TRANSB                \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo       \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No         \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No         \
                , &amp;m_one                  \
                , __A                     \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo       \
                , __B                     \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;No         \
                , &amp;zero                   \
                , _t_buffer.data()        \
                , (<span style="color: #c18401;">int</span> <span style="color: #a626a4;">const</span>*)&amp;NoNo       \
                );

    <span style="color: #a626a4;">using</span> <span style="color: #c18401;">F</span> = <span style="color: #c18401;">double</span>;
    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">NoNoNo</span> = No*NoNo;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">_t_buffer</span>;
    _t_buffer.reserve(NoNoNo);
    <span style="color: #c18401;">F</span> <span style="color: #8b4513;">one</span>{1.0}, <span style="color: #8b4513;">m_one</span>{-1.0}, <span style="color: #8b4513;">zero</span>{0.0};

    t_reorder.start();
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span> = 0; k &lt; NoNoNo; k++) {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">zero the Tijk</span>
      Tijk[k] = 0.0;
    }
    t_reorder.stop();

    chrono[<span style="color: #50a14f;">"doubles:holes"</span>].start();
    { <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Holes part ============================================================</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhC[i + k*No + L*NoNo] * TABhh[L + j*No]; H1</span>
      chrono[<span style="color: #50a14f;">"doubles:holes:1"</span>].start();
      DGEMM_HOLES(VhhhC, TABhh, <span style="color: #50a14f;">"N"</span>)
      REORDER(i, k, j)
      chrono[<span style="color: #50a14f;">"doubles:holes:1"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhC[j + k*No + L*NoNo] * TABhh[i + L*No]; H0</span>
      chrono[<span style="color: #50a14f;">"doubles:holes:2"</span>].start();
      DGEMM_HOLES(VhhhC, TABhh, <span style="color: #50a14f;">"T"</span>)
      REORDER(j, k, i)
      chrono[<span style="color: #50a14f;">"doubles:holes:2"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhB[i + j*No + L*NoNo] * TAChh[L + k*No]; H5</span>
      chrono[<span style="color: #50a14f;">"doubles:holes:3"</span>].start();
      DGEMM_HOLES(VhhhB, TAChh, <span style="color: #50a14f;">"N"</span>)
      REORDER(i, j, k)
      chrono[<span style="color: #50a14f;">"doubles:holes:3"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhB[k + j*No + L*NoNo] * TAChh[i + L*No]; H3</span>
      chrono[<span style="color: #50a14f;">"doubles:holes:4"</span>].start();
      DGEMM_HOLES(VhhhB, TAChh, <span style="color: #50a14f;">"T"</span>)
      REORDER(k, j, i)
      chrono[<span style="color: #50a14f;">"doubles:holes:4"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhA[j + i*No + L*NoNo] * TBChh[L + k*No]; H1</span>
      chrono[<span style="color: #50a14f;">"doubles:holes:5"</span>].start();
      DGEMM_HOLES(VhhhA, TBChh, <span style="color: #50a14f;">"N"</span>)
      REORDER(j, i, k)
      chrono[<span style="color: #50a14f;">"doubles:holes:5"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">VhhhA[k + i*No + L*NoNo] * TBChh[j + L*No]; H4</span>
      chrono[<span style="color: #50a14f;">"doubles:holes:6"</span>].start();
      DGEMM_HOLES(VhhhA, TBChh, <span style="color: #50a14f;">"T"</span>)
      REORDER(k, i, j)
      chrono[<span style="color: #50a14f;">"doubles:holes:6"</span>].stop();
    }
    chrono[<span style="color: #50a14f;">"doubles:holes"</span>].stop();

    chrono[<span style="color: #50a14f;">"doubles:particles"</span>].start();
    { <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Particle part =========================================================</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TAphh[E + i*Nv + j*NoNv] * VBCph[E + k*Nv]; P0</span>
      chrono[<span style="color: #50a14f;">"doubles:particles:1"</span>].start();
      DGEMM_PARTICLES(TAphh, VBCph)
      REORDER(i, j, k)
      chrono[<span style="color: #50a14f;">"doubles:particles:1"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TAphh[E + i*Nv + k*NoNv] * VCBph[E + j*Nv]; P3</span>
      chrono[<span style="color: #50a14f;">"doubles:particles:2"</span>].start();
      DGEMM_PARTICLES(TAphh, VCBph)
      REORDER(i, k, j)
      chrono[<span style="color: #50a14f;">"doubles:particles:2"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TCphh[E + k*Nv + i*NoNv] * VABph[E + j*Nv]; P5</span>
      chrono[<span style="color: #50a14f;">"doubles:particles:3"</span>].start();
      DGEMM_PARTICLES(TCphh, VABph)
      REORDER(k, i, j)
      chrono[<span style="color: #50a14f;">"doubles:particles:3"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TCphh[E + k*Nv + j*NoNv] * VBAph[E + i*Nv]; P2</span>
      chrono[<span style="color: #50a14f;">"doubles:particles:4"</span>].start();
      DGEMM_PARTICLES(TCphh, VBAph)
      REORDER(k, j, i)
      chrono[<span style="color: #50a14f;">"doubles:particles:4"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TBphh[E + j*Nv + i*NoNv] * VACph[E + k*Nv]; P1</span>
      chrono[<span style="color: #50a14f;">"doubles:particles:5"</span>].start();
      DGEMM_PARTICLES(TBphh, VACph)
      REORDER(j, i, k)
      chrono[<span style="color: #50a14f;">"doubles:particles:5"</span>].stop();
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TBphh[E + j*Nv + k*NoNv] * VCAph[E + i*Nv]; P4</span>
      chrono[<span style="color: #50a14f;">"doubles:particles:6"</span>].start();
      DGEMM_PARTICLES(TBphh, VCAph)
      REORDER(j, k, i)
      chrono[<span style="color: #50a14f;">"doubles:particles:6"</span>].stop();
    }
    chrono[<span style="color: #50a14f;">"doubles:particles"</span>].stop();

<span style="color: #e44649;">  #undef</span> REORDER
<span style="color: #e44649;">  #undef</span> DGEMM_HOLES
<span style="color: #e44649;">  #undef</span> DGEMM_PARTICLES
<span style="color: #e44649;">  #undef</span> _IJK_
<span style="color: #e44649;">  #else</span>
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">k</span> = 0; k &lt; No; k++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">j</span> = 0; j &lt; No; j++)
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 0; i &lt; No; i++){
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">ijk</span> = i + j*No + k*NoNo
                ,  <span style="color: #8b4513;">jk</span> = j + k*No
                ;
      Tijk[ijk] = 0.0; <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">:important</span>
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">HOLE DIAGRAMS: TABHH and VHHHA</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">L</span> = 0; L &lt; No; L++){
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[abLj] * V[Lcik]        H1</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[baLi] * V[Lcjk]        H0      TODO: conjugate T for complex</span>
        Tijk[ijk] -= TABhh[L + j*No] * VhhhC[i + k*No + L*NoNo];
        Tijk[ijk] -= TABhh[i + L*No] * VhhhC[j + k*No + L*NoNo];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[acLk] * V[Lbij]        H5</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[caLi] * V[Lbkj]        H3</span>
        Tijk[ijk] -= TAChh[L + k*No] * VhhhB[i + j*No + L*NoNo];
        Tijk[ijk] -= TAChh[i + L*No] * VhhhB[k + j*No + L*NoNo];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[bcLk] * V[Laji]        H2</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[cbLj] * V[Laki]        H4</span>
        Tijk[ijk] -= TBChh[L + k*No] * VhhhA[j + i*No + L*NoNo];
        Tijk[ijk] -= TBChh[j + L*No] * VhhhA[k + i*No + L*NoNo];
      }
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PARTILCE DIAGRAMS: TAPHH and VABPH</span>
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">E</span> = 0; E &lt; Nv; E++) {
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[aEij] * V[bcEk]        P0</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[aEik] * V[cbEj]        P3 // TODO: CHECK THIS ONE, I DONT KNOW</span>
        Tijk[ijk] += TAphh[E + i*Nv + j*NoNv] * VBCph[E + k*Nv];
        Tijk[ijk] += TAphh[E + i*Nv + k*NoNv] * VCBph[E + j*Nv];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[cEki] * V[abEj]        P5</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[cEkj] * V[baEi]        P2</span>
        Tijk[ijk] += TCphh[E + k*Nv + i*NoNv] * VABph[E + j*Nv];
        Tijk[ijk] += TCphh[E + k*Nv + j*NoNv] * VBAph[E + i*Nv];

        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[bEji] * V[acEk]        P1</span>
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">t[bEjk] * V[caEi]        P4</span>
        Tijk[ijk] += TBphh[E + j*Nv + i*NoNv] * VACph[E + k*Nv];
        Tijk[ijk] += TBphh[E + j*Nv + k*NoNv] * VCAph[E + i*Nv];
      }

    }
<span style="color: #e44649;">  #endif</span>
  }

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org174086a" class="outline-3">
<h3 id="org174086a"><span class="section-number-3">1.8</span> Blas</h3>
<div class="outline-text-3" id="text-1-8">
<p>
The main matrix-matrix multiplication method used in this algorithm
is mainly using the <code>DGEMM</code> function, which we declare as
<code>extern</code> since it should be known only at link-time.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {
  <span style="color: #a626a4;">extern</span> <span style="color: #50a14f;">"C"</span> {
    <span style="color: #c18401;">void</span> <span style="color: #0184bc;">dgemm_</span>(
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">char</span> *<span style="color: #8b4513;">transa</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">char</span> *<span style="color: #8b4513;">transb</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">m</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">n</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">k</span>,
      <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">alpha</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">A</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">lda</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">B</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">ldb</span>,
      <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">beta</span>,
      <span style="color: #c18401;">double</span> *<span style="color: #8b4513;">C</span>,
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> *<span style="color: #8b4513;">ldc</span>
    );
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org51e9818" class="outline-3">
<h3 id="org51e9818"><span class="section-number-3">1.9</span> Atrip</h3>
<div class="outline-text-3" id="text-1-9">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;sstream&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;string&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;map&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;chrono&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;ctf.hpp&gt;</span>

<span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span> {

  <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Atrip</span> {

    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span>;
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">np</span>;
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">void</span> <span style="color: #0184bc;">init</span>();

    <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Input</span> {
      <span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; *<span style="color: #8b4513;">ei</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">ea</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Tph</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Tpphh</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Vpphh</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Vhhhp</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        , *<span style="color: #8b4513;">Vppph</span> = <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                        ;
      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">maxIterations</span> = 0, <span style="color: #8b4513;">iterationMod</span> = -1;
      <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">barrier</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
      <span style="color: #c18401;">bool</span> <span style="color: #8b4513;">chrono</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_epsilon_i</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { ei = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_epsilon_a</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { ea = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Tai</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Tph = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Tabij</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Tpphh = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Vabij</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Vpphh = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Vijka</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Vhhhp = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_Vabci</span>(<span style="font-weight: bold; text-decoration: underline;">CTF</span>::<span style="color: #c18401;">Tensor</span>&lt;<span style="color: #c18401;">double</span>&gt; * <span style="color: #8b4513;">t</span>) { Vppph = t; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_maxIterations</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>) { maxIterations = i; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_iterationMod</span>(<span style="color: #c18401;">int</span> <span style="color: #8b4513;">i</span>) { iterationMod = i; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_barrier</span>(<span style="color: #c18401;">bool</span> <span style="color: #8b4513;">i</span>) { barrier = i; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
      <span style="color: #c18401;">Input</span>&amp; <span style="color: #0184bc;">with_chrono</span>(<span style="color: #c18401;">bool</span> <span style="color: #8b4513;">i</span>) { chrono = i; <span style="color: #a626a4;">return</span> *<span style="color: #a626a4;">this</span>; }
    };

    <span style="color: #a626a4;">struct</span> <span style="color: #c18401;">Output</span> {
      <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>;
    };
    <span style="color: #a626a4;">static</span> <span style="color: #c18401;">Output</span> <span style="color: #0184bc;">run</span>(<span style="color: #c18401;">Input</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">in</span>);
  };

}
</pre>
</div>
</div>

<div id="outline-container-orgfe5d2c3" class="outline-4">
<h4 id="orgfe5d2c3"><span class="section-number-4">1.9.1</span> Main</h4>
<div class="outline-text-4" id="text-1-9-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;iomanip&gt;</span>

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Atrip.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Utils.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Equations.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/SliceUnion.hpp&gt;</span>
<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Unions.hpp&gt;</span>

<span style="color: #a626a4;">using</span> <span style="color: #a626a4;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">atrip</span>;

<span style="color: #c18401;">int</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #8b4513;">rank</span>;
<span style="color: #c18401;">int</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #8b4513;">np</span>;

<span style="color: #c18401;">void</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #0184bc;">init</span>()  {
  MPI_Comm_rank(MPI_COMM_WORLD, &amp;<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank);
  MPI_Comm_size(MPI_COMM_WORLD, &amp;<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::np);
}

<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #c18401;">Output</span> <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #0184bc;">run</span>(<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::<span style="color: #c18401;">Input</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">in</span>) {

  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">np</span> = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::np;
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">int</span> <span style="color: #8b4513;">rank</span> = <span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank;
  <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">universe</span> = in.ei-&gt;wrld-&gt;comm;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Timings in seconds ================================================{{{1</span>
  <span style="color: #c18401;">Timings</span> <span style="color: #8b4513;">chrono</span>{};

  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">No</span> = in.ei-&gt;lens[0];
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">Nv</span> = in.ea-&gt;lens[0];
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"No: "</span> &lt;&lt; No &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"Nv: "</span> &lt;&lt; Nv &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">allocate the three scratches, see piecuch</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt;<span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">Tijk</span>(No*No*No) <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">doubles only (see piecuch)</span>
                    , <span style="color: #8b4513;">Zijk</span>(No*No*No) <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">singles + doubles (see piecuch)</span>
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">we need local copies of the following tensors on every</span>
                    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">rank</span>
                    , <span style="color: #8b4513;">epsi</span>(No)
                    , <span style="color: #8b4513;">epsa</span>(Nv)
                    , <span style="color: #8b4513;">Tai</span>(No * Nv)
                    ;

  in.ei-&gt;read_all(epsi.data());
  in.ea-&gt;read_all(epsa.data());
  in.Tph-&gt;read_all(Tai.data());

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMMUNICATOR CONSTRUCTION ========================================={{{1</span>
  <span style="color: #a0a1a7; font-weight: bold;">//</span>
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">Construct a new communicator living only on a single rank</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">child_size</span> = 1
    , <span style="color: #8b4513;">child_rank</span>
    ;
  <span style="color: #a626a4;">const</span>
  <span style="color: #c18401;">int</span> <span style="color: #8b4513;">color</span> = rank / child_size
    , <span style="color: #8b4513;">crank</span> = rank % child_size
    ;
  <span style="color: #c18401;">MPI_Comm</span> <span style="color: #8b4513;">child_comm</span>;
  <span style="color: #a626a4;">if</span> (np == 1) {
    child_comm = universe;
  } <span style="color: #a626a4;">else</span> {
    MPI_Comm_split(universe, color, crank, &amp;child_comm);
    MPI_Comm_rank(child_comm, &amp;child_rank);
    MPI_Comm_size(child_comm, &amp;child_size);
  }


  chrono[<span style="color: #50a14f;">"nv-slices"</span>].start();
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">BUILD SLICES PARAMETRIZED BY NV ==================================={{{1</span>
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"BUILD NV-SLICES\n"</span>;
  <span style="color: #c18401;">TAPHH</span> <span style="color: #8b4513;">taphh</span>(*in.Tpphh, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
  <span style="color: #c18401;">HHHA</span>  <span style="color: #8b4513;">hhha</span>(*in.Vhhhp, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
  chrono[<span style="color: #50a14f;">"nv-slices"</span>].stop();

  chrono[<span style="color: #50a14f;">"nv-nv-slices"</span>].start();
  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">BUILD SLICES PARAMETRIZED BY NV x NV =============================={{{1</span>
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"BUILD NV x NV-SLICES\n"</span>;
  <span style="color: #c18401;">ABPH</span> <span style="color: #8b4513;">abph</span>(*in.Vppph, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
  <span style="color: #c18401;">ABHH</span> <span style="color: #8b4513;">abhh</span>(*in.Vpphh, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
  <span style="color: #c18401;">TABHH</span> <span style="color: #8b4513;">tabhh</span>(*in.Tpphh, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv, (<span style="color: #c18401;">size_t</span>)np, child_comm, universe);
  chrono[<span style="color: #50a14f;">"nv-nv-slices"</span>].stop();

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">all tensors</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">vector</span>&lt; <span style="color: #c18401;">SliceUnion</span>* &gt; <span style="color: #8b4513;">unions</span> = {&amp;taphh, &amp;hhha, &amp;abph, &amp;abhh, &amp;tabhh};

  <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">CONSTRUCT TUPLE LIST ==============================================={{{1</span>
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"BUILD TUPLE LIST\n"</span>;
  <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuplesList</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::move(getTuplesList(Nv));
  WITH_RANK &lt;&lt; <span style="color: #50a14f;">"tupList.size() = "</span> &lt;&lt; tuplesList.size() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">GET ABC INDEX RANGE FOR RANK ======================================{{{1</span>
  <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">abcIndex</span> = getABCRange(np, rank, tuplesList);
  <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">nIterations</span> = abcIndex.second - abcIndex.first;

<span style="color: #e44649;">#ifdef</span> ATRIP_BENCHMARK
  { <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">maxIterations</span> = in.maxIterations;
    <span style="color: #a626a4;">if</span> (maxIterations != 0) {
      abcIndex.second = abcIndex.first + maxIterations % (nIterations + 1);
      nIterations = maxIterations % (nIterations + 1);
    }
  }
<span style="color: #e44649;">#endif</span>

  WITH_RANK &lt;&lt; <span style="color: #50a14f;">"abcIndex = "</span> &lt;&lt; pretty_print(abcIndex) &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"#iterations: "</span> &lt;&lt; nIterations &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">first abc</span>
  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">firstAbc</span> = tuplesList[abcIndex.first];


  <span style="color: #c18401;">double</span> <span style="color: #8b4513;">energy</span>(0.);


  <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span> <span style="color: #c18401;">isFakeTuple</span>
    = [&amp;<span style="color: #8b4513;">tuplesList</span>](<span style="color: #c18401;">size_t</span> <span style="color: #a626a4;">const</span> <span style="color: #8b4513;">i</span>) { <span style="color: #a626a4;">return</span> i &gt;= tuplesList.size(); };


  <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">communicateDatabase</span>
    = [ &amp;<span style="color: #8b4513;">unions</span>
      , <span style="font-weight: bold; text-decoration: underline;">np</span>
      , &amp;<span style="color: #8b4513;">chrono</span>
      ] (<span style="color: #c18401;">ABCTuple</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">abc</span>, <span style="color: #c18401;">MPI_Comm</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">c</span>) -&gt; <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Database {

        chrono[<span style="color: #50a14f;">"db:comm:type:do"</span>].start();
        <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">MPI_LDB_ELEMENT</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="font-weight: bold; text-decoration: underline;">mpi</span>::localDatabaseElement();
        chrono[<span style="color: #50a14f;">"db:comm:type:do"</span>].stop();

        chrono[<span style="color: #50a14f;">"db:comm:ldb"</span>].start();
        <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabase</span> <span style="color: #8b4513;">ldb</span>;

        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tensor</span>: unions) {
          <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">tensorDb</span> = tensor-&gt;buildLocalDatabase(abc);
          ldb.insert(ldb.end(), tensorDb.begin(), tensorDb.end());
        }
        chrono[<span style="color: #50a14f;">"db:comm:ldb"</span>].stop();

        <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Database</span> <span style="color: #8b4513;">db</span>(np * ldb.size(), ldb[0]);

        chrono[<span style="color: #50a14f;">"oneshot-db:comm:allgather"</span>].start();
        chrono[<span style="color: #50a14f;">"db:comm:allgather"</span>].start();
        MPI_Allgather( ldb.data()
                     , ldb.size()
                     , MPI_LDB_ELEMENT
                     , db.data()
                     , ldb.size()
                     , MPI_LDB_ELEMENT
                     , c);
        chrono[<span style="color: #50a14f;">"db:comm:allgather"</span>].stop();
        chrono[<span style="color: #50a14f;">"oneshot-db:comm:allgather"</span>].stop();

        chrono[<span style="color: #50a14f;">"db:comm:type:free"</span>].start();
        MPI_Type_free(&amp;MPI_LDB_ELEMENT);
        chrono[<span style="color: #50a14f;">"db:comm:type:free"</span>].stop();

        <span style="color: #a626a4;">return</span> db;
      };

  <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">doIOPhase</span>
    = [&amp;<span style="color: #8b4513;">unions</span>, &amp;<span style="color: #8b4513;">rank</span>, &amp;<span style="color: #8b4513;">np</span>, &amp;<span style="color: #8b4513;">universe</span>, &amp;<span style="color: #8b4513;">chrono</span>] (<span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Database</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">db</span>) {

    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">localDBLength</span> = db.size() / np;

    <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">sendTag</span> = 0
         , <span style="color: #8b4513;">recvTag</span> = rank * localDBLength
         ;

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">RECIEVE PHASE ======================================================</span>
    {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">At this point, we have already send to everyone that fits</span>
      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">begin</span> = &amp;db[rank * localDBLength]
                , <span style="color: #8b4513;">end</span>   = begin + localDBLength
                ;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">it</span> = begin; it != end; ++it) {
        recvTag++;
        <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">el</span> = *it;
        <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span> = unionByName(unions, el.name);

        <span style="color: #c18401;">WITH_DBG</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #8b4513;">cout</span>
          &lt;&lt; rank &lt;&lt; <span style="color: #50a14f;">":r"</span>
          &lt;&lt; <span style="color: #50a14f;">"&#9839;"</span> &lt;&lt; recvTag &lt;&lt; <span style="color: #50a14f;">" =&gt;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#171;n"</span> &lt;&lt; el.name
          &lt;&lt; <span style="color: #50a14f;">", t"</span> &lt;&lt; el.info.type
          &lt;&lt; <span style="color: #50a14f;">", s"</span> &lt;&lt; el.info.state
          &lt;&lt; <span style="color: #50a14f;">"&#187;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8857; {"</span> &lt;&lt; rank &lt;&lt; <span style="color: #50a14f;">"&#8656;"</span> &lt;&lt; el.info.from.rank
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.from.source &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8756; {"</span> &lt;&lt; el.info.tuple[0]
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.tuple[1]
                    &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">"\n"</span>
          ;

        chrono[<span style="color: #50a14f;">"db:io:recv"</span>].start();
        u.receive(el.info, recvTag);
        chrono[<span style="color: #50a14f;">"db:io:recv"</span>].stop();

      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">recv</span>
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">SEND PHASE =========================================================</span>
    <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">otherRank</span> = 0; otherRank&lt;np; otherRank++) {
      <span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">begin</span> = &amp;db[otherRank * localDBLength]
                , <span style="color: #8b4513;">end</span> = begin + localDBLength
                ;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">it</span> = begin; it != end; ++it) {
        sendTag++;
        <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">LocalDatabaseElement</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">el</span> = *it;

        <span style="color: #a626a4;">if</span> (el.info.from.rank != rank) <span style="color: #a626a4;">continue</span>;

        <span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span> = unionByName(unions, el.name);
        <span style="color: #c18401;">WITH_DBG</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #8b4513;">cout</span>
          &lt;&lt; rank &lt;&lt; <span style="color: #50a14f;">":s"</span>
          &lt;&lt; <span style="color: #50a14f;">"&#9839;"</span> &lt;&lt; sendTag &lt;&lt; <span style="color: #50a14f;">" =&gt;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#171;n"</span> &lt;&lt; el.name
          &lt;&lt; <span style="color: #50a14f;">", t"</span> &lt;&lt; el.info.type
          &lt;&lt; <span style="color: #50a14f;">", s"</span> &lt;&lt; el.info.state
          &lt;&lt; <span style="color: #50a14f;">"&#187;"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8857; {"</span> &lt;&lt; el.info.from.rank &lt;&lt; <span style="color: #50a14f;">"&#8658;"</span> &lt;&lt; otherRank
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.from.source &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">" &#8756; {"</span> &lt;&lt; el.info.tuple[0]
                    &lt;&lt; <span style="color: #50a14f;">", "</span>
                    &lt;&lt; el.info.tuple[1]
                    &lt;&lt; <span style="color: #50a14f;">"}"</span>
          &lt;&lt; <span style="color: #50a14f;">"\n"</span>
          ;

        chrono[<span style="color: #50a14f;">"db:io:send"</span>].start();
        u.send(otherRank, el.info, sendTag);
        chrono[<span style="color: #50a14f;">"db:io:send"</span>].stop();

      } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">send phase</span>

    } <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">otherRank</span>


  };

<span style="color: #e44649;">#if</span> <span style="color: #e44649;">defined</span>(HAVE_OCD) || <span style="color: #e44649;">defined</span>(ATRIP_PRINT_TUPLES)
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #c18401;">map</span>&lt;<span style="color: #c18401;">ABCTuple</span>, <span style="color: #c18401;">double</span>&gt; <span style="color: #8b4513;">tupleEnergies</span>;
<span style="color: #e44649;">#endif</span>

  <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">doublesFlops</span>
    = <span style="color: #c18401;">double</span>(No)
    * <span style="color: #c18401;">double</span>(No)
    * <span style="color: #c18401;">double</span>(No)
    * (<span style="color: #c18401;">double</span>(<span style="color: #8b4513;">No</span>) + <span style="color: #c18401;">double</span>(Nv))
    * 2
    * 6
    / 1e9
    ;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">START MAIN LOOP ======================================================{{{1</span>

  <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="color: #c18401;">Database</span> <span style="color: #8b4513;">db</span>;

  <span style="color: #a626a4;">for</span> ( <span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = abcIndex.first, <span style="color: #8b4513;">iteration</span> = 1
      ; i &lt; abcIndex.second
      ; i++, iteration++
      ) {
    chrono[<span style="color: #50a14f;">"iterations"</span>].start();

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check overhead from chrono over all iterations</span>
    chrono[<span style="color: #50a14f;">"start:stop"</span>].start(); chrono[<span style="color: #50a14f;">"start:stop"</span>].stop();

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check overhead of doing a barrier at the beginning</span>
    chrono[<span style="color: #50a14f;">"oneshot-mpi:barrier"</span>].start();
    chrono[<span style="color: #50a14f;">"mpi:barrier"</span>].start();
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: REMOVE</span>
    <span style="color: #a626a4;">if</span> (in.barrier == 1)
    MPI_Barrier(universe);
    chrono[<span style="color: #50a14f;">"mpi:barrier"</span>].stop();
    chrono[<span style="color: #50a14f;">"oneshot-mpi:barrier"</span>].stop();

    <span style="color: #a626a4;">if</span> (iteration % in.iterationMod == 0) {
      LOG(0,<span style="color: #50a14f;">"Atrip"</span>)
        &lt;&lt; <span style="color: #50a14f;">"iteration "</span> &lt;&lt; iteration
        &lt;&lt; <span style="color: #50a14f;">" ["</span> &lt;&lt; 100 * iteration / nIterations &lt;&lt; <span style="color: #50a14f;">"%]"</span>
        &lt;&lt; <span style="color: #50a14f;">" ("</span> &lt;&lt; doublesFlops * iteration / chrono[<span style="color: #50a14f;">"doubles"</span>].count()
        &lt;&lt; <span style="color: #50a14f;">"GF)"</span>
        &lt;&lt; <span style="color: #50a14f;">" ("</span> &lt;&lt; doublesFlops * iteration / chrono[<span style="color: #50a14f;">"iterations"</span>].count()
        &lt;&lt; <span style="color: #50a14f;">"GF)"</span>
        &lt;&lt; <span style="color: #50a14f;">" ===========================\n"</span>;

      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PRINT TIMINGS</span>
      <span style="color: #a626a4;">if</span> (in.chrono)
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: chrono)
        LOG(1, <span style="color: #50a14f;">" "</span>) &lt;&lt; pair.first &lt;&lt; <span style="color: #50a14f;">" :: "</span>
                    &lt;&lt; pair.second.count()
                    &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::endl;

    }

    <span style="color: #a626a4;">const</span> <span style="color: #c18401;">ABCTuple</span> <span style="color: #8b4513;">abc</span> = isFakeTuple(i)
                       ? tuplesList[tuplesList.size() - 1]
                       : tuplesList[i]
                 , *<span style="color: #8b4513;">abcNext</span> = i == (abcIndex.second - 1)
                            ? <span style="font-weight: bold; text-decoration: underline;">nullptr</span>
                            : isFakeTuple(i + 1)
                            ? &amp;tuplesList[tuplesList.size() - 1]
                            : &amp;tuplesList[i + 1]
                 ;

    chrono[<span style="color: #50a14f;">"with_rank"</span>].start();
    WITH_RANK &lt;&lt; <span style="color: #50a14f;">" :it "</span> &lt;&lt; iteration
              &lt;&lt; <span style="color: #50a14f;">" :abc "</span> &lt;&lt; pretty_print(abc)
              &lt;&lt; <span style="color: #50a14f;">" :abcN "</span>
              &lt;&lt; (abcNext ? pretty_print(*abcNext) : <span style="color: #50a14f;">"None"</span>)
              &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
    chrono[<span style="color: #50a14f;">"with_rank"</span>].stop();


    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMM FIRST DATABASE ================================================{{{1</span>
    <span style="color: #a626a4;">if</span> (i == abcIndex.first) {
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database ............ \n"</span>;
      <span style="color: #a626a4;">const</span> <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">__db</span> = communicateDatabase(abc, universe);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database communicated \n"</span>;
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database io phase \n"</span>;
      doIOPhase(__db);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__:first database io phase DONE\n"</span>;
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__::::Unwrapping all slices for first database\n"</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: unions) u-&gt;unwrapAll(abc);
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__first__::::Unwrapping all slices for first database DONE\n"</span>;
      MPI_Barrier(universe);
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMM NEXT DATABASE ================================================={{{1</span>
    <span style="color: #a626a4;">if</span> (abcNext) {
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__comm__:"</span> &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"th communicating database\n"</span>;
      chrono[<span style="color: #50a14f;">"db:comm"</span>].start();
      <span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">const auto db = communicateDatabase(*abcNext, universe);</span>
      db = communicateDatabase(*abcNext, universe);
      chrono[<span style="color: #50a14f;">"db:comm"</span>].stop();
      chrono[<span style="color: #50a14f;">"db:io"</span>].start();
      doIOPhase(db);
      chrono[<span style="color: #50a14f;">"db:io"</span>].stop();
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__comm__:"</span> &lt;&lt;  iteration &lt;&lt; <span style="color: #50a14f;">"th database io phase DONE\n"</span>;
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMPUTE DOUBLES ===================================================={{{1</span>
    OCD_Barrier(universe);
    <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>isFakeTuple(i)) {
      WITH_RANK &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th doubles\n"</span>;
      WITH_CHRONO(chrono[<span style="color: #50a14f;">"oneshot-unwrap"</span>],
      WITH_CHRONO(chrono[<span style="color: #50a14f;">"unwrap"</span>],
      WITH_CHRONO(chrono[<span style="color: #50a14f;">"unwrap:doubles"</span>],
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: <span style="color: #a626a4;">decltype</span>(unions){&amp;abph, &amp;hhha, &amp;taphh, &amp;tabhh}) {
          u-&gt;unwrapAll(abc);
        }
      )))
      chrono[<span style="color: #50a14f;">"oneshot-doubles"</span>].start();
      chrono[<span style="color: #50a14f;">"doubles"</span>].start();
      doublesContribution( abc, (<span style="color: #c18401;">size_t</span>)No, (<span style="color: #c18401;">size_t</span>)Nv
                         <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VABCI</span>
                         , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, abc)
                         , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC, abc)
                         , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, abc)
                         , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BA, abc)
                         , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::CA, abc)
                         , abph.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::CB, abc)
                         <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- VHHHA</span>
                         , hhha.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, abc)
                         , hhha.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, abc)
                         , hhha.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::C, abc)
                         <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TA</span>
                         , taphh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::A, abc)
                         , taphh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::B, abc)
                         , taphh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::C, abc)
                         <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TABIJ</span>
                         , tabhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, abc)
                         , tabhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC, abc)
                         , tabhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, abc)
                         <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">-- TIJK</span>
                         , Tijk.data()
                         , chrono
                         );
      WITH_RANK &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th doubles done\n"</span>;
      chrono[<span style="color: #50a14f;">"doubles"</span>].stop();
      chrono[<span style="color: #50a14f;">"oneshot-doubles"</span>].stop();
    }

    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMPUTE SINGLES =================================================== {{{1</span>
    OCD_Barrier(universe);
    <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>isFakeTuple(i)) {
      WITH_CHRONO(chrono[<span style="color: #50a14f;">"oneshot-unwrap"</span>],
      WITH_CHRONO(chrono[<span style="color: #50a14f;">"unwrap"</span>],
      WITH_CHRONO(chrono[<span style="color: #50a14f;">"unwrap:singles"</span>],
        abhh.unwrapAll(abc);
      )))
      chrono[<span style="color: #50a14f;">"reorder"</span>].start();
      <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">I</span>(0); I &lt; Zijk.size(); I++) Zijk[I] = Tijk[I];
      chrono[<span style="color: #50a14f;">"reorder"</span>].stop();
      chrono[<span style="color: #50a14f;">"singles"</span>].start();
      singlesContribution( No, Nv, abc
                         , Tai.data()
                         , abhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AB, abc)
                         , abhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::AC, abc)
                         , abhh.unwrapSlice(<span style="font-weight: bold; text-decoration: underline;">Slice</span>::BC, abc)
                         , Zijk.data());
      chrono[<span style="color: #50a14f;">"singles"</span>].stop();
    }


    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMPUTE ENERGY ==================================================== {{{1</span>
    <span style="color: #a626a4;">if</span> (<span style="font-weight: bold;">!</span>isFakeTuple(i)) {
      <span style="color: #c18401;">double</span> <span style="color: #8b4513;">tupleEnergy</span>(0.);

      <span style="color: #c18401;">int</span> <span style="color: #8b4513;">distinct</span>(0);
      <span style="color: #a626a4;">if</span> (abc[0] == abc[1]) distinct++;
      <span style="color: #a626a4;">if</span> (abc[1] == abc[2]) distinct--;
      <span style="color: #a626a4;">const</span> <span style="color: #c18401;">double</span> <span style="color: #8b4513;">epsabc</span>(epsa[abc[0]] + epsa[abc[1]] + epsa[abc[2]]);

      chrono[<span style="color: #50a14f;">"energy"</span>].start();
      <span style="color: #a626a4;">if</span> ( distinct == 0)
        tupleEnergy = getEnergyDistinct(epsabc, epsi, Tijk, Zijk);
      <span style="color: #a626a4;">else</span>
        tupleEnergy = getEnergySame(epsabc, epsi, Tijk, Zijk);
      chrono[<span style="color: #50a14f;">"energy"</span>].stop();

<span style="color: #e44649;">#if</span> <span style="color: #e44649;">defined</span>(HAVE_OCD) || <span style="color: #e44649;">defined</span>(ATRIP_PRINT_TUPLES)
      tupleEnergies[abc] = tupleEnergy;
<span style="color: #e44649;">#endif</span>

      energy += tupleEnergy;

    }

    <span style="color: #a626a4;">if</span> (isFakeTuple(i)) {
      <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">fake iterations should also unwrap whatever they got</span>
      WITH_RANK &lt;&lt; iteration
                &lt;&lt; <span style="color: #50a14f;">"th unwrapping because of fake in "</span>
                &lt;&lt; i &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: unions) u-&gt;unwrapAll(abc);
    }

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
    <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">u</span>: unions) {
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__dups__:"</span>
                &lt;&lt; iteration
                &lt;&lt; <span style="color: #50a14f;">"-th n"</span> &lt;&lt; u-&gt;name &lt;&lt; <span style="color: #50a14f;">" checking duplicates\n"</span>;
      u-&gt;checkForDuplicates();
    }
<span style="color: #e44649;">#endif</span>


    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">CLEANUP UNIONS ===================================================={{{1</span>
    OCD_Barrier(universe);
    <span style="color: #a626a4;">if</span> (abcNext) {
      chrono[<span style="color: #50a14f;">"gc"</span>].start();
      WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__:"</span> &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th cleaning up.......\n"</span>;
      <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">u</span>: unions) {

        u-&gt;unwrapAll(abc);
        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__:n"</span> &lt;&lt; u-&gt;name  &lt;&lt; <span style="color: #50a14f;">" :it "</span> &lt;&lt; iteration
                  &lt;&lt; <span style="color: #50a14f;">" :abc "</span> &lt;&lt; pretty_print(abc)
                  &lt;&lt; <span style="color: #50a14f;">" :abcN "</span> &lt;&lt; pretty_print(*abcNext)
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">slice</span>: u-&gt;slices)
          WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__:guts:"</span> &lt;&lt; slice.info &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
        u-&gt;clearUnusedSlicesForNext(*abcNext);

        WITH_RANK &lt;&lt; <span style="color: #50a14f;">"__gc__: checking validity\n"</span>;

<span style="color: #e44649;">#ifdef</span> HAVE_OCD
        <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">check for validity of the slices</span>
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">type</span>: u-&gt;sliceTypes) {
          <span style="color: #a626a4;">auto</span> <span style="color: #8b4513;">tuple</span> = <span style="font-weight: bold; text-decoration: underline;">Slice</span>::subtupleBySlice(abc, type);
        <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span>&amp; <span style="color: #8b4513;">slice</span>: u-&gt;slices) {
          <span style="color: #a626a4;">if</span> ( slice.info.type == type
             &amp;&amp; slice.info.tuple == tuple
             &amp;&amp; slice.isDirectlyFetchable()
             ) {
            <span style="color: #a626a4;">if</span> (slice.info.state == <span style="font-weight: bold; text-decoration: underline;">Slice</span>::Dispatched)
              <span style="color: #a626a4;">throw</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::domain_error( <span style="color: #50a14f;">"This slice should not be undispatched! "</span>
                                     + pretty_print(slice.info));
          }
        }
        }
<span style="color: #e44649;">#endif</span>


      }
      chrono[<span style="color: #50a14f;">"gc"</span>].stop();
    }

      WITH_RANK &lt;&lt; iteration &lt;&lt; <span style="color: #50a14f;">"-th cleaning up....... DONE\n"</span>;

    chrono[<span style="color: #50a14f;">"iterations"</span>].stop();
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">ITERATION END ====================================================={{{1</span>

  }
    <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">END OF MAIN LOOP</span>

  MPI_Barrier(universe);

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PRINT TUPLES ========================================================={{{1</span>
<span style="color: #e44649;">#if</span> <span style="color: #e44649;">defined</span>(HAVE_OCD) || <span style="color: #e44649;">defined</span>(ATRIP_PRINT_TUPLES)
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"tuple energies"</span> &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  <span style="color: #a626a4;">for</span> (<span style="color: #c18401;">size_t</span> <span style="color: #8b4513;">i</span> = 0; i &lt; np; i++) {
    MPI_Barrier(universe);
    <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: tupleEnergies) {
      <span style="color: #a626a4;">if</span> (i == rank)
        <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; pair.first[0]
                  &lt;&lt; <span style="color: #50a14f;">" "</span> &lt;&lt; pair.first[1]
                  &lt;&lt; <span style="color: #50a14f;">" "</span> &lt;&lt; pair.first[2]
                  &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setprecision(15) &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setw(23)
                  &lt;&lt; <span style="color: #50a14f;">" tupleEnergy: "</span> &lt;&lt; pair.second
                  &lt;&lt; <span style="color: #50a14f;">"\n"</span>
                  ;
    }
  }
<span style="color: #e44649;">#endif</span>

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">COMMUNICATE THE ENERGIES ============================================={{{1</span>
  LOG(0,<span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"COMMUNICATING ENERGIES \n"</span>;
  <span style="color: #c18401;">double</span> <span style="color: #8b4513;">globalEnergy</span> = 0;
  MPI_Reduce(&amp;energy, &amp;globalEnergy, 1, MPI_DOUBLE, MPI_SUM, 0, universe);

  WITH_RANK &lt;&lt; <span style="color: #50a14f;">"local energy "</span> &lt;&lt; energy &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(0, <span style="color: #50a14f;">"Atrip"</span>) &lt;&lt; <span style="color: #50a14f;">"Energy: "</span>
    &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setprecision(15) &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::setw(23)
    &lt;&lt; (- globalEnergy) &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::endl;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">PRINT TIMINGS {{{1</span>
  <span style="color: #a626a4;">if</span> (in.chrono)
  <span style="color: #a626a4;">for</span> (<span style="color: #a626a4;">auto</span> <span style="color: #a626a4;">const</span>&amp; <span style="color: #8b4513;">pair</span>: chrono)
    LOG(0,<span style="color: #50a14f;">"atrip:chrono"</span>) &lt;&lt; pair.first &lt;&lt; <span style="color: #50a14f;">" "</span>
                          &lt;&lt; pair.second.count() &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::endl;


  LOG(0, <span style="color: #50a14f;">"atrip:flops(doubles)"</span>)
    &lt;&lt; nIterations * doublesFlops / chrono[<span style="color: #50a14f;">"doubles"</span>].count() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;
  LOG(0, <span style="color: #50a14f;">"atrip:flops(iterations)"</span>)
    &lt;&lt; nIterations * doublesFlops / chrono[<span style="color: #50a14f;">"iterations"</span>].count() &lt;&lt; <span style="color: #50a14f;">"\n"</span>;

  <span style="color: #a0a1a7; font-weight: bold;">// </span><span style="color: #a0a1a7;">TODO: change the sign in  the getEnergy routines</span>
  <span style="color: #a626a4;">return</span> { - globalEnergy };

}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgefe0704" class="outline-3">
<h3 id="orgefe0704"><span class="section-number-3">1.10</span> Debug</h3>
<div class="outline-text-3" id="text-1-10">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once
<span style="color: #e44649;">#define</span> <span style="color: #8b4513;">ATRIP_BENCHMARK</span>
<span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">#define ATRIP_DONT_SLICE</span>
<span style="color: #e44649;">#define</span> <span style="color: #8b4513;">ATRIP_DEBUG</span> 1
<span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">#define ATRIP_WORKLOAD_DUMP</span>
<span style="color: #e44649;">#define</span> <span style="color: #8b4513;">ATRIP_USE_DGEMM</span>
<span style="color: #a0a1a7; font-weight: bold;">//</span><span style="color: #a0a1a7;">#define ATRIP_PRINT_TUPLES</span>

<span style="color: #e44649;">#define</span> <span style="color: #0184bc;">LOG</span>(<span style="color: #8b4513;">level</span>, <span style="color: #8b4513;">name</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0) <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; name &lt;&lt; <span style="color: #50a14f;">": "</span>

<span style="color: #e44649;">#if</span> ATRIP_DEBUG == 4
<span style="color: #e44649;">#  pragma</span> message(<span style="color: #50a14f;">"WARNING: You have OCD debugging ABC triples "</span>\
                  <span style="color: #50a14f;">"expect GB of output and consult your therapist"</span>)
<span style="color: #e44649;">#  include</span> <span style="color: #50a14f;">&lt;dbg.h&gt;</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">HAVE_OCD</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>) MPI_Barrier(com)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == r)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...) dbg(__VA_ARGS__)
<span style="color: #e44649;">#elif</span> ATRIP_DEBUG == 3
<span style="color: #e44649;">#  pragma</span> message(<span style="color: #50a14f;">"WARNING: You have crazy debugging ABC triples,"</span>\
                  <span style="color: #50a14f;">" expect GB of output"</span>)
<span style="color: #e44649;">#  include</span> <span style="color: #50a14f;">&lt;dbg.h&gt;</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == r)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...) dbg(__VA_ARGS__)
<span style="color: #e44649;">#elif</span> ATRIP_DEBUG == 2
<span style="color: #e44649;">#  pragma</span> message(<span style="color: #50a14f;">"WARNING: You have some debugging info for ABC triples"</span>)
<span style="color: #e44649;">#  include</span> <span style="color: #50a14f;">&lt;dbg.h&gt;</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == 0)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank == r)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span>
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...) dbg(__VA_ARGS__)
<span style="color: #e44649;">#elif</span> ATRIP_DEBUG == 1
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">OCD_Barrier</span>(<span style="color: #8b4513;">com</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_OCD</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_ROOT</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">WITH_SPECIAL</span>(<span style="color: #8b4513;">r</span>) <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_RANK</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>) <span style="font-weight: bold; text-decoration: underline;">std</span>::cout &lt;&lt; <span style="font-weight: bold; text-decoration: underline;">atrip</span>::<span style="font-weight: bold; text-decoration: underline;">Atrip</span>::rank &lt;&lt; <span style="color: #50a14f;">": "</span>
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_DBG</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #8b4513;">WITH_CRAZY_DEBUG</span> <span style="color: #a626a4;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>)
<span style="color: #e44649;">#  define</span> <span style="color: #0184bc;">DBG</span>(...)
<span style="color: #e44649;">#else</span>
<span style="color: #e44649;">#  error</span>(<span style="color: #50a14f;">"ATRIP_DEBUG is not defined!"</span>)
<span style="color: #e44649;">#endif</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaaf4662" class="outline-3">
<h3 id="orgaaf4662"><span class="section-number-3">1.11</span> Include header</h3>
<div class="outline-text-3" id="text-1-11">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #e44649;">#pragma</span> once

<span style="color: #e44649;">#include</span> <span style="color: #50a14f;">&lt;atrip/Atrip.hpp&gt;</span>

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2021-10-13 Wed 13:45</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
